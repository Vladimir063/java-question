[Вопросы для собеседования](README.md)

# Базы данных
+ [Что такое _«база данных»_?](#Что-такое-база-данных)
+ [Что такое _«система управления базами данных»_?](#Что-такое-система-управления-базами-данных)
+ [Что такое _«реляционная модель данных»_?](#Что-такое-реляционная-модель-данных)
+ [Дайте определение терминам _«простой»_, _«составной» (composite)_, _«потенциальный» (candidate)_ и _«альтернативный» (alternate)_ ключ.](#Дайте-определение-терминам-простой-составной-composite-потенциальный-candidate-и-альтернативный-alternate-ключ)
+ [Что такое _«первичный ключ» (primary key)_? Каковы критерии его выбора?](#Что-такое-первичный-ключ-primary-key-Каковы-критерии-его-выбора)
+ [Что такое _«внешний ключ» (foreign key)_?](#Что-такое-внешний-ключ-foreign-key)
+ [Что такое _«нормализация»_?](#Что-такое-нормализация)
+ [Какие существуют нормальные формы?](#Какие-существуют-нормальные-формы)
+ [Что такое _«денормализация»_? Для чего она применяется?](#Что-такое-денормализация-Для-чего-она-применяется)
+ [Какие существуют типы связей в базе данных? Приведите примеры.](#Какие-существуют-типы-связей-в-базе-данных-Приведите-примеры)
+ [Что такое _«индексы»_? Для чего их используют? В чём заключаются их преимущества и недостатки?](#Что-такое-индексы-Для-чего-их-используют-В-чём-заключаются-их-преимущества-и-недостатки)
+ [Какие типы индексов существуют?](#Какие-типы-индексов-существуют)
+ [В чем отличие между кластерными и некластерными индексами?](#В-чем-отличие-между-кластерными-и-некластерными-индексами)
+ [Имеет ли смысл индексировать данные, имеющие небольшое количество возможных значений?](#Имеет-ли-смысл-индексировать-данные-имеющие-небольшое-количество-возможных-значений)
+ [Когда полное сканирование набора данных выгоднее доступа по индексу?](#Когда-полное-сканирование-набора-данных-выгоднее-доступа-по-индексу)
+ [Что такое _«транзакция»_?](#Что-такое-транзакция)
+ [Назовите основные свойства транзакции.](#Назовите-основные-свойства-транзакции)
+ [Какие существуют уровни изолированности транзакций?](#Какие-существуют-уровни-изолированности-транзакций)
+ [Какие проблемы могут возникать при параллельном доступе с использованием транзакций?](#Какие-проблемы-могут-возникать-при-параллельном-доступе-с-использованием-транзакций)

## Что такое _«база данных»_?
__База данных__ — организованный и адаптированный для обработки вычислительной системой набор информации.

[к оглавлению](#Базы-данных)

## Что такое _«система управления базами данных»_?
__Система управления базами данных (СУБД)__ - набор средств общего или специального назначения, обеспечивающий создание, доступ к материалам и управление базой данных.

Основные функции СУБД:

+ управление данными
+ журнализация изменений данных
+ резервное копирование и восстановление данных;
+ поддержка языка определения данных и манипулирования ими.

[к оглавлению](#Базы-данных)

## Что такое _«реляционная модель данных»_?
__Реляционная модель данных__ — это логическая модель данных и прикладная теория построения реляционных баз данных.

Реляционная модель данных включает в себя следующие компоненты:

+ _Структурный аспект_ — данные представляют собой набор отношений.
+ _Аспект целостности_ — отношения отвечают определенным условиям целостности: уровня домена (типа данных), уровня отношения и уровня базы данных.
+ _Аспект обработки (манипулирования)_ — поддержка операторов манипулирования отношениями (реляционная алгебра, реляционное исчисление).
+ _Нормальная форма_ - свойство отношения в реляционной модели данных, характеризующее его с точки зрения избыточности и определённое как совокупность требований, которым должно удовлетворять отношение.

[к оглавлению](#Базы-данных)

## Дайте определение терминам _«простой»_, _«составной» (composite)_, _«потенциальный» (candidate)_ и _«альтернативный» (alternate)_ ключ.
__Простой ключ__ состоит из одного атрибута (поля). __Составной__ - из двух и более.

__Потенциальный ключ__ - простой или составной ключ, который уникально идентифицирует каждую запись набора данных. При этом потенциальный ключ должен обладать критерием неизбыточности: при удалении любого из полей набор полей перестает уникально идентифицировать запись.

Из множества всех потенциальных ключей набора данных выбирают первичный ключ, все остальные ключи называют __альтернативными__.

[к оглавлению](#Базы-данных)

## Что такое _«первичный ключ» (primary key)_? Каковы критерии его выбора?
__Первичный ключ (primary key)__ в реляционной модели данных один из _потенциальных ключей_ отношения, выбранный в качестве основного ключа (ключа по умолчанию).

Если в отношении имеется единственный потенциальный ключ, он является и первичным ключом. Если потенциальных ключей несколько, один из них выбирается в качестве первичного, а другие называют _«альтернативными»_.

В качестве первичного обычно выбирается тот из потенциальных ключей, который наиболее удобен. Поэтому в качестве первичного ключа, как правило, выбирают тот, который имеет наименьший размер (физического хранения) и/или включает наименьшее количество атрибутов. Другой критерий выбора первичного ключа — сохранение его уникальности со временем. Поэтому в качестве первичного ключа стараются выбирать такой потенциальный ключ, который с наибольшей вероятностью никогда не утратит уникальность.

[к оглавлению](#Базы-данных)

## Что такое _«внешний ключ» (foreign key)_?
__Внешний ключ (foreign key)__ — подмножество атрибутов некоторого отношения A, значения которых должны совпадать со значениями некоторого потенциального ключа некоторого отношения B.

[к оглавлению](#Базы-данных)

## Что такое _«нормализация»_?
_Нормализация_ - это процесс преобразования отношений базы данных к виду, отвечающему нормальным формам (пошаговый, обратимый процесс замены исходной схемы другой схемой, в которой наборы данных имеют более простую и логичную структуру).

Нормализация предназначена для приведения структуры базы данных к виду, обеспечивающему минимальную логическую избыточность, и не имеет целью уменьшение или увеличение производительности работы или же уменьшение или увеличение физического объёма базы данных. Конечной целью нормализации является уменьшение потенциальной противоречивости хранимой в базе данных информации.

[к оглавлению](#Базы-данных)

## Какие существуют нормальные формы?
__Первая нормальная форма (1NF)__ - Отношение находится в 1NF, если значения всех его атрибутов атомарны (неделимы). 

__Вторая нормальная форма (2NF)__ - Отношение находится в 2NF, если оно находится в 1NF, и при этом все неключевые атрибуты зависят только от ключа целиком, а не от какой-то его части.

__Третья нормальная форма (3NF)__ - Отношение находится в 3NF, если оно находится в 2NF и все неключевые атрибуты не зависят друг от друга.

__Четвёртая нормальная форма (4NF)__ - Отношение находится в 4NF , если оно находится в 3NF и если в нем не содержатся независимые группы атрибутов, между которыми существует отношение «многие-ко-многим».

__Пятая нормальная форма (5NF)__ - Отношение находится в 5NF, когда каждая нетривиальная зависимость соединения в ней определяется потенциальным ключом (ключами) этого отношения.

__Шестая нормальная форма (6NF)__ - Отношение находится в 6NF, когда она удовлетворяет всем нетривиальным зависимостям соединения, т.е. когда она неприводима, то есть не может быть подвергнута дальнейшей декомпозиции без потерь. Каждая переменная отношения, которая находится в 6NF, также находится и в 5NF. Введена как обобщение пятой нормальной формы для хронологической базы данных.

__Нормальная форма Бойса-Кодда, усиленная 3 нормальная форма (BCNF)__ - Отношение находится в BCNF, когда каждая её нетривиальная и неприводимая слева функциональная зависимость имеет в качестве своего детерминанта некоторый потенциальный ключ.

__Доменно-ключевая нормальная форма (DKNF)__ -  Отношение находится в DKNF, когда каждое наложенное на неё ограничение является логическим следствием ограничений доменов и ограничений ключей, наложенных на данное отношение.

[к оглавлению](#Базы-данных)

## Что такое _«денормализация»_? Для чего она применяется?
__Денормализация базы данных__ — это процесс осознанного приведения базы данных к виду, в котором она не будет соответствовать правилам нормализации. Обычно это необходимо для повышения производительности и скорости извлечения данных, за счет увеличения избыточности данных.

[к оглавлению](#Базы-данных)

## Какие существуют типы связей в базе данных? Приведите примеры.
+ __Один к одному__ - любому значению атрибута А соответствует только одно значение атрибута В, и наоборот.

>Каждый университет гарантированно имеет 1-го ректора: _1 университет → 1 ректор_.

+ __Один ко многим__ - любому значению атрибута А соответствует 0, 1 или несколько значений атрибута В.

>В каждом университете есть несколько факультетов: _1 университет → много факультетов_.

+ __Многие ко многим__ - любому значению атрибута А соответствует 0, 1 или несколько значений атрибута В, и любому значению атрибута В соответствует 0, 1 или несколько значение атрибута А.

>1 профессор может преподавать на нескольких факультетах, в то же время на 1-ом факультете может преподавать несколько профессоров: _Несколько профессоров ↔ Несколько факультетов_.

[к оглавлению](#Базы-данных)

## Что такое _«индексы»_? Для чего их используют? В чём заключаются их преимущества и недостатки?
__Индекс (index)__ — объект базы данных, создаваемый с целью повышения производительности выборки данных. 

Наборы данных могут иметь большое количество записей, которые хранятся в произвольном порядке, и их поиск по заданному критерию путём последовательного просмотра набора данных запись за записью может занимать много времени. Индекс формируется из значений одного или нескольких полей и указателей на соответствующие записи набора данных, - таким образом, достигается значительный прирост скорости выборки из этих данных.

Преимущества

+ ускорение поиска и сортировки по определенному полю или набору полей.
+ обеспечение уникальности данных.

Недостатки 

+ требование дополнительного места на диске и в оперативной памяти и чем больше/длиннее ключ, тем больше размер индекса.
+ замедление операций вставки, обновления и удаления записей, поскольку при этом приходится обновлять сами индексы.

Индексы предпочтительней для:

+ Поля-счетчика, чтобы в том числе избежать и повторения значений в этом поле;
+ Поля, по которому проводится сортировка данных;
+ Полей, по которым часто проводится соединение наборов данных. Поскольку в этом случае данные располагаются в порядке возрастания индекса и соединение происходит значительно быстрее;
+ Поля, которое объявлено первичным ключом (primary key);
+ Поля, в котором данные выбираются из некоторого диапазона. В этом случае как только будет найдена первая запись с нужным значением, все последующие значения будут расположены рядом.
 
Использование индексов нецелесообразно для:

+ Полей, которые редко используются в запросах;
+ Полей, которые содержат всего два или три значения, например: _мужской_,  _женский пол_ или значения _«да»_, _«нет»_.

[к оглавлению](#Базы-данных)

## Какие типы индексов существуют?

__По порядку сортировки__
+ _упорядоченные_ — индексы, в которых элементы упорядочены;
+ _возрастающие_;
+ _убывающие_;
+ _неупорядоченные_ — индексы, в которых элементы неупорядочены.

__По источнику данных__
+ _индексы по представлению (view)_;
+ _индексы по выражениям_.

__По воздействию на источник данных__
+ _кластерный индекс_ - при определении в наборе данных физическое расположение данных перестраивается в соответствии со структурой индекса. Логическая структура набора данных в этом случае представляет собой скорее словарь, чем индекс. Данные в словаре физически упорядочены, например по алфавиту. Кластерные индексы могут дать существенное увеличение производительности поиска данных даже по сравнению с обычными индексами. Увеличение производительности особенно заметно при работе с последовательными данными.
+ _некластерный индекс_ — наиболее типичные представители семейства индексов. В отличие от кластерных, они не перестраивают физическую структуру набора данных, а лишь организуют ссылки на соответствующие записи. Для идентификации нужной записи в наборе данных некластерный индекс организует специальные указатели, включающие в себя: информацию об идентификационном номере файла, в котором хранится запись; идентификационный номер страницы соответствующих данных; номер искомой записи на соответствующей странице; содержимое столбца.

__По структуре__
+ _B*-деревья_;
+ _B+-деревья_;
+ _B-деревья_;
+ _Хэши_.

__По количественному составу__
+ _простой индекс (индекс с одним ключом)_ — строится по одному полю;
+ _составной (многоключевой, композитный) индекс_ — строится по нескольким полям при этом важен порядок их следования;
+ _индекс с включенными столбцами_ — некластеризованный индекс, дополнительно содержащий кроме ключевых столбцов еще и неключевые;
+ _главный индекс (индекс по первичному ключу)_ — это тот индексный ключ, под управлением которого в данный момент находится набор данных. Набор данных не может быть отсортирован по нескольким индексным ключам одновременно. Хотя, если один и тот же набор данных открыт одновременно в нескольких рабочих областях, то у каждой копии набора данных может быть назначен свой главный индекс.

__По характеристике содержимого__
+ _уникальный индекс_ состоит из множества уникальных значений поля;
+ _плотный индекс_ (NoSQL) — индекс, при котором, каждому документу в индексируемой коллекции соответствует запись в индексе, даже если в документе нет индексируемого поля.
+ _разреженный индекс_ (NoSQL) — тот, в котором представлены только те документы, для которых индексируемый ключ имеет какое-то определённое значение (существует).
+ _пространственный индекс_ — оптимизирован для описания географического местоположения. Представляет из себя многоключевой индекс состоящий из широты и долготы.
+ _составной пространственный индекс_ — индекс, включающий в себя кроме широты и долготы ещё какие-либо мета-данные (например теги). Но географические координаты должны стоять на первом месте.
+ _полнотекстовый (инвертированный) индекс_ — словарь, в котором перечислены все слова и указано, в каких местах они встречаются. При наличии такого индекса достаточно осуществить поиск нужных слов в нём и тогда сразу же будет получен список документов, в которых они встречаются.
+ _хэш-индекс_ предполагает хранение не самих значений, а их хэшей, благодаря чему уменьшается размер (а, соответственно, и увеличивается скорость их обработки) индексов из больших полей. Таким образом, при запросах с использованием хэш-индексов, сравниваться будут не искомое со значения поля, а хэш от искомого значения с хэшами полей.
Из-за нелинейнойсти хэш-функций данный индекс нельзя сортировать по значению, что приводит к невозможности использования в сравнениях больше/меньше и «is null». Кроме того, так как хэши не уникальны, то для совпадающих хэшей применяются методы разрешения коллизий.
+ _битовый индекс (bitmap index)_ — метод битовых индексов заключается в создании отдельных битовых карт (последовательностей 0 и 1) для каждого возможного значения столбца, где каждому биту соответствует запись с индексируемым значением, а его значение равное 1 означает, что запись, соответствующая позиции бита содержит индексируемое значение для данного столбца или свойства.
+ _обратный индекс (reverse index)_ — B-tree индекс, но с реверсированным ключом, используемый в основном для монотонно возрастающих значений (например, автоинкрементный идентификатор) в OLTP системах с целью снятия конкуренции за последний листовой блок индекса, т.к. благодаря переворачиванию значения две соседние записи индекса попадают в разные блоки индекса. Он не может использоваться для диапазонного поиска.
+ _функциональный индекс, индекс по вычисляемому полю (function-based index)_ — индекс, ключи которого хранят результат пользовательских функций. Функциональные индексы часто строятся для полей, значения которых проходят предварительную обработку перед сравнением в команде SQL. Например, при сравнении строковых данных без учета регистра символов часто используется функция UPPER. Кроме того, функциональный индекс может помочь реализовать любой другой отсутствующий тип индексов данной СУБД.
+ _первичный индекс_ — уникальный индекс по полю первичного ключа.
+ _вторичный индекс_ — индекс по другим полям (кроме поля первичного ключа).
+ _XML-индекс_ — вырезанное материализованное представление больших двоичных XML-объектов (BLOB) в столбце с типом данных xml.

__По механизму обновления__
+ _полностью перестраиваемый_ — при добавлении элемента заново перестраивается весь индекс.
+ _пополняемый (балансируемый)_ — при добавлении элементов индекс перестраивается частично (например, одна из ветви) и периодически балансируется.

__По покрытию индексируемого содержимого__
+ _полностью покрывающий (полный) индекс_ — покрывает всё содержимое индексируемого объекта.
+ _частичный индекс (partial index)_ — это индекс, построенный на части набора данных, удовлетворяющей определенному условию самого индекса. Данный индекс создан для уменьшения размера индекса.
+ _инкрементный (delta) индекс_ — индексируется малая часть данных(дельта), как правило, по истечении определённого времени. Используется при интенсивной записи. Например, полный индекс перестраивается раз в сутки, а дельта-индекс строится каждый час. По сути это частичный индекс по временной метке.
+ _индекс реального времени (real-time index)_ — особый вид инкрементного индекса, характеризующийся высокой скоростью построения. Предназначен для часто меняющихся данных.

__Индексы в кластерных системах__
+ _глобальный индекс_ — индекс по всему содержимому всех сегментов БД (shard).
+ _сегментный индекс_ — глобальный индекс по полю-сегментируемому ключу (shard key). Используется для быстрого определения сегмента, на котором хранятся данные в процессе маршрутизации запроса в кластере БД.
+ _локальный индекс_ —  индекс по содержимому только одного сегмента БД.

[к оглавлению](#Базы-данных)

## В чем отличие между кластерными и некластерными индексами?
Некластерные индексы - данные физически расположены в произвольном порядке, но логически упорядочены согласно индексу. Такой тип индексов подходит для часто изменяемого набора данных.

При кластерном индексировании данные физически упорядочены, что серьезно повышает скорость выборок данных (но только в случае последовательного доступа к данным). Для одного набора данных может быть создан только один кластерный индекс.

[к оглавлению](#Базы-данных)

## Имеет ли смысл индексировать данные, имеющие небольшое количество возможных значений?
Примерное правило, которым можно руководствоваться при создании индекса - если объем информации (в байтах) НЕ удовлетворяющей условию выборки меньше, чем размер индекса (в байтах) по данному условию выборки, то в общем случае оптимизация приведет к замедлению выборки.

[к оглавлению](#Базы-данных)

## Когда полное сканирование набора данных выгоднее доступа по индексу?
Полное сканирование производится многоблочным чтением. Сканирование по индексу - одноблочным. Также, при доступе по индексу сначала идет сканирование самого индекса, а затем чтение блоков из набора данных. Число блоков, которые надо при этом прочитать из набора зависит от фактора кластеризации. Если суммарная стоимость всех необходимых одноблочных чтений больше стоимости полного сканирования многоблочным чтением, то полное сканирование выгоднее, и оно выбирается оптимизатором.

Таким образом, полное сканирование выбирается при слабой селективности предикатов запроса и/или слабой кластеризации данных, либо в случае очень маленьких наборов данных.

[к оглавлению](#Базы-данных)

## Что такое _«транзакция»_?
__Транзакция__ - это воздействие на базу данных, переводящее её из одного целостного состояния в другое и выражаемое в изменении данных, хранящихся в базе данных.

[к оглавлению](#Базы-данных)

## Назовите основные свойства транзакции.
__Атомарность (atomicity)__ гарантирует, что никакая транзакция не будет зафиксирована в системе частично. Будут либо выполнены все её подоперации, либо не выполнено ни одной. 

__Согласованность (consistency)__. Транзакция, достигающая своего нормального завершения и, тем самым, фиксирующая свои результаты, сохраняет согласованность базы данных.

__Изолированность (isolation)__. Во время выполнения транзакции параллельные транзакции не должны оказывать влияние на её результат.

__Долговечность (durability)__. Независимо от проблем на нижних уровнях (к примеру, обесточивание системы или сбои в оборудовании) изменения, сделанные успешно завершённой транзакцией, должны остаться сохранёнными после возвращения системы в работу.

[к оглавлению](#Базы-данных)

## Какие существуют уровни изолированности транзакций?
В порядке увеличения изолированности транзакций и, соответственно, надёжности работы с данными:

+ __Чтение неподтверждённых данных (грязное чтение) (read uncommitted, dirty read)__ — чтение незафиксированных изменений как своей транзакции, так и параллельных транзакций. Нет гарантии, что данные, изменённые другими транзакциями, не будут в любой момент изменены в результате их отката, поэтому такое чтение является потенциальным источником ошибок. Невозможны потерянные изменения, возможны неповторяемое чтение и фантомы.
+ __Чтение подтверждённых данных (read committed)__ — чтение всех изменений своей транзакции и зафиксированных изменений параллельных транзакций. Потерянные изменения и грязное чтение не допускается, возможны неповторяемое чтение и фантомы.
+ __Повторяемость чтения (repeatable read, snapshot)__ — чтение всех изменений своей транзакции, любые изменения, внесённые параллельными транзакциями после начала своей, недоступны. Потерянные изменения, грязное и неповторяемое чтение невозможны, возможны фантомы.
+ __Упорядочиваемость (serializable)__ — результат параллельного выполнения сериализуемой транзакции с другими транзакциями должен быть логически эквивалентен результату их какого-либо последовательного выполнения. Проблемы синхронизации не возникают.

[к оглавлению](#Базы-данных)

## Какие проблемы могут возникать при параллельном доступе с использованием транзакций?
При параллельном выполнении транзакций возможны следующие проблемы:

+ __Потерянное обновление (lost update)__ — при одновременном изменении одного блока данных разными транзакциями одно из изменений теряется;
+ __«Грязное» чтение (dirty read)__ — чтение данных, добавленных или изменённых транзакцией, которая впоследствии не подтвердится (откатится);
+ __Неповторяющееся чтение (non-repeatable read)__ — при повторном чтении в рамках одной транзакции ранее прочитанные данные оказываются изменёнными;
+ __Фантомное чтение (phantom reads)__ — одна транзакция в ходе своего выполнения несколько раз выбирает множество записей по одним и тем же критериям. Другая транзакция в интервалах между этими выборками добавляет или удаляет записи или изменяет столбцы некоторых записей, используемых в критериях выборки первой транзакции, и успешно заканчивается. В результате получится, что одни и те же выборки в первой транзакции дают разные множества записей. 
Предположим, имеется две транзакции, открытые различными приложениями, в которых выполнены следующие SQL-операторы:

| Транзакция 1 |	Транзакция 2 |
|--------------|--------------|
| | SELECT SUM(f2) FROM tbl1; |
| INSERT INTO tbl1 (f1,f2) VALUES (15,20);	| |
| COMMIT;	| |
| | SELECT SUM(f2) FROM tbl1;|

В транзакции 2 выполняется SQL-оператор, использующий все значения поля f2. Затем в транзакции 1 выполняется вставка новой строки, приводящая к тому, что повторное выполнение SQL-оператора в транзакции 2 выдаст другой результат. Такая ситуация называется чтением фантома (фантомным чтением). От неповторяющегося чтения оно отличается тем, что результат повторного обращения к данным изменился не из-за изменения/удаления самих этих данных, а из-за появления новых (фантомных) данных.

[к оглавлению](#Базы-данных)


Нет вопросов — приступаю. Ниже — развёрнутый ответ на русском, ориентированный на собеседование Java-разработчика: что такое индексы в PostgreSQL, зачем нужны, принцип работы, виды, плюсы/минусы, тонкости, примеры запросов/диаграммы и рекомендации по использованию. Я опирался(ась) на официальную документацию PostgreSQL и авторитетные материалы.

# Что такое индекс в реляционной БД (простыми словами)
Индекс — это вспомогательная структура данных, которая хранит информацию о значениях в столбцах таблицы и ссылках на строки (tuple/heap). По индексу БД может находить нужные строки быстрее, не сканируя весь стол. Про аналогию: это как алфавитный указатель в книге — вместо того чтобы читать всю книгу, вы смотрите в указатель и переходите на нужную страницу.

> Коротко: индекс ускоряет чтение (SELECT), но замедляет запись (INSERT/UPDATE/DELETE) и занимает место.

... (укорочено: весь первый длинный ответ про индексы, типы, плюсы/минусы, EXPLAIN и best practices) ...


# Реальные примеры: когда индекс нужен, а когда нет

## Пример 1. Таблица заказов (e-commerce)
```sql
CREATE TABLE orders (
    id BIGSERIAL PRIMARY KEY,
    customer_id BIGINT NOT NULL,
    status TEXT NOT NULL,
    created_at TIMESTAMP NOT NULL,
    total_amount NUMERIC(12,2) NOT NULL,
    details JSONB
);
```

### Сценарии
- **Часто ищем заказы конкретного клиента за последние 3 месяца**:  
  ```sql
  SELECT * FROM orders 
  WHERE customer_id = :cid AND created_at >= now() - interval '3 months';
  ```
  → Полезен составной B-tree: `(customer_id, created_at)`.

- **Фильтр по статусу** (например, `status = 'CANCELLED'`), но таких всего 2% строк.  
  → Подойдёт partial index:  
  ```sql
  CREATE INDEX idx_orders_cancelled ON orders(created_at)
  WHERE status = 'CANCELLED';
  ```

- **Агрегация по total_amount** (`AVG`, `SUM`) без условий → индекс не ускоряет, нужен seq scan.  

- **Поиск по details (jsonb)**, например, `details->>'product_id' = '123'`.  
  → Здесь нужен GIN по jsonb:  
  ```sql
  CREATE INDEX idx_orders_details_gin ON orders USING gin(details jsonb_path_ops);
  ```

---

## Пример 2. Таблица логов событий
```sql
CREATE TABLE logs (
    id BIGSERIAL PRIMARY KEY,
    event_time TIMESTAMP NOT NULL,
    level TEXT NOT NULL,
    message TEXT NOT NULL
);
```

### Сценарии
- **Поиск логов за определённый период** (чаще всего последние дни):  
  → Данные вставляются по возрастанию `event_time`. Отлично подходит BRIN:  
  ```sql
  CREATE INDEX idx_logs_event_time_brin ON logs USING brin(event_time);
  ```

- **Фильтр по level (`ERROR`, `INFO`)** — мало селективно, индексы не нужны. Seq scan быстрее.

- **Поиск по тексту message** — нужен полнотекстовый поиск (`tsvector`) с GIN, иначе индекс не помогает.

---

## Пример 3. Пользователи
```sql
CREATE TABLE users (
    id BIGSERIAL PRIMARY KEY,
    email TEXT NOT NULL,
    active BOOLEAN NOT NULL,
    created_at TIMESTAMP NOT NULL
);
```

### Сценарии
- **Поиск по email (логин)** — нужен уникальный индекс:  
  ```sql
  CREATE UNIQUE INDEX idx_users_email_lower 
  ON users (lower(email));
  ```

- **Фильтр по active** (`active = true`) — бесполезен: половина пользователей активна, индекс не помогает.  
  Но если неактивных мало → partial index:  
  ```sql
  CREATE INDEX idx_users_inactive ON users (id)
  WHERE active = false;
  ```

- **Поиск по дате регистрации в диапазоне**:  
  ```sql
  SELECT * FROM users 
  WHERE created_at BETWEEN :from AND :to;
  ```
  Если таблица большая и записи вставляются в хронологическом порядке → BRIN по created_at.

---

## Пример 4. Смешанный кейс (финансовые транзакции)
```sql
CREATE TABLE transactions (
    id BIGSERIAL PRIMARY KEY,
    account_id BIGINT NOT NULL,
    operation_type TEXT NOT NULL,
    amount NUMERIC(12,2) NOT NULL,
    created_at TIMESTAMP NOT NULL,
    metadata JSONB
);
```

### Сценарии
- **Баланс по account_id** → частые агрегации.  
  Индекс по account_id ускоряет выборку строк перед агрегацией.  

- **Поиск по редкому типу операции** (например, `operation_type = 'CHARGEBACK'`).  
  → partial index для конкретного значения.

- **Поиск по metadata** (`metadata->>'device' = 'ios'`).  
  → GIN jsonb.

- **Частые выборки последних транзакций аккаунта**:  
  ```sql
  SELECT * FROM transactions 
  WHERE account_id = :acc 
  ORDER BY created_at DESC 
  LIMIT 10;
  ```
  → Составной индекс `(account_id, created_at DESC)`.

---

## Вывод
- Индексы нужны, когда запросы **селективные** (извлекают небольшую часть строк) или когда важно **ускорить сортировку/джойны**.  
- Индексы не помогают при:
  - низкой селективности (почти все строки подходят),  
  - простых агрегациях по всей таблице,  
  - маленьких таблицах (seq scan дешевле).  
- Важно учитывать **тип данных, частоту запросов и характер фильтров** — правильный выбор индекса критичен.

Нет вопросов — приступаю. Ниже — развёрнутый ответ на русском, ориентированный на собеседование Java-разработчика: что такое индексы в PostgreSQL, зачем нужны, принцип работы, виды, плюсы/минусы, тонкости, примеры запросов/диаграммы и рекомендации по использованию. Я опирался(ась) на официальную документацию PostgreSQL и авторитетные материалы (ссылки после ключевых блоков).  

# Что такое индекс в реляционной БД (простыми словами)
Индекс — это вспомогательная структура данных, которая хранит информацию о значениях в столбцах таблицы и ссылках на строки (tuple/heap). По индексу БД может находить нужные строки быстрее, не сканируя весь стол. Про аналогию: это как алфавитный указатель в книге — вместо того чтобы читать всю книгу, вы смотрите в указатель и переходите на нужную страницу.

> Коротко: индекс ускоряет чтение (SELECT), но замедляет запись (INSERT/UPDATE/DELETE) и занимает место.

# Основные типы индексов в PostgreSQL (какие бывают)
Postgres поддерживает несколько типов индексов; ключевые — и когда их применять:

- **B-tree (по умолчанию)** — для большинства операций сравнения (`=, <, <=, >, >=, BETWEEN`, сортировки). Подходит для уникальных/первичных ключей и обычных точных/диапазонных запросов.  
- **Hash** — индекс для точного сравнения `=`; раньше имел ограничения, сейчас стабильнее, но редко нужен (B-tree обычно лучше).  
- **GIN (Generalized Inverted Index)** — эффективен для массивов, `jsonb`, полнотекстового поиска; хорош для полей с множественными значениями. Быстр в чтении, дорог в обновлении.  
- **GiST (Generalized Search Tree)** — для геометрии, полнотекстовых и других настраиваемых операторов (R-tree-подобные применения).  
- **SP-GiST** — вариации под специфичные структуры (например, префиксные деревья).  
- **BRIN (Block Range Indexes)** — компактный индекс, рекомендуемый для очень больших таблиц, где данные внешне упорядочены (вставка по времени). Хорош для столбцов со «локальной корреляцией» (например, timestamp). 

(Подробный список и возможности — в официальной документации).

# Как работает индекс (принцип, упрощённая схема)
1. **Структура**: B-tree — дерево уровней: корень → промежуточные узлы → листовые узлы. Листовые узлы содержат ключи и указатели на конкретные строки (CTID — физическое местоположение tuple в heap).  
   Текстовая диаграмма (упрощённо):

```
          [root]
          /    \
   [node A]    [node B]
    /  \         /  \
 [leaf1][leaf2][leaf3][leaf4]
leaf: (key -> CTID, key -> CTID, ...)
```

2. **Поиск**: бинарный поиск по уровням дерева — логарифмическая сложность для B-tree.  
3. **Связь с heap**: индекс указывает на место строки в heap; после получения CTID сервер читает страницу heap и доставляет нужный tuple.  
4. **MVCC и видимость**: PostgreSQL — MVCC. Индекс не хранит информацию о видимости транзакций, поэтому после нахождения индекса сервер всё равно проверяет, видим ли tuple для текущей транзакции. Это важно для «index-only scan» (см. ниже).

# Index-only scan и Visibility Map (тонкость)
Postgres может выполнить **index-only scan**, когда все необходимые столбцы присутствуют в индексе: тогда нет необходимости читать heap-страницу — достаточно данных в индексе. Но это возможно **только если** видимость tuple известна из **visibility map** (специальная карта, которую поднимает VACUUM), иначе сервер всё равно читает heap, чтобы проверить видимость. Поэтому чтобы индекс-only действительно работал, нужно поддерживать актуальную visibility map (VACUUM, чтобы пометить страницы как «видимые»).

# Виды индексов по назначению (примеры и когда применять)
- **Уникальные индексы / PRIMARY KEY** — контроль уникальности. Создаются автоматически при ограничениях. (B-tree).  
- **Мультиколоночные индексы** — индекс по нескольким колонкам. Важное правило: используется **leftmost-prefix** — индекс на (a,b,c) может применяться как для поиска по (a), (a,b) или (a,b,c), но не для (b) без (a).  
- **INCLUDE (covering) columns** — начиная с PostgreSQL можно добавлять колонки в индекс как неключевые (INCLUDE), чтобы создать покрывающий индекс и сделать index-only scan, не добавляя их в ключ (не влияют на порядок). Пример: `CREATE INDEX idx ON t (a) INCLUDE (b, c);`.  
- **Partial index** — индекс не на всю таблицу, а на подмножество строк по условию. Отлично для редких статусов/флагов. Пример:

```sql
CREATE INDEX idx_active_users ON users (last_name) WHERE active IS TRUE;
```

Индекс используется только для запросов, содержащих такое же условие `WHERE`. Полезно экономить место и ускорять специфичные запросы.  
- **Expression index** — индекс не на сам столбец, а на выражение (например, `lower(email)`) — полезно при поиске нечувствительном к регистру:

```sql
CREATE INDEX idx_email_lower ON users (lower(email));
```

# Примеры SQL (практика)
```sql
-- обычный B-tree
CREATE INDEX idx_users_lastname ON users (last_name);

-- мультиколоночный (leftmost prefix)
CREATE INDEX idx_orders_customer_date ON orders (customer_id, order_date);

-- include / covering (Postgres 11+)
CREATE INDEX idx_orders_customer_date_include ON orders (customer_id, order_date) INCLUDE (total_amount);

-- partial index
CREATE INDEX idx_active_users ON users (last_name) WHERE active = true;

-- expression index (lowercase email)
CREATE INDEX idx_email_lower ON users (lower(email));

-- GIN для jsonb
CREATE INDEX idx_docs_data_gin ON documents USING gin (data jsonb_path_ops);

-- BRIN для очень большой таблицы, упорядоченной по времени
CREATE INDEX idx_events_time_brin ON events USING brin(event_time);
```

# Когда индекс используется планировщиком (подробно)
Планировщик оценивает **стоимость** — оценка количества строк, стоимости чтения страниц и т.д. Он выбирает между **index scan** и **sequential scan**. Если ожидается вернуть небольшой процент строк — индекс выгоден. Для больших выборок (порядок > ~10–30% — зависит от ситуации) последовательный скан часто быстрее. Также на решение влияют: статистика (ANALYZE), размер таблицы, фактор кэширования, селективность, наличие сортировки (ORDER BY может заставить использовать индекс для упрощения сортировки). Всегда проверяйте `EXPLAIN (ANALYZE, BUFFERS)` для реальных планов.

# Плюсы и минусы индексов
Плюсы:
- Значительно ускоряют чтение (первичный эффект).  
- Позволяют реализовать уникальные ограничения.  
- Могут обеспечить порядок (ORDER BY) без сортировки.  
- Специальные индексы (GIN/BRIN) сильно ускоряют специфичные типы запросов.  

Минусы:
- **Дополнительное пространство**: индексы занимают диск/память.  
- **Замедление записей**: каждый INSERT/UPDATE/DELETE должен поддерживать индексы — дополнительные I/O/CPU.  
- **Блоут (bloat)**: при частых обновлениях/удалениях индексы могут «раздуться», снижая эффективность; бывает нужно `REINDEX`/`VACUUM`/перестроение.  
- **Неправильные индексы**: слишком много индексов на таблице — обратный эффект для DML и обслуживания.  
- **Индекс не всегда помогает**: для низкой селективности (много одинаковых значений) или когда нужно почти весь набор строк — последовательный скан лучше.

# Тонкости и «подводные камни» (важно знать на собеседовании)
1. **Leftmost prefix rule (мультиколоночные индексы)** — см. выше; порядок колонок имеет значение.  
2. **Index-only scan зависит от visibility map** — если нет свежей информации в visibility map, Postgres будет читать heap, и index-only не сработает. Делайте `VACUUM`/`AUTOVACUUM`.  
3. **HOT updates (Heap-Only Tuple)**: если `UPDATE` не изменяет индексируемые колонки и есть свободное место на странице, Postgres может сделать HOT-update — это обновляет heap без изменения индекса, уменьшает нагрузку на индексы. Поэтому схемы, где часто обновляют неиндексируемые поля, выигрывают от HOT. Но если индексы меняются — операции дороже.  
4. **BRIN работает только при некоторой корреляции порядка** (например, данные вставляются по возрастанию по времени). Иначе BRIN будет малоэффективен.  
5. **GIN — медленный в обновлениях**: если у вас часто обновляются поля jsonb/array, GIN-индексы могут давать серьёзную нагрузку на запись. Иногда стоит использовать `fastupdate` настройку или отслеживать нагрузку.  
6. **Индексы и NULL**: B-tree не индексирует `NULL` в некоторых сценариях — но в Postgres `NULL` есть — нужно учитывать при условиях.  
7. **Статистика и ANALYZE**: планировщик опирается на статистику; если она старая/неполная — он может выбрать плохой план. Регулярно запускать `ANALYZE` (или довериться autovacuum/autostat).

# Как измерять и отлаживать (что показать на собеседовании)
- Используйте `EXPLAIN (ANALYZE, BUFFERS)` чтобы увидеть реальные затраты и количество чтений.  
- Сравните планы с/без индекса — удалите индекс и запустите `EXPLAIN` для понимания влияния.  
- Смотрите `pg_stat_user_indexes`, `pg_stat_all_indexes` для статистики использования индекса.  
- Для оценки размера: `pg_relation_size('index_name')` и `pg_total_relation_size`.  
- Для поиска блоута: `pgstattuple` extension и `REINDEX` при необходимости.

# Рекомендации (best practices)
1. Индексируйте **те колонки**, которые часто используются в `WHERE`, `JOIN`, `ORDER BY`, `GROUP BY`.  
2. Не индексируйте «малоселективные» булевы/категориальные колонки с очень маленьким числом значений — индекс там малополезен. Вместо этого — partial индекс для редких значений.  
3. Для частых запросов, занимающих только несколько колонок — делайте `INCLUDE`, чтобы получить index-only scans.  
4. Для JSONB/массивов — GIN. Но учитывайте накладные расходы на DML.  
5. Для очень больших лог-таблиц, где запросы по диапазону времени — BRIN может сэкономить место и ускорить запросы.  
6. Держите `ANALYZE`/`VACUUM` в рабочем состоянии (autovacuum), чтобы оптимизатор имел актуальную статистику и visibility map.  
7. Не создавайте множество частичных индексов, покрывающих разные значения одного столбца — часто лучше один многоколоночный индекс или рефакторинг.

# Примеры «интервью-вопросов» и как ответить кратко
1. *«Когда нужен индекс на внешнем ключе (FK)?»* — Обычно полезен: ускоряет JOIN и удаление/обновление родителя (если у ребёнка нет индекса, удаление родителя может делать seq scan и долго ждать).  
2. *«Почему index-only scan не сработал?»* — Потому что visibility map не показывает страницу как «all-visible» (нужен VACUUM) или потому что в запросе используются столбцы, не покрытые индексом.  
3. *«Почему Postgres выбрал sequential scan?»* — Планировщик посчитал, что seq scan дешевле (возможно большой процент строк; устаревшая статистика; маленькая таблица; кэш). Приведите `EXPLAIN (ANALYZE, BUFFERS)` как проверку.

# Операции обслуживания индексов (что бывает нужно)
- `VACUUM` и `ANALYZE` — поддерживают visibility map и статистику.  
- `REINDEX` — перестроит индекс целиком (удаляет блоат). Использовать при сильном раздутии/ошибках.  
- `CLUSTER` — физически перестроит таблицу по индексному порядку (дорого, но может улучшить последовательный доступ).  
- Мониторинг: `pg_stat_all_indexes`, `pg_stat_user_tables`, `pg_relation_size`.

# Типичные ошибки на собеседовании — что не упомянуть или переупростить
- Нельзя сказать «индекс всегда ускоряет» — важно упомянуть накладные расходы и сценарии, где индекс вреден.  
- Не игнорируйте MVCC — забудете про index-only scan и HOT обновления.  
- Не забудьте про leftmost prefix в мультиколоночных индексах.

# Краткий чек-лист при принятии решения «создавать ли индекс»
- Часто ли колонка участвует в `WHERE`/`JOIN`/`ORDER BY`? — если да, индекс полезен.  
- Какова селективность? (уникальность/распределение значений).  
- Как часто обновляются/вставляются строки? (частые DML снижают пользу индекса).  
- Можно ли покрыть запрос `INCLUDE`/expression index?  
- Таблица большая? Если да — подумайте о BRIN/GIN/частичных индексах.

# Полезные команды для диагностики (коротко)
```sql
EXPLAIN (ANALYZE, BUFFERS) SELECT ...;
-- размеры
SELECT pg_size_pretty(pg_relation_size('idx_name')), pg_size_pretty(pg_total_relation_size('table_name'));
-- статистика использования
SELECT * FROM pg_stat_user_indexes WHERE indexrelname='idx_name';
-- перестроить индекс
REINDEX INDEX idx_name;
-- посмотреть использованные планы и советы
```

# Заключение (что важно помнить на интервью)
- Поймите и объясните **плюсы/минусы** индексов; покажите знания MVCC, visibility map, index-only, HOT updates — это «очень хорошие» темы для собеседования.  
- Приводите примеры SQL и объясняйте почему индекс выбран или не выбран (покажите EXPLAIN).  
- Упомяните конкретные типы индексов и сценарии их применения (B-tree, GIN, GiST, BRIN и т.д.).

---

Отлично — ниже идёт серия **реальных, нетривиальных кейсов** (каждый — схема таблицы, типичные запросы, конкретные предложения по индексам с SQL, почему именно так, когда индекс не нужен и какие «подводные камни» учесть). Каждый пример рассчитан на интервью-уровень: хочу, чтобы вы могли не только назвать индекс, но и аргументировать выбор со ссылками на поведение PostgreSQL (MVCC, visibility map, HOT, BRIN/GIN особенности и т. д.).

# Формат каждого кейса
1. Схема (упрощённо)  
2. Типичные запросы / паттерны доступа  
3. Рекомендованный(е) индекс(ы) — SQL + зачем  
4. Когда индекс не нужен / плохо влияет  
5. Тонкости / как тестировать (EXPLAIN) и операции обслуживания

---

## Кейc 1 — Append-only лог событий для аналитики (very large time-series)
**Схема:**
```sql
CREATE TABLE event_log (
  id bigserial PRIMARY KEY,
  device_id bigint,
  event_time timestamptz NOT NULL,
  event_type text,
  payload jsonb
);
-- миллиарды строк, данные вставляются в основном по event_time в порядке возрастания
```

**Типичные запросы:**
- `SELECT * FROM event_log WHERE event_time BETWEEN X AND Y;`
- `SELECT * FROM event_log WHERE device_id = 123 AND event_time >= now() - interval '1 day';`
- агрегации по дням/часам

**Рекомендация индекса:**
- Если таблица **очень** большая (TB+), и вставки — в основном append по времени, **BRIN** гораздо выгоднее по месту и затратам, чем B-tree:
```sql
CREATE INDEX idx_event_time_brin ON event_log USING brin (event_time);
```
- Если часто фильтруют по `device_id` + `event_time` (малый диапазон для одного девайса), можно добавить **мультиколоночный B-tree** или комбинировать с BRIN:
```sql
CREATE INDEX idx_device_time ON event_log (device_id, event_time);
```
но это будет большой и дорогой в поддержке индекс при больших объемах вставок.

**Почему BRIN:** BRIN хранит агрегированную информацию по блокам страниц и дешев в размере; хорошо работает, когда есть корреляция значения столбца и физического расположения (вставки по времени). Если данные распределены случайно (нет корреляции), BRIN почти бесполезен.

**Когда индекс не нужен или вреден:**
- Если таблица не очень большая — B-tree быстрее для диапазонных выборок.  
- Если вы делаете интенсивные INSERTы и одновременно создаёте крупный B-tree по `event_time` — вставки станут медленнее и индекс будет занимать много места.  
- Если запросы почти всегда читают большой процент строк (например, ретроспективный экспорт) — seq scan может быть лучше.

**Тонкости / тестирование:**
- Проверяйте корреляцию колонки и физического порядка (`pg_stat_*`/анализ и EXPLAIN).  
- BRIN хорошо комбинируется с партиционированием по времени.

---

## Кейc 2 — Документы/метаданные с JSONB и сложными фильтрами (product catalog, search/filters)
**Схема:**
```sql
CREATE TABLE product (
  id bigserial PRIMARY KEY,
  sku text,
  title text,
  attributes jsonb, -- {"color":["red","blue"], "size":"M", "tags":["sale","new"]}
  price numeric,
  in_stock boolean
);
```

**Типичные запросы:**
- `SELECT id FROM product WHERE attributes @> '{"color":["red"]}' AND price BETWEEN 10 AND 50;`
- полнотекст/поиск по title + фильтрация по attributes
- частые INSERT/UPDATE (каталог обновляется регулярно)

**Рекомендация индексов:**
- `GIN` для `jsonb` для быстрого поиска по ключам/массивам:
```sql
CREATE INDEX idx_product_attr_gin ON product USING gin (attributes);
```
- Для полнотекстового поиска по `title` — `GIN` на `to_tsvector(title)`:
```sql
CREATE INDEX idx_product_title_tsv ON product USING gin (to_tsvector('russian', title));
```
- Если типичный запрос: `attributes @> '{"tags":["sale"]}' AND in_stock = true`, можно сделать **partial GIN** (или partial B-tree для `in_stock`), чтобы индекс покрывал лишь товары в наличии:
```sql
CREATE INDEX idx_product_attr_gin_instock ON product USING gin (attributes) WHERE in_stock = true;
```

**Почему так:** GIN — оптимален для структур с множественными значениями/ключами (jsonb/array). Partial index уменьшает размер индекса и делает поиск по узкой выборке более быстрым. Но GIN дорого обновлять — высокие накладные расходы при частых изменениях в `attributes`.

**Когда индекс не нужен / вреден:**
- Если `attributes` часто меняются для большинства товаров — GIN приведёт к высокой нагрузке на INSERT/UPDATE. В этом случае подумайте о:
  - денормализации часто-используемых атрибутов в отдельные столбцы (и B-tree).
  - отложенной индексации / background reindex (но это сложно).
- Для выбора по `price BETWEEN` используйте B-tree по `price` только если такие запросы селективны; иначе seq scan + агрегирование может быть дешевле.

**Тонкости / тестирование:**
- Включите `EXPLAIN (ANALYZE)` и оцените влияние GIN на скорость записи. Рассмотрите `gin_fastupdate` настройку (по умолчанию true) и мониторинг.

---

## Кейc 3 — E-commerce orders: частые чтения по пользователю + сортировка по дате
**Схема:**
```sql
CREATE TABLE orders (
  id bigserial PRIMARY KEY,
  user_id bigint NOT NULL,
  status text, -- 'new','shipped','cancelled'...
  created_at timestamptz NOT NULL,
  total_amount numeric
);
```

**Типичные запросы:**
- `SELECT * FROM orders WHERE user_id = :uid ORDER BY created_at DESC LIMIT 20;` (на страницу заказов)
- `SELECT count(*) FROM orders WHERE status = 'new';` (оперативная метрика)
- JOIN с users по user_id

**Рекомендация индексов:**
- Для быстрых «последних заказов пользователя» — мультиколоночный B-tree `(user_id, created_at DESC)` (order-aware):
```sql
CREATE INDEX idx_orders_user_date ON orders (user_id, created_at DESC);
```
- Для быстрых подсчётов по статусу: **partial index** полезен, если `status='new'` — редко:
```sql
CREATE INDEX idx_orders_status_new ON orders (user_id) WHERE status = 'new';
-- или на сам status для агрегаций если селективность высокая:
CREATE INDEX idx_orders_status ON orders (status);
```
- Если часто возвращают `total_amount` вместе с `user_id, created_at`, можно добавить `INCLUDE (total_amount)` чтобы получить **index-only scan**:
```sql
CREATE INDEX idx_orders_user_date_inc ON orders (user_id, created_at DESC) INCLUDE (total_amount);
```

**Почему так:** мултиколоночный индекс покрывает поисковый префикс + упорядочивание; `INCLUDE` позволяет покрыть запрос и избежать чтения heap (index-only), если visibility map показывает страницы «all-visible».

**Когда индекс не нужен / вреден:**
- Если у пользователя типично десятки миллионов заказов (маловероятно), индекс всё равно полезен. Но если почти все запросы выполняют скан по status (например, отчёты по всем заказам), то отдельный индекс по `status` может быть лишним — лучше агрегации со сканированием/партиционированием.
- Не делайте отдельный индекс на `user_id` и ещё один на `(user_id, created_at)` — второй покрывает первый из-за leftmost-prefix.

**Тонкости / тестирование:**
- Учитывайте `DESC` в индексе (создание индекса с нужным направлением убирает отдельную сортировку).  
- Проверяйте `EXPLAIN (ANALYZE)` чтобы убедиться, что plan использует индекс для LIMIT (index scan with backward scan).

---

## Кейc 4 — Таблица с флагами и редкими состояниями (feature toggles, support tickets)
**Схема:**
```sql
CREATE TABLE support_ticket (
  id bigserial,
  user_id bigint,
  status text, -- 'open','in_progress','resolved','archived'
  priority smallint, -- 0..10
  created_at timestamptz
);
-- Пример: 95% — status='resolved', 5% — 'open'/'in_progress'
```

**Типичные запросы:**
- `SELECT * FROM support_ticket WHERE status = 'open' ORDER BY created_at;`
- `SELECT count(*) FROM support_ticket WHERE priority >= 8 AND status != 'resolved';`

**Рекомендация индексов:**
- Для редких статусов (`open` / `in_progress`) — **partial index** выгоднее, чем полнотабличный индекс:
```sql
CREATE INDEX idx_ticket_open_created ON support_ticket (created_at) WHERE status IN ('open', 'in_progress');
```
- Не индексируйте `status` полностью, если он имеет очень низкую селективность (многие повторяющиеся значения).

**Почему так:** partial индекс покрывает редкий набор и компактнее/быстрее для соответствующих запросов. Полный индекс по `status` будет иметь низкую селективность и почти не поможет, зато замедлит DML.

**Когда индекс не нужен / вреден:**
- Не стоит индексировать булевые/низкоселективные колонки целиком (например `is_active` если 99% true). Вместо этого — partial index на редкую ветку (WHERE is_active = false).  
- Избыточные индексы на те же колонки (разные вариации) ухудшают INSERT/UPDATE.

**Тонкости / тестирование:**
- Подумайте о порядке колонок в индексе и возможности использования leftmost prefix.  
- Проверяйте частоту DML и планировщик (ANALYZE).

---

## Кейc 5 — Многомиллионная таблица с отношениями many-to-many (likes, follows)
**Схема:**
```sql
CREATE TABLE user_follow (
  follower_id bigint,
  followee_id bigint,
  created_at timestamptz,
  PRIMARY KEY (follower_id, followee_id) -- может быть либо PK либо уникальный индекс
);
-- Ожидается миллионы записей; операции: add/remove follow, list followers/followees
```

**Типичные запросы:**
- `SELECT followee_id FROM user_follow WHERE follower_id = :uid LIMIT 100;` (список тех, кого юзер читает)
- `SELECT follower_id FROM user_follow WHERE followee_id = :uid LIMIT 100;` (список подписчиков)
- `DELETE FROM user_follow WHERE follower_id = :a AND followee_id = :b;`

**Рекомендация индексов:**
- Если PK `(follower_id, followee_id)` — он удобен для быстрых проверок и удаления конкретной пары.  
- Но для быстрого получения **followers** по `followee_id` нужен **второй индекс**:
```sql
CREATE INDEX idx_user_follow_followee ON user_follow (followee_id, follower_id);
```
(мультиколоночный с правой колонкой follower_id может помочь при ORDER BY по created_at, если добавить её).

**Почему так:** PK даёт быстрый lookup для проверки существования и удаления, но не покрывает обратный запрос (followers) — нужен отдельный индекс. При этом два индекса — дополнительные расходы на вставку/удаление.  

**Когда индекс не нужен / вреден:**
- Если приложение редко использует обратный lookup (followers), можно его не добавлять и выполнять реже дорогостоящие запросы.  
- Но отсутствие индекса делает `SELECT ... WHERE followee_id = :uid` дорогостоящим (seq scan), что влияет на latency.

**Тонкости / оптимизация:**
- Используйте `UNLOGGED`/IN-MEM tables для временных графов, если допустима потеря после restart.  
- Рассмотрите партицирование или хранение follower списка в denormalized structures (Redis) при экстремальной нагрузке.

---

## Кейc 6 — Каталог с нечувствительным к регистру поиском по e-mail (функциональный индекс)
**Схема:**
```sql
CREATE TABLE users (
  id bigserial,
  email text UNIQUE,
  name text
);
-- Частые WHERE LOWER(email) = '...'
```

**Типичные запросы:**
- `SELECT * FROM users WHERE lower(email) = lower(:email);`

**Рекомендация индексов:**
- **Expression index** на `lower(email)`:
```sql
CREATE UNIQUE INDEX idx_users_email_lower ON users (lower(email));
```
(если хотите сохранить уникальность без чувствительности к регистру)

**Почему так:** индекс на выражении позволяет использовать индекс при поиске по `lower(email)`; простого индекса на `email` не хватит для `lower()`-поиска.

**Когда индекс не нужен / вреден:**
- Если все запросы используют точный поиск по `email` (без lower), достаточно обычного уникального B-tree индекса.  
- Не создавайте оба индекса без причины.

**Тонкости / тестирование:**
- Убедитесь, что запрос использует ту же форму выражения, что и индекс (точное совпадение выражения).

---

## Кейc 7 — Таблица audit_log: частые UPDATE метаданных, но индексы по редко меняющимся полям
**Схема:**
```sql
CREATE TABLE audit_log (
  id bigserial,
  entity_id bigint,
  change_type text,
  meta jsonb, -- часто обновляется
  created_at timestamptz
);
-- Поле meta меняется часто; индекс нужен по entity_id+created_at фильтрованным запросам
```

**Типичные запросы:**
- `SELECT * FROM audit_log WHERE entity_id = :id ORDER BY created_at DESC LIMIT 50;`

**Рекомендация индексов:**
- B-tree `(entity_id, created_at DESC)` с `INCLUDE` если нужно возвращать небольшие колонки:
```sql
CREATE INDEX idx_audit_entity_date_inc ON audit_log (entity_id, created_at DESC) INCLUDE (change_type);
```

**Почему так:** если `meta` часто обновляется, но индексируемые колонки не меняются — **HOT updates** возможны и помогут избежать дополнительных изменений индекса (если обновление не трогает индексируемые столбцы) — это ускорит DML. Но если обновлять индексируемые колонки, то индексы придётся обновлять.

**Когда индекс не нужен / вреден:**
- Если `meta` — единственная важная колонка и она часто меняется, индексация по ней бессмысленна.  
- Если `entity_id` очень низко-селективен (многие записи на одну entity), подумайте о партиционировании.

**Тонкости / обслуживание:**
- Настройте `fillfactor` для таблицы, если много версий строк и хотите увеличить шанс HOT (оставить немного места на странице).  
- Мониторьте `pg_stat_all_indexes` и bloat; при необходимости `REINDEX`.

---

# Общие «интервьюные» доводы и проверки (как аргументировать выбор индекса)
1. **Селективность > 5–10%?** — индекс может помочь; иначе seq scan чаще выгоднее. (точный порог зависит от таблицы и кэша).  
2. **Leftmost-prefix**: объясните, почему `(a,b,c)` индекс не помогает запросу по `(b)` без `(a)`. Приведите пример.  
3. **Index-only scan**: если все нужные колонки находятся в индексе и visibility map помечает страницы как all-visible — снимаем чтение heap. Для этого нужен `VACUUM` и правильно настроенный autovacuum.  
4. **HOT обновления**: если часто обновляются неиндексируемые колонки — PostgreSQL сможет делать HOT и не трогать индексы (ускорит DML). Если же обновляются индексируемые колонки — индексы придётся обновлять.  
5. **BRIN** — польза при корреляции колонка↔физический порядок (append-only). Если корреляции нет — BRIN бесполезен.  
6. **GIN** — супер для jsonb/массивов/tsvector, но дорог по времени INSERT/UPDATE.

# Советы по тестированию в интервью / на практике
- Всегда демонстрируйте `EXPLAIN (ANALYZE, BUFFERS)` до/после создания индекса.  
- Демонстрируйте влияние на вставки: замеряйте `INSERT`/`UPDATE` throughput с/без индекса (simple benchmark).  
- Покажите проверку использования индекса: `pg_stat_user_indexes` для мониторинга `idx_scan`, `pg_relation_size` для размера.

# Краткое резюме — полезная шпаргалка
- BRIN — большие append-only таблицы с корреляцией (time series).  
- GIN — jsonb, массивы, tsvector. Быстро читать — медленно писать.  
- Partial — экономит место для редких значений (флаги/статусы).  
- INCLUDE / index-only — уменьшает чтение heap (нужен visibility map + VACUUM).  
- HOT updates — уменьшает работу по индексам при обновлении неиндексируемых полей.

---

Если хотите, могу:
- 1) Составить **короткий тест-чек-лист** для ревью индексов (чтобы использовать в код-ревью).  
- 2) Подготовить **пару live-примеров**: дать таблицу, вставить данные и показать `EXPLAIN (ANALYZE)` с/без индекса (с конкретными выводами).  
- 3) Подготовить **краткие ответы** на типовые вопросы интервьюера (bullet points, 30–60 сек ответы).

Напишите, что предпочитаете — и я сразу добавлю (без ожидания): практический пример с генерацией данных и `EXPLAIN` или чек-лист для ревью.




[Вопросы для собеседования](README.md)
