### Подробное описание 7 уровней модели OSI

#### 1. Физический уровень (Physical Layer)

Физический уровень отвечает за передачу необработанных битов по физическим носителям: кабелям, оптоволокну, радиоволнам и т.д. Он определяет электрические и механические характеристики, скорости передачи данных, типы разъемов и среду передачи. Java-разработчику важно понимать физический уровень, чтобы правильно проектировать приложения, чувствительные к задержкам и пропускной способности.

На этом уровне решаются вопросы сигнализации и синхронизации. Например, формируются сигналы 0 и 1 в виде напряжений или частотных импульсов. Также реализуются методы кодирования данных для минимизации ошибок передачи. Для беспроводных приложений учитываются параметры передачи, такие как частота, мощность сигнала и помехи.

Физический уровень не занимается логикой обработки данных — его задача исключительно передать биты. Java-разработчики обычно взаимодействуют с ним косвенно через сетевые интерфейсы или драйверы, но понимание особенностей передачи помогает оптимизировать приложения, работающие с реальным временем, потоковым видео или аудио.

Без правильного функционирования физического уровня невозможна передача данных, независимо от корректности работы вышележащих уровней. Поэтому знание физического уровня помогает при диагностике проблем с сетью и выборе подходящей сетевой инфраструктуры.

#### 2. Канальный уровень (Data Link Layer)

Канальный уровень обеспечивает надежную передачу данных между двумя узлами, соединенными напрямую. Он разбивает потоки битов на **кадры**, добавляет контрольные суммы для обнаружения ошибок и управляет доступом к среде передачи. В Ethernet, Wi-Fi и других сетях канальный уровень реализует протоколы передачи данных.

На этом уровне решаются вопросы адресации узлов с использованием MAC-адресов. Это позволяет локально доставлять кадры на конкретные устройства в одной сети. Java-разработчик редко взаимодействует с этим уровнем напрямую, но при создании сетевых приложений полезно понимать, как данные локально передаются и проверяются.

Канальный уровень также управляет конфликтами в среде передачи, например через протокол CSMA/CD в Ethernet. Он играет ключевую роль в обеспечении надежности локальных сетей и минимизации потерь данных.

Для сетевой отладки важно понимать, как кадры формируются и проверяются, так как ошибки на этом уровне могут вызывать потерю пакетов, задержки и необходимость повторной передачи, что влияет на производительность приложений.

#### 3. Сетевой уровень (Network Layer)

Сетевой уровень отвечает за **маршрутизацию и логическую адресацию** данных между узлами сети, даже если они находятся в разных подсетях. Основным протоколом является IP, который определяет, как пакеты перемещаются от источника к назначению через маршрутизаторы.

На этом уровне формируются пакеты с IP-заголовками, включающими адреса отправителя и получателя. Маршрутизаторы анализируют эти заголовки и определяют оптимальный путь для передачи данных. Java-разработчик должен понимать IP-адресацию и маски подсетей для настройки сетевых приложений и правильной работы с сокетами.

Также сетевой уровень управляет фрагментацией пакетов для передачи через различные каналы с ограниченной пропускной способностью. Это важно для передачи больших объемов данных и потоков мультимедиа.

Понимание сетевого уровня помогает разработчику оптимизировать сетевые приложения, предотвращать потерю пакетов, управлять задержками и обеспечивать корректное взаимодействие между различными сетями.

#### 4. Транспортный уровень (Transport Layer)

Транспортный уровень обеспечивает **надежную передачу данных между конечными точками**, управление потоком и контроль ошибок. Основные протоколы: TCP (надежный) и UDP (быстрый, но ненадежный). TCP гарантирует доставку пакетов в правильном порядке, UDP используется для потокового видео и аудио.

Транспортный уровень сегментирует данные на пакеты и добавляет заголовки с номерами последовательности, контрольными суммами и портами источника и назначения. Java-разработчик взаимодействует с транспортным уровнем через сокеты, выбирая TCP для надежных соединений и UDP для быстрого обмена.

TCP реализует трехстороннее рукопожатие (handshake) для установления соединения, управление окном передачи (flow control) и повторную передачу потерянных сегментов. UDP, напротив, не гарантирует доставку, что делает его менее надежным, но более быстрым.

Знание транспортного уровня важно для оптимизации производительности приложений, обработки ошибок передачи и построения масштабируемых сетевых систем.

#### 5. Сеансовый уровень (Session Layer)

Сеансовый уровень управляет **сеансами связи** между приложениями. Он обеспечивает установку, поддержание и завершение сеансов, а также синхронизацию обмена данными. В современных приложениях этот уровень часто реализуется библиотеками и протоколами, такими как RPC или TLS.

Сеансовый уровень позволяет определить начало и конец обмена, восстановление после сбоев и контроль диалогов между клиентом и сервером. Для Java-разработчика понимание этого уровня важно при работе с распределенными системами и веб-приложениями.

Он также управляет логикой синхронизации данных, например, поддерживая контроль точек восстановления (checkpointing) и согласованность при длительных транзакциях. Это особенно актуально в базах данных и многопользовательских приложениях.

Хотя Java-разработчик редко пишет код напрямую для сеансового уровня, знания о нем помогают правильно использовать существующие фреймворки для управления соединениями и безопасности.

#### 6. Представительный уровень (Presentation Layer)

Представительный уровень отвечает за **преобразование данных в стандартный формат**, который может быть понятен приложению. Он занимается кодировкой, сжатием, шифрованием и дешифрованием данных. Например, преобразование текстовых данных в UTF-8 или JSON, а также обработка SSL/TLS.

На этом уровне данные могут быть сжаты для уменьшения объема передаваемой информации, что важно для производительности сетевых приложений. Также реализуется шифрование для обеспечения безопасности передачи.

Java-разработчик часто взаимодействует с представительным уровнем через библиотеки для сериализации/десериализации данных (например, Jackson для JSON) и средства шифрования (javax.crypto, SSLContext).

Понимание этого уровня помогает разрабатывать безопасные и совместимые приложения, а также обеспечивать корректное взаимодействие между различными системами и протоколами.

#### 7. Прикладной уровень (Application Layer)

Прикладной уровень предоставляет интерфейс для взаимодействия с пользователем или другим приложением. Протоколы: HTTP, FTP, SMTP, DNS и т.д. Этот уровень формирует данные, которые будут переданы на нижние уровни, и обрабатывает данные, полученные от них.

Java-разработчик работает напрямую с прикладным уровнем, используя API и библиотеки для HTTP, WebSocket, почтовых протоколов, REST и SOAP. На этом уровне реализуются логика бизнес-приложений и обмен информацией между системами.

Прикладной уровень также управляет обработкой ошибок, сессиями пользователя и взаимодействием с другими сервисами. Он обеспечивает удобство использования и интеграцию приложений.

Понимание прикладного уровня критично для разработки клиент-серверных приложений, веб-сервисов и API, обеспечивая надежное и эффективное взаимодействие между пользователями и системами.



### TCP (Transmission Control Protocol)

TCP — это транспортный протокол, обеспечивающий **надежную доставку данных**. Он устанавливает соединение между клиентом и сервером (handshake), сегментирует данные на пакеты, гарантирует их доставку и правильный порядок. TCP используется в ситуациях, где важна корректность данных, например, HTTP, FTP, базы данных.

Особенности TCP:

* Надежность доставки.
* Контроль последовательности и ошибок.
* Управление потоком данных (flow control).
* Соединение ориентированное (connection-oriented).

### HTTP (HyperText Transfer Protocol)

HTTP — протокол прикладного уровня для передачи гипертекста, используемый в веб-приложениях. Он работает поверх TCP и является **без состояния (stateless)**: каждый запрос независим от предыдущих.

Особенности HTTP:

* Методы: GET, POST, PUT, DELETE и другие.
* Заголовки запросов и ответов для передачи метаданных.
* Поддержка куки и сессий для управления состоянием.
* HTTPS — защищенная версия HTTP с использованием SSL/TLS.

### Практическая значимость для Java-разработчика

* Использование `java.net` пакета для работы с сокетами (Socket, ServerSocket).
* Работа с HTTP через `HttpURLConnection` или современные библиотеки (`HttpClient`, Spring RestTemplate).
* Понимание различий между TCP и UDP для выбора протокола передачи.
* Знание модели OSI помогает отлаживать сетевые проблемы и оптимизировать сетевое взаимодействие.

Эти знания позволяют Java-разработчику создавать сетевые приложения, корректно обрабатывать соединения и понимать принципы работы клиент-серверной архитектуры.

### SOAP (Simple Object Access Protocol)

SOAP — это протокол для обмена структурированными сообщениями между компьютерами в сети. Он используется для взаимодействия между различными приложениями, независимо от их платформы и языка программирования. Главная цель SOAP — стандартизировать способ отправки запросов и получения ответов по сети.

Протокол SOAP основан на XML. Сообщение SOAP содержит заголовок (header) и тело (body), где находятся данные и инструкции для выполнения операции. Использование XML делает сообщения легко читаемыми, переносимыми и совместимыми с различными системами.

SOAP работает поверх разных транспортных протоколов, чаще всего HTTP, но также может использовать SMTP, TCP или другие. Это позволяет интегрировать приложения через интернет или корпоративные сети, обеспечивая надежную и безопасную передачу данных.

SOAP поддерживает расширяемость, стандарты безопасности и обработку ошибок. В заголовке сообщения можно включать информацию о безопасности, а в теле — код ошибок и результаты выполнения. Благодаря этим возможностям SOAP широко применяется в корпоративных системах и интеграционных сервисах.

**Пример**: Представим веб-сервис для интернет-магазина. Клиентское приложение отправляет SOAP-запрос с информацией о заказе, сервер получает сообщение, обрабатывает его и возвращает SOAP-ответ с подтверждением заказа. Все данные структурированы в XML и могут быть прочитаны различными системами.

Для Java-разработчика существуют библиотеки для работы с SOAP, такие как JAX-WS. Они позволяют создавать клиентские и серверные приложения, обрабатывать запросы и ответы, генерировать код по WSDL и легко интегрироваться с другими сервисами.

SOAP позволяет создавать надежные, стандартизированные и кроссплатформенные веб-сервисы, что делает его важным инструментом для интеграции сложных систем.

### Сравнение SOAP и REST

SOAP (Simple Object Access Protocol) и REST (Representational State Transfer) — это два подхода к созданию веб-сервисов, которые позволяют обмениваться данными между системами, но имеют принципиальные различия в архитектуре и применении.

#### 1. Архитектура

SOAP основан на строгом протоколе, использующем XML для всех сообщений, и поддерживает стандарты WS-Security, ACID-транзакции, надежную доставку и обработку ошибок. REST — это архитектурный стиль, использующий HTTP и стандарты веба. Данные могут передаваться в формате JSON, XML, текст или HTML, что делает REST более гибким и легким для интеграции с веб-приложениями.

#### 2. Протокол и транспорт

SOAP может работать поверх различных транспортных протоколов: HTTP, SMTP, TCP и других, обеспечивая расширяемость и поддержку корпоративных систем. REST использует только HTTP и опирается на стандартные методы: GET, POST, PUT, DELETE, что упрощает взаимодействие с веб-ресурсами.

#### 3. Сообщения и формат данных

SOAP строго использует XML для описания сообщений с заголовками и телом, что делает его стандартизированным и универсальным, но более тяжелым. REST поддерживает разнообразные форматы данных, чаще всего JSON, который легче для обработки и передачи по сети.

#### 4. Безопасность и стандарты

SOAP имеет встроенную поддержку WS-Security, шифрование, цифровые подписи, а также сложные схемы аутентификации и авторизации, что делает его предпочтительным для корпоративных систем с высокой требовательностью к безопасности. REST использует HTTPS для обеспечения безопасности и полагается на стандартные механизмы авторизации, такие как OAuth.

#### 5. Сложность и производительность

SOAP сложнее в реализации, требует больше ресурсов для обработки XML-сообщений, что влияет на производительность. REST проще, легковеснее и быстрее за счет минималистичного подхода и использования JSON, что делает его популярным для веб-приложений и мобильных сервисов.

#### 6. Применение

SOAP используется в банковских системах, телекоммуникациях и корпоративных интеграциях, где важны транзакции, надежность и безопасность. REST применяется в веб-приложениях, мобильных приложениях и сервисах с высоким трафиком, где важны скорость и простота интеграции.

**Вывод:** Выбор между SOAP и REST зависит от требований проекта. Если требуется высокая безопасность, сложные транзакции и поддержка корпоративных стандартов — SOAP. Если важны легкость, скорость и интеграция с веб-сервисами — REST.


### gRPC: Подробное описание

gRPC — это современный фреймворк для удалённого вызова процедур (RPC), разработанный компанией Google. Он позволяет создавать высокопроизводительные и надёжные распределённые приложения, обеспечивая прямое взаимодействие между клиентом и сервером.

gRPC использует протокол HTTP/2 для передачи данных, что даёт возможность мультиплексирования потоков, уменьшения задержек и поддержки двунаправленных потоков. Это делает gRPC более эффективным по сравнению с традиционным HTTP/1.x.

Основой gRPC является использование **Protocol Buffers (protobuf)** — компактного бинарного формата для сериализации данных. Protobuf позволяет описывать структуру сообщений, автоматически генерировать код для различных языков и экономить сетевой трафик.

gRPC поддерживает несколько видов вызовов:

1. **Unary RPC** — стандартный запрос-ответ.
2. **Server Streaming** — сервер отправляет поток сообщений клиенту.
3. **Client Streaming** — клиент отправляет поток сообщений серверу.
4. **Bidirectional Streaming** — клиент и сервер обмениваются потоками данных одновременно.

Для Java-разработчика gRPC предлагает готовые библиотеки и плагины для интеграции с проектами на Maven или Gradle. Генерация кода по protobuf делает взаимодействие с сервисом типизированным и безопасным.

**Пример:** Представим систему заказа еды. Клиентское приложение отправляет Unary RPC-запрос с информацией о заказе, сервер обрабатывает его и возвращает подтверждение. Для потоковых уведомлений, например, о статусе доставки, используется Server Streaming, чтобы клиент получал обновления в реальном времени.

gRPC обеспечивает строгую типизацию и поддержку контрактов между клиентом и сервером, что уменьшает количество ошибок и упрощает масштабирование системы. Он особенно полезен для микросервисной архитектуры, где множество сервисов взаимодействуют между собой.

Преимущества gRPC:

* Высокая производительность благодаря HTTP/2 и бинарной сериализации.
* Поддержка нескольких языков программирования.
* Простой и понятный контракт с использованием protobuf.
* Лёгкость масштабирования и интеграции микросервисов.

Недостатки gRPC:

* Не так распространён в веб-приложениях, как REST.
* Требует изучения protobuf и специфической инфраструктуры.
* Для браузеров нужно использовать gRPC-Web.

В итоге, gRPC — это мощный инструмент для построения распределённых систем и микросервисов с высокой производительностью и надёжностью. Java-разработчик может использовать его для создания быстрых и масштабируемых приложений с минимальной задержкой передачи данных.

### Сравнение gRPC и REST

gRPC и REST — это два подхода к созданию веб-сервисов, используемых для обмена данными между клиентом и сервером, но они имеют разные архитектурные принципы, протоколы и сценарии применения.

#### 1. Протокол и формат данных

REST использует HTTP/1.x и текстовые форматы данных, чаще всего JSON. Это делает его легким для интеграции с веб-приложениями и браузерами, но менее эффективным для передачи больших объемов данных.
gRPC использует HTTP/2 и бинарный формат Protocol Buffers (protobuf), что обеспечивает высокую производительность, меньшую задержку и экономию сетевого трафика.

#### 2. Типизация и контракты

REST не имеет строгой типизации: данные передаются в JSON, а структура объектов не контролируется автоматически. В gRPC структура данных строго типизирована через protobuf, что уменьшает вероятность ошибок и облегчает генерацию клиентского кода.

#### 3. Производительность и масштабируемость

REST имеет более высокий оверхед из-за текста и заголовков HTTP, особенно при больших объёмах данных. gRPC благодаря бинарной сериализации и мультиплексированию потоков HTTP/2 обеспечивает более высокую производительность и масштабируемость, особенно в микросервисных архитектурах.

#### 4. Поддержка потоков данных

REST поддерживает в основном стандартный запрос-ответ. gRPC предоставляет четыре типа вызовов: Unary, Server Streaming, Client Streaming и Bidirectional Streaming, что позволяет реализовывать двунаправленные и потоковые коммуникации.

#### 5. Безопасность

REST обычно использует HTTPS и стандартные механизмы авторизации, такие как OAuth. gRPC также работает поверх HTTPS и поддерживает TLS, а благодаря контрактам protobuf проще реализовать проверку и контроль целостности данных.

#### 6. Простота и распространённость

REST проще в реализации и широко распространён в веб-разработке. Браузеры и большинство клиентских библиотек сразу поддерживают REST. gRPC требует изучения protobuf и специфических библиотек, но предоставляет преимущества для внутренних сервисов и микросервисов.

#### Когда применять REST

* Для веб-приложений и мобильных приложений, где важна простота и совместимость.
* Когда требуется широкая поддержка браузерами и сторонними клиентами.
* Для публичных API и интеграции с внешними системами.

#### Когда применять gRPC

* Для микросервисной архитектуры с высокой нагрузкой.
* Когда важна высокая производительность, низкая задержка и потоковые коммуникации.
* Для строго типизированного взаимодействия между внутренними сервисами.

**Вывод:** REST лучше подходит для внешних, публичных и веб-ориентированных сервисов благодаря простоте и совместимости. gRPC идеален для высокопроизводительных внутренних сервисов и микросервисной архитектуры с большим количеством потоковых данных и строгой типизацией.


### Разница между REST и RESTful

REST (Representational State Transfer) — это архитектурный стиль для создания веб-сервисов, предложенный Роем Филдингом. Он описывает принципы и ограничения, которые должны соблюдаться для проектирования масштабируемых и удобных API, включая использование HTTP, идентификацию ресурсов, клиент-серверную архитектуру и безсостояние (stateless).

REST сам по себе является концепцией, набором правил, а не конкретной реализацией. Он определяет принципы взаимодействия между клиентом и сервером, но не накладывает строгих ограничений на структуру URL или используемые методы HTTP.

RESTful — это конкретная реализация API, которая строго следует принципам REST. RESTful API использует стандартные HTTP-методы (GET, POST, PUT, DELETE) для работы с ресурсами, идентифицирует ресурсы через URL, возвращает данные в стандартизированном формате (JSON или XML) и соблюдает безсостояние, что упрощает масштабирование и поддержку.

Основные различия:

1. **Принципы vs Реализация**: REST — это архитектурный стиль, RESTful — реализация REST, которая полностью следует его правилам.
2. **Стандартизация методов**: RESTful API использует четкие HTTP-методы для операций над ресурсами, а REST может использовать нестандартные подходы.
3. **URL и ресурсы**: В RESTful ресурсы четко идентифицируются через URL, а в REST структура URL может быть менее строгой.
4. **Безсостояние (Stateless)**: RESTful API строго соблюдает безсостояние, REST может частично это игнорировать.
5. **Форматы данных**: RESTful API чаще всего использует JSON, XML или другие стандартизованные форматы, REST может быть более гибким.

Пример RESTful API: для работы с пользователями URL выглядит как `/users`, методы: GET `/users` — получить список, POST `/users` — создать пользователя, PUT `/users/{id}` — обновить, DELETE `/users/{id}` — удалить.

Для Java-разработчика понимание различий важно при проектировании API: RESTful API обеспечивает стандартизацию, удобство для фронтенда и сторонних сервисов, а REST может использоваться для внутренних, более гибких решений.

### Идемпотентность в REST

Идемпотентность — это важный принцип в архитектуре REST, означающий, что многократное выполнение одного и того же запроса должно иметь **одинаковый эффект на сервере** и возвращать одинаковый результат, независимо от того, сколько раз запрос был отправлен.

Например, если клиент отправляет запрос для обновления информации о пользователе через PUT, повторные отправки этого запроса не должны изменять результат больше одного раза. Если первый запрос обновил данные, последующие запросы с теми же параметрами не меняют состояние и возвращают тот же результат.

HTTP-методы имеют разные свойства с точки зрения идемпотентности:

* **GET** — идемпотентный: повторные запросы просто возвращают данные без изменения состояния.
* **PUT** — идемпотентный: повторное обновление ресурса с одинаковыми данными не меняет его состояние после первого запроса.
* **DELETE** — идемпотентный: повторное удаление ресурса, который уже удалён, не вызывает ошибок и не меняет состояние системы.
* **POST** — не идемпотентный: каждый запрос может создавать новый ресурс или выполнять действие, которое изменяет состояние.

Идемпотентность важна для надёжности веб-приложений. В сетевых условиях запрос может быть отправлен повторно из-за таймаута, потери соединения или ошибок клиента. Если метод идемпотентен, повторная отправка не приведёт к непредвиденным изменениям данных.

Для Java-разработчика понимание идемпотентности помогает правильно проектировать REST API, выбирать методы HTTP для операций и обеспечивать предсказуемое поведение системы. Например, обновления ресурсов через PUT или PATCH должны быть идемпотентными, чтобы клиент мог безопасно повторять запросы при сетевых ошибках.

Идемпотентность также облегчает интеграцию с кэшированием, прокси-серверами и балансировщиками нагрузки, поскольку эти компоненты могут безопасно повторять или кэшировать запросы, не нарушая бизнес-логику.


# WebSocket в Spring Boot

## Что такое WebSocket

**WebSocket** —  — это протокол поверх TCP, который обеспечивает постоянное двустороннее соединение между клиентом и сервером. Он начинается как обычный HTTP-запрос (handshake), а затем «апгрейдится» в WebSocket-соединение.

Особенности:

* Постоянное соединение, в отличие от HTTP-запросов.
* Сервер может отправлять данные клиенту в любой момент.
* Идеально подходит для чатов, игр, уведомлений и стриминга данных.

| Особенность                              | Что важно понимать                                                                                                                       |
| ---------------------------------------  | ---------------------------------------------------------------------------------------------------------------------------------------- |
| 🔁 **Двусторонняя связь (Full-duplex)** | Клиент и сервер могут отправлять сообщения **в обе стороны** независимо и асинхронно.                                                     |
| 🔗 **Постоянное соединение**            | В отличие от HTTP, соединение **не закрывается после ответа**. Работает через `TCP` и держится открытым, пока одна из сторон не закроет. |
| 🚀 **Меньше накладных расходов**        | Нет постоянного открытия/закрытия TCP и HTTP-заголовков, поэтому отлично подходит для **реального времени**.                             |
| 🕹️ **Событийная модель**               | Работает через события (`onOpen`, `onMessage`, `onClose`, `onError`), удобно в асинхронных приложениях.                                  |
| 🧱 **Формат сообщений**                 | Поддерживает **текстовые (UTF-8)** и **бинарные** сообщения.                                                                             |
| 🔒 **Безопасность (WSS)**               | Поддерживает шифрование через TLS (`wss://` аналог `https://`).                                                                          |
| 🧠 **Стандартизированный API**          | Есть стандартные Java API: `javax.websocket` (Jakarta EE) и Spring `@ServerEndpoint` / `@EnableWebSocket`.                               |
| 🧩 **Совместимость с HTTP/1.1**         | Устанавливается через HTTP handshake:                                                                                                    |
| `GET /chat HTTP/1.1`                    |                                                                                                                                          |
| `Upgrade: websocket`                    |                                                                                                                                          |
| `Connection: Upgrade`                   |                                                                                                                                          |
| ⚡ **Поддержка масштабирования**         | При горизонтальном масштабировании нужно учитывать sticky sessions или Redis Pub/Sub для передачи сообщений между инстансами.            |
| 🧰 **Поддержка брокеров (Spring)**      | В Spring можно подключить STOMP-протокол и Message Broker (RabbitMQ, Kafka, Redis) для маршрутизации сообщений.                          |
| 🧹 **Управление подключениями**         | Нужно обрабатывать **отключения, heartbeats (ping/pong)** и переподключения клиентов.                                                    |
| 🧵 **Асинхронность**                    | В Java используется неблокирующая IO (NIO), особенно в Spring WebFlux, чтобы поддерживать тысячи соединений.                             |


---

## Настройка WebSocket в Spring Boot

### 1. Зависимости

Добавьте в `pom.xml`:

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-websocket</artifactId>
</dependency>
```

### 2. Конфигурация WebSocket

Создайте класс конфигурации:

```java
import org.springframework.context.annotation.Configuration;
import org.springframework.messaging.simp.config.MessageBrokerRegistry;
import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;
import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;

@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/ws")  // URL для подключения WebSocket
                .setAllowedOriginPatterns("*")  // Разрешаем CORS
                .withSockJS();  // Поддержка fallback
    }

    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        registry.enableSimpleBroker("/topic"); // Простая брокерная шина
        registry.setApplicationDestinationPrefixes("/app");
    }
}
```

* `/ws` — точка подключения для клиентов.
* `/app` — префикс для сообщений от клиента к серверу.
* `/topic` — префикс для сообщений, отправляемых сервером клиентам.

---

## Создание контроллера WebSocket

```java
import org.springframework.messaging.handler.annotation.MessageMapping;
import org.springframework.messaging.handler.annotation.SendTo;
import org.springframework.stereotype.Controller;

@Controller
public class ChatController {

    @MessageMapping("/chat.sendMessage") // Сообщения, отправляемые на /app/chat.sendMessage
    @SendTo("/topic/public") // Сообщения будут отправлены всем подписчикам /topic/public
    public ChatMessage sendMessage(ChatMessage message) {
        return message;
    }
}

class ChatMessage {
    private String content;
    private String sender;

    // геттеры и сеттеры
    public String getContent() { return content; }
    public void setContent(String content) { this.content = content; }
    public String getSender() { return sender; }
    public void setSender(String sender) { this.sender = sender; }
}
```

* Клиенты отправляют сообщения на `/app/chat.sendMessage`.
* Все клиенты, подписанные на `/topic/public`, получают сообщение.

---

## Клиентская часть (JavaScript)

```html
<!DOCTYPE html>
<html>
<head>
    <title>WebSocket Chat</title>
    <script src="https://cdn.jsdelivr.net/npm/sockjs-client@1.5.1/dist/sockjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js"></script>
</head>
<body>
    <script>
        let socket = new SockJS('/ws');
        let stompClient = Stomp.over(socket);

        stompClient.connect({}, function(frame) {
            console.log('Connected: ' + frame);
            stompClient.subscribe('/topic/public', function(message){
                console.log(JSON.parse(message.body));
            });
        });

        function sendMessage() {
            let chatMessage = {sender: 'User1', content: 'Hello!'};
            stompClient.send('/app/chat.sendMessage', {}, JSON.stringify(chatMessage));
        }
    </script>
    <button onclick="sendMessage()">Send Message</button>
</body>
</html>
```

* Подключаемся к `/ws` с помощью SockJS и STOMP.
* Подписываемся на `/topic/public` для получения сообщений.
* Отправляем сообщения на `/app/chat.sendMessage`.

---

## Применение WebSocket в Spring Boot

* **Чаты и мессенджеры**
* **Онлайн-игры**
* **Реальное время на дашбордах**
* **Уведомления и алерты**
* **Финансовые приложения (курсы, акции)**

---

## Итог

* WebSocket обеспечивает **двустороннее соединение**.
* В Spring Boot используется **STOMP поверх SockJS**.
* Конфигурация через `WebSocketMessageBrokerConfigurer`.
* Контроллеры обрабатывают сообщения через `@MessageMapping` и `@SendTo`.
* Клиенты подписываются на топики и отправляют сообщения на префиксы приложения.

---

# JWT токены (JSON Web Token)

Что это: компактный формат для передачи данных об аутентификации и правах пользователя.
Зачем: чтобы клиент (например, фронтенд) мог доказывать серверу, кто он, без постоянного запроса к базе.

Принцип:

После входа сервер выдает токен, подписанный секретом (обычно HMAC или RSA).

Клиент отправляет токен в заголовке Authorization: Bearer <token>.

Сервер проверяет подпись — и если всё ок, доверяет данным внутри (userId, roles и т.д.).

Плюсы: без сессий на сервере, кросс-платформенно, легко проверять.
Минусы: нельзя отозвать токен до истечения срока (если не хранить blacklist).
| Часть     | Что содержит                   | Для чего нужна                        |
| --------- | ------------------------------ | ------------------------------------- |
| Header    | Алгоритм и тип                 | Проверка способа подписи              |
| Payload   | Данные о пользователе и токене | Аутентификация и авторизация          |
| Signature | Криптографическая подпись      | Гарантирует целостность и подлинность |


# OAuth 2.0

Что это: протокол делегированной авторизации.
Зачем: позволяет одной системе (клиенту) получить ограниченный доступ к ресурсам другой системы без передачи пароля.

Пример:
Вы логинитесь в сторонний сайт через Google — сайт получает токен, который даёт ему доступ к вашему имени и e-mail, но не к паролю Google.

Главная идея:

Пользователь → Авторизация у провайдера (Google/Facebook и т.д.)

Провайдер выдает access_token → Клиент использует его для доступа к API.


