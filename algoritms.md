# Основные алгоритмы сортировки

## 1. Bubble Sort (Пузырьковая сортировка)

Bubble Sort — один из самых простых алгоритмов сортировки. Принцип работы заключается в многократном проходе по массиву и последовательном сравнении соседних элементов. Если соседние элементы стоят в неправильном порядке, они меняются местами. Проходы повторяются до тех пор, пока массив полностью не отсортирован.

Алгоритм стабилен (не меняет порядок равных элементов) и прост для реализации, но крайне неэффективен на больших данных. В худшем и среднем случае его сложность — O(n²), а в лучшем случае, когда массив уже отсортирован, O(n). Память используется минимальная — O(1), так как сортировка проводится на месте.

Bubble Sort хорошо подходит для небольших массивов или когда нужно быстро реализовать учебный пример сортировки. В Java его обычно используют только в учебных целях или для массивов размером до десятков элементов.

**Пример в Java:**

```java
for (int i = 0; i < arr.length - 1; i++) {
    for (int j = 0; j < arr.length - i - 1; j++) {
        if (arr[j] > arr[j + 1]) {
            int temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
        }
    }
}
```

---

## 2. Selection Sort (Сортировка выбором)

Selection Sort работает по принципу выбора наименьшего (или наибольшего) элемента на каждом шаге и его перемещения в начало массива. Проходы повторяются, пока все элементы не будут упорядочены.

Алгоритм имеет сложность O(n²) в худшем, среднем и лучшем случаях и использует O(1) памяти, так как сортировка проводится на месте. Он не является стабильным, так как равные элементы могут менять свой порядок при перемещении.

Selection Sort удобен для массивов, где важен минимальный расход памяти, но не критична скорость. В Java этот метод редко используют в реальных проектах из-за низкой производительности на больших данных.

**Пример в Java:**

```java
for (int i = 0; i < arr.length - 1; i++) {
    int minIndex = i;
    for (int j = i + 1; j < arr.length; j++) {
        if (arr[j] < arr[minIndex]) {
            minIndex = j;
        }
    }
    int temp = arr[minIndex];
    arr[minIndex] = arr[i];
    arr[i] = temp;
}
```

---

## 3. Insertion Sort (Сортировка вставками)

Insertion Sort строит отсортированную последовательность по одному элементу. На каждом шаге берётся следующий элемент из массива и вставляется в правильную позицию в уже отсортированной части.

Алгоритм стабилен и эффективен для почти отсортированных массивов. В худшем и среднем случаях сложность O(n²), в лучшем — O(n) для уже почти отсортированных данных. Память используется минимальная — O(1).

Insertion Sort идеален для небольших массивов или массивов с частично отсортированными данными. В Java часто используют этот алгоритм в комбинации с другими сортировками для малых подмассивов в `Arrays.sort()` для оптимизации.

**Пример в Java:**

```java
for (int i = 1; i < arr.length; i++) {
    int key = arr[i];
    int j = i - 1;
    while (j >= 0 && arr[j] > key) {
        arr[j + 1] = arr[j];
        j--;
    }
    arr[j + 1] = key;
}
```

---

## 4. Merge Sort (Сортировка слиянием)

Merge Sort — это алгоритм «разделяй и властвуй». Массив рекурсивно делится на две половины до тех пор, пока не останется массивы из одного элемента. Затем они объединяются в отсортированные последовательности с помощью процедуры слияния.

Сложность алгоритма стабильна — O(n log n) в любом случае. Память используется дополнительная — O(n), так как нужен временный массив для слияния. Алгоритм стабилен и хорошо масштабируется на больших данных.

Merge Sort часто применяют, когда требуется стабильная сортировка или сортировка больших массивов. В Java его используют внутри `Collections.sort()` для объектов, чтобы гарантировать стабильность сортировки.

**Пример в Java:**

```java
void mergeSort(int[] arr) {
    if (arr.length < 2) return;
    int mid = arr.length / 2;
    int[] left = Arrays.copyOfRange(arr, 0, mid);
    int[] right = Arrays.copyOfRange(arr, mid, arr.length);
    mergeSort(left);
    mergeSort(right);
    merge(arr, left, right);
}
void merge(int[] arr, int[] left, int[] right) {
    int i = 0, j = 0, k = 0;
    while (i < left.length && j < right.length) {
        if (left[i] <= right[j]) arr[k++] = left[i++];
        else arr[k++] = right[j++];
    }
    while (i < left.length) arr[k++] = left[i++];
    while (j < right.length) arr[k++] = right[j++];
}
```

---

## 5. Quick Sort (Быстрая сортировка)

Quick Sort также использует стратегию «разделяй и властвуй». Выбирается опорный элемент (pivot), после чего массив делится на две части: элементы меньше pivot и больше pivot. Затем рекурсивно сортируются обе части.

Средняя сложность алгоритма — O(n log n), худшая — O(n²) (редко, при неудачном выборе опорного элемента). Память — O(log n) для рекурсивного стека. Алгоритм не является стабильным, но в среднем работает очень быстро.

Quick Sort подходит для сортировки больших массивов с большим объёмом данных. В Java `Arrays.sort()` для примитивных типов использует модифицированную версию Quick Sort с оптимизацией для малых массивов и медианой из трёх элементов.

**Пример в Java:**

```java
void quickSort(int[] arr, int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}
int partition(int[] arr, int low, int high) {
    int pivot = arr[high];
    int i = low - 1;
    for (int j = low; j < high; j++) {
        if (arr[j] <= pivot) {
            i++;
            int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;
        }
    }
    int temp = arr[i + 1]; arr[i + 1] = arr[high]; arr[high] = temp;
    return i + 1;
}
```

---

## 6. Heap Sort (Сортировка кучей)

Heap Sort строит из массива бинарную кучу (max-heap) и затем последовательно извлекает максимальный элемент, помещая его в конец массива.

Сложность алгоритма — O(n log n) в худшем, среднем и лучшем случаях. Память — O(1), так как сортировка выполняется на месте. Алгоритм не является стабильным.

Heap Sort хорошо подходит для массивов большого размера, когда важна гарантированная временная сложность. В Java реализовать можно через `PriorityQueue`, хотя встроенные методы сортировки обычно используют Quick Sort или Merge Sort для оптимизации.

**Пример в Java:**

```java
void heapSort(int[] arr) {
    int n = arr.length;
    for (int i = n / 2 - 1; i >= 0; i--) heapify(arr, n, i);
    for (int i = n - 1; i >= 0; i--) {
        int temp = arr[0]; arr[0] = arr[i]; arr[i] = temp;
        heapify(arr, i, 0);
    }
}
void heapify(int[] arr, int n, int i) {
    int largest = i, l = 2*i+1, r = 2*i+2;
    if (l < n && arr[l] > arr[largest]) largest = l;
    if (r < n && arr[r] > arr[largest]) largest = r;
    if (largest != i) {
        int swap = arr[i]; arr[i] = arr[largest]; arr[largest] = swap;
        heapify(arr, n, largest);
    }
}
```

---

## Сравнительная таблица сортировок

| Алгоритм       | Сложность (Лучший) | Сложность (Средний) | Сложность (Худший) | Память   | Стабильность | Применение в Java                                                                   |
| -------------- | ------------------ | ------------------- | ------------------ | -------- | ------------ | ----------------------------------------------------------------------------------- |
| Bubble Sort    | O(n)               | O(n²)               | O(n²)              | O(1)     | Да           | Учебные задачи, маленькие массивы                                                   |
| Selection Sort | O(n²)              | O(n²)               | O(n²)              | O(1)     | Нет          | Минимальная память, учебные задачи                                                  |
| Insertion Sort | O(n)               | O(n²)               | O(n²)              | O(1)     | Да           | Малые или почти отсортированные массивы, внутри Arrays.sort() для малых подмассивов |
| Merge Sort     | O(n log n)         | O(n log n)          | O(n log n)         | O(n)     | Да           | Collections.sort() для объектов, стабильная сортировка                              |
| Quick Sort     | O(n log n)         | O(n log n)          | O(n²)              | O(log n) | Нет          | Arrays.sort() для примитивов, быстрая сортировка больших массивов                   |
| Heap Sort      | O(n log n)         | O(n log n)          | O(n log n)         | O(1)     | Нет          | Массивы больших размеров, гарантированная временная сложность                       |
