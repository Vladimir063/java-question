# Основные алгоритмы сортировки

## 1. Bubble Sort (Пузырьковая сортировка)

Bubble Sort — один из самых простых алгоритмов сортировки. Принцип работы заключается в многократном проходе по массиву и последовательном сравнении соседних элементов. Если соседние элементы стоят в неправильном порядке, они меняются местами. Проходы повторяются до тех пор, пока массив полностью не отсортирован.

Алгоритм стабилен (не меняет порядок равных элементов) и прост для реализации, но крайне неэффективен на больших данных. В худшем и среднем случае его сложность — O(n²), а в лучшем случае, когда массив уже отсортирован, O(n). Память используется минимальная — O(1), так как сортировка проводится на месте.

Bubble Sort хорошо подходит для небольших массивов или когда нужно быстро реализовать учебный пример сортировки. В Java его обычно используют только в учебных целях или для массивов размером до десятков элементов.

**Пример в Java:**

```java
for (int i = 0; i < arr.length - 1; i++) {
    for (int j = 0; j < arr.length - i - 1; j++) {
        if (arr[j] > arr[j + 1]) {
            int temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
        }
    }
}
```

---

## 2. Selection Sort (Сортировка выбором)

Selection Sort работает по принципу выбора наименьшего (или наибольшего) элемента на каждом шаге и его перемещения в начало массива. Проходы повторяются, пока все элементы не будут упорядочены.

Алгоритм имеет сложность O(n²) в худшем, среднем и лучшем случаях и использует O(1) памяти, так как сортировка проводится на месте. Он не является стабильным, так как равные элементы могут менять свой порядок при перемещении.

Selection Sort удобен для массивов, где важен минимальный расход памяти, но не критична скорость. В Java этот метод редко используют в реальных проектах из-за низкой производительности на больших данных.

**Пример в Java:**

```java
for (int i = 0; i < arr.length - 1; i++) {
    int minIndex = i;
    for (int j = i + 1; j < arr.length; j++) {
        if (arr[j] < arr[minIndex]) {
            minIndex = j;
        }
    }
    int temp = arr[minIndex];
    arr[minIndex] = arr[i];
    arr[i] = temp;
}
```

---

## 3. Insertion Sort (Сортировка вставками)

Insertion Sort строит отсортированную последовательность по одному элементу. На каждом шаге берётся следующий элемент из массива и вставляется в правильную позицию в уже отсортированной части.
 Процесс продолжается до тех пор, пока весь массив не окажется отсортированным. 
 это простой алгоритм сортировки, который работает аналогично тому, как мы сортируем карты в руке. Алгоритм проходит по массиву слева направо, постепенно формируя отсортированную последовательность элементов. Каждый новый элемент сравнивается с предыдущими элементами и вставляется в правильное положение среди уже отсортированных элементов.

Алгоритм стабилен и эффективен для почти отсортированных массивов. В худшем и среднем случаях сложность O(n²), в лучшем — O(n) для уже почти отсортированных данных. Память используется минимальная — O(1).

Insertion Sort идеален для небольших массивов или массивов с частично отсортированными данными. В Java часто используют этот алгоритм в комбинации с другими сортировками для малых подмассивов в `Arrays.sort()` для оптимизации.

**Пример в Java:**

```java
for (int i = 1; i < arr.length; i++) {
    int key = arr[i];
    int j = i - 1;
    while (j >= 0 && arr[j] > key) {
        arr[j + 1] = arr[j];
        j--;
    }
    arr[j + 1] = key;
}
```

---

## 4. Merge Sort (Сортировка слиянием)

Merge Sort — это алгоритм «разделяй и властвуй». Массив рекурсивно делится на две половины до тех пор, пока не останется массивы из одного элемента. Затем они объединяются в отсортированные последовательности с помощью процедуры слияния.

Сложность алгоритма стабильна — O(n log n) в любом случае. Память используется дополнительная — O(n), так как нужен временный массив для слияния. Алгоритм стабилен и хорошо масштабируется на больших данных.

Merge Sort часто применяют, когда требуется стабильная сортировка или сортировка больших массивов. В Java его используют внутри `Collections.sort()` для объектов, чтобы гарантировать стабильность сортировки.

**Пример в Java:**

```java
void mergeSort(int[] arr) {
    if (arr.length < 2) return;
    int mid = arr.length / 2;
    int[] left = Arrays.copyOfRange(arr, 0, mid);
    int[] right = Arrays.copyOfRange(arr, mid, arr.length);
    mergeSort(left);
    mergeSort(right);
    merge(arr, left, right);
}
void merge(int[] arr, int[] left, int[] right) {
    int i = 0, j = 0, k = 0;
    while (i < left.length && j < right.length) {
        if (left[i] <= right[j]) arr[k++] = left[i++];
        else arr[k++] = right[j++];
    }
    while (i < left.length) arr[k++] = left[i++];
    while (j < right.length) arr[k++] = right[j++];
}
```

---

## 5. Quick Sort (Быстрая сортировка)

Quick Sort также использует стратегию «разделяй и властвуй». Выбирается опорный элемент (pivot), после чего массив делится на две части: элементы меньше pivot и больше pivot. Затем рекурсивно сортируются обе части.

Средняя сложность алгоритма — O(n log n), худшая — O(n²) (редко, при неудачном выборе опорного элемента). Память — O(log n) для рекурсивного стека. Алгоритм не является стабильным, но в среднем работает очень быстро.

Quick Sort подходит для сортировки больших массивов с большим объёмом данных. В Java `Arrays.sort()` для примитивных типов использует модифицированную версию Quick Sort с оптимизацией для малых массивов и медианой из трёх элементов.

**Пример в Java:**

```java
void quickSort(int[] arr, int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}
int partition(int[] arr, int low, int high) {
    int pivot = arr[high];
    int i = low - 1;
    for (int j = low; j < high; j++) {
        if (arr[j] <= pivot) {
            i++;
            int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;
        }
    }
    int temp = arr[i + 1]; arr[i + 1] = arr[high]; arr[high] = temp;
    return i + 1;
}
```

---

## 6. Heap Sort (Сортировка кучей)

Heap Sort строит из массива бинарную кучу (max-heap) и затем последовательно извлекает максимальный элемент, помещая его в конец массива.

Сложность алгоритма — O(n log n) в худшем, среднем и лучшем случаях. Память — O(1), так как сортировка выполняется на месте. Алгоритм не является стабильным.

Heap Sort хорошо подходит для массивов большого размера, когда важна гарантированная временная сложность. В Java реализовать можно через `PriorityQueue`, хотя встроенные методы сортировки обычно используют Quick Sort или Merge Sort для оптимизации.

**Пример в Java:**

```java
void heapSort(int[] arr) {
    int n = arr.length;
    for (int i = n / 2 - 1; i >= 0; i--) heapify(arr, n, i);
    for (int i = n - 1; i >= 0; i--) {
        int temp = arr[0]; arr[0] = arr[i]; arr[i] = temp;
        heapify(arr, i, 0);
    }
}
void heapify(int[] arr, int n, int i) {
    int largest = i, l = 2*i+1, r = 2*i+2;
    if (l < n && arr[l] > arr[largest]) largest = l;
    if (r < n && arr[r] > arr[largest]) largest = r;
    if (largest != i) {
        int swap = arr[i]; arr[i] = arr[largest]; arr[largest] = swap;
        heapify(arr, n, largest);
    }
}
```

---


# Сравнительная таблица (Big-O) — 5 популярных алгоритмов сортировки

| Алгоритм | Лучший случай (время) | Средний (время) | Худший (время) | Память (aux) | Стабильность | Примечание |
|---|---:|---:|---:|---:|---|---|
| QuickSort (обычный) | **O(n log n)** | **O(n log n)** | **O(n²)** | O(log n) (рекурсивный стек, в среднем) | Нет | Очень быстрый на практике; худший случай при плохом выборе опорного элемента |
| MergeSort | **O(n log n)** | **O(n log n)** | **O(n log n)** | **O(n)** (доп. массив) | Да | Гарантированное O(n log n), стабильный, требует дополнительной памяти |
| HeapSort | **O(n log n)** | **O(n log n)** | **O(n log n)** | **O(1)** (in-place) | Нет | Надёжный верхний предел времени, не стабильный, константы хуже QuickSort |
| Insertion Sort | **O(n)** (почти отсортирован) | **O(n²)** | **O(n²)** | **O(1)** | Да | Отлично для маленьких массивов или частично отсортированных данных |
| Bubble Sort (оптимизированный) | **O(n)** (с флагом ранней остановки) | **O(n²)** | **O(n²)** | **O(1)** | Да | Прост в понимании; практически не используется в продуктивном коде |

**Краткие рекомендации**
- QuickSort — общий выбор для скорости на практике; используй рандомизированное или медианное разбиение, чтобы избежать O(n²).
- MergeSort — когда нужна стабильность и гарантированное время, или при внешней сортировке (требуется O(n) доп. памяти).
- HeapSort — когда важна ограниченная дополнительная память O(1) и предсказуемое O(n log n).
- Insertion Sort — отлично как часть гибридных алгоритмов (для малых подмассивов) и для почти отсортированных данных.
- Bubble Sort — только для обучения/демонстраций.


### 1. Стек (Stack)

Стек — это структура данных, которая работает по принципу **LIFO** (Last In, First Out — последний вошёл, первый вышел). Это значит, что элементы добавляются и удаляются только с одного конца, называемого **верхом стека**. Стек часто используется в задачах, где нужно сохранить порядок операций или реализовать откат действий, например, в браузере (история страниц) или при вычислении выражений.

Реализация стека может быть как на массиве, так и на связанном списке. В случае массива операции push (добавление) и pop (удаление) выполняются за O(1), если не нужно расширять массив. На связанном списке добавление и удаление тоже выполняются за O(1), что делает стек очень эффективным для динамических данных.

Стек активно применяется в алгоритмах обхода графов и деревьев (DFS), в реализации рекурсий и в некоторых алгоритмах компиляции. Также используется в парсерах, где нужно проверять корректность скобочных выражений.

Недостатком стека является ограничение на доступ к элементам — получить элемент посередине напрямую нельзя, только последовательное извлечение с верха. Это делает стек узкоспециализированной структурой данных, но крайне полезной там, где порядок операций важнее доступа к любому элементу.

---

### 2. Очередь (Queue)

Очередь — это структура данных, которая работает по принципу **FIFO** (First In, First Out — первый вошёл, первый вышел). Элементы добавляются в конец очереди (tail) и извлекаются с начала (head). Очереди часто применяются в системах управления задачами, потоках данных и моделировании процессов, где важен порядок обработки.

Очереди можно реализовать с помощью массивов, связанных списков или кольцевых буферов. В массивной реализации операции enqueue и dequeue могут быть O(1) при правильной организации кольцевого буфера. Связанный список позволяет динамически изменять размер очереди без пересоздания массива.

Существуют также разновидности очередей: **дек (двусторонняя очередь)** позволяет вставлять и удалять элементы с обоих концов, а **приоритетная очередь** упорядочивает элементы по приоритету, что делает ее важной в алгоритмах сортировки и планировании задач.

Недостаток обычной очереди в том, что доступ к произвольному элементу тоже ограничен — только через последовательное извлечение. Для работы с элементами по приоритету лучше использовать приоритетные очереди, которые обычно реализуются через кучу (heap).

---

### 3. Графы (Graphs)

Граф — это структура данных, состоящая из **вершин (узлов)** и **рёбер**, соединяющих их. Графы могут быть направленными или ненаправленными, взвешенными или невзвешенными. Они позволяют моделировать сложные сети, такие как социальные сети, транспортные маршруты и компьютерные сети.

Графы обычно представляют с помощью **списка смежности** или **матрицы смежности**. Список смежности экономит память для разреженных графов и позволяет эффективно перебирать соседей. Матрица смежности удобна для плотных графов и быстрого доступа к наличию ребра, но требует O(V²) памяти, где V — количество вершин.

Алгоритмы на графах включают поиск в глубину (DFS), поиск в ширину (BFS), алгоритмы поиска кратчайшего пути (Dijkstra, Bellman-Ford) и алгоритмы для минимального остовного дерева (Kruskal, Prim). Графы являются основой для многих сложных алгоритмических задач.

Основной недостаток графов — сложность реализации и потребность в большом объёме памяти для плотных графов. Также операции поиска и модификации могут быть затратными, особенно если граф большой.

---

### 4. Деревья (Trees)

Дерево — это структура данных, состоящая из **узлов**, где один узел является корнем, а все остальные имеют родителя и могут иметь потомков. Деревья эффективно моделируют иерархические структуры, такие как файловые системы или организации.

Бинарное дерево — популярный тип, где каждый узел имеет максимум двух потомков. Бинарные деревья поиска (BST) позволяют быстро искать, добавлять и удалять элементы. В среднем операции поиска, вставки и удаления выполняются за O(log n), но в худшем случае (несбалансированное дерево) могут деградировать до O(n).

Деревья также применяются в алгоритмах обхода (in-order, pre-order, post-order), в реализации выражений, компиляции, базах данных и индексах. Балансировка дерева, например, с помощью AVL или красно-чёрного дерева, гарантирует, что операции останутся эффективными даже в худших случаях.

Недостаток деревьев в том, что без балансировки они могут стать "выражением в линию", что ухудшает эффективность. Поэтому для больших динамических структур данных чаще используют сбалансированные деревья.

---

### 5. Красно-чёрные деревья (Red-Black Trees)

Красно-чёрное дерево — это **самобалансирующееся бинарное дерево поиска**, где каждый узел имеет цвет (красный или черный) и соблюдаются правила для балансировки. Оно гарантирует, что глубина дерева всегда O(log n), что обеспечивает эффективный поиск, вставку и удаление.

Правила включают: корень всегда черный, красные узлы не могут быть соседними, все пути от корня до листьев имеют одинаковое количество черных узлов. Эти ограничения обеспечивают "почти сбалансированное" дерево и предотвращают деградацию в длинную цепочку.

Красно-чёрные деревья применяются в Java в структуре **TreeMap** и **TreeSet**, обеспечивая упорядоченное хранение и быстрый доступ к элементам. Они оптимальны для частых вставок и удалений, где важно поддерживать упорядоченность данных.

Недостаток — высокая сложность реализации и необходимость поддержки правил балансировки при каждой модификации дерева. Но для больших наборов данных с частыми операциями это гораздо эффективнее, чем обычные бинарные деревья поиска.

---

### 6. Куча (Heap)

Куча — это структура данных, обычно **бинарная куча**, которая поддерживает **свойство кучи**: каждый родительский узел больше или меньше своих детей (max-heap или min-heap). Она широко используется для реализации приоритетных очередей и алгоритмов сортировки (HeapSort).

Вставка и извлечение элемента с вершины выполняются за O(log n), что делает кучу очень эффективной для динамических множеств с быстрым доступом к минимуму или максимуму. Куча реализуется обычно в виде массива, где дочерние элементы вычисляются по индексам.

Кучи применяются в планировании задач, потоках с приоритетами, алгоритмах на графах (Dijkstra) и сортировках. Max-heap и min-heap позволяют быстро находить экстремальные значения без полного обхода структуры.

Недостаток — прямой доступ к произвольному элементу медленный (O(n)), так как структура оптимизирована только для доступа к вершине. Для произвольного поиска лучше использовать хэш-таблицы или сбалансированные деревья.

---

### Сравнительная таблица по Big O (Java)

| Структура данных               | Доступ   | Поиск    | Вставка               | Удаление             |
| ------------------------------ | -------- | -------- | --------------------- | -------------------- |
| Массив (Array)                 | O(1)     | O(n)     | O(n)                  | O(n)                 |
| Стек (Stack)                   | O(n)     | O(n)     | O(1)                  | O(1)                 |
| Очередь (Queue)                | O(n)     | O(n)     | O(1)                  | O(1)                 |
| Связанный список (Linked List) | O(n)     | O(n)     | O(1) (в начале/конце) | O(1) (узел известен) |
| Граф (Adjacency List)          | O(V+E)   | O(V+E)   | O(1)                  | O(E)                 |
| Дерево (Binary Search Tree)    | O(log n) | O(log n) | O(log n)              | O(log n)             |
| Красно-чёрное дерево           | O(log n) | O(log n) | O(log n)              | O(log n)             |
| Хэш-таблица (HashMap)          | O(1)     | O(1)     | O(1)                  | O(1)                 |

### Двоичное дерево поиска (Binary Search Tree, BST)

Двоичное дерево поиска (BST) — это вид бинарного дерева, где каждый узел имеет максимум двух потомков: левый и правый. Главное свойство BST заключается в том, что для любого узла все элементы в левом поддереве меньше текущего узла, а все элементы в правом поддереве — больше или равны. Это позволяет быстро искать элементы и поддерживать упорядоченность данных.

Операции поиска, вставки и удаления в среднем выполняются за O(log n), где n — количество элементов в дереве. Однако в худшем случае, если дерево несбалансировано и вырождается в цепочку, сложность может достигать O(n). Поэтому для больших данных часто применяют сбалансированные версии дерева, такие как AVL или красно-чёрные деревья.

BST активно используется для реализации множеств, словарей и индексирования данных в базах данных. Обход дерева может выполняться разными способами: in-order (возвращает элементы в отсортированном порядке), pre-order, post-order. Эти обходы необходимы для поиска, сортировки и копирования дерева.

Недостатком BST является потенциальная потеря эффективности при несбалансированном дереве, что делает необходимой балансировку. Несмотря на это, BST остаётся одной из самых важных структур данных для организации упорядоченной информации.

---

### Основные операции и их сложности (Big O)

| Операция         | Среднее  | Худшее |
| ---------------- | -------- | ------ |
| Поиск            | O(log n) | O(n)   |
| Вставка          | O(log n) | O(n)   |
| Удаление         | O(log n) | O(n)   |
| Минимум/Максимум | O(log n) | O(n)   |

### Основные алгоритмы поиска

Поиск — это базовая операция в информатике, которая позволяет найти элемент в структуре данных. Существует множество алгоритмов поиска, различающихся по эффективности и условиям применения.

### 1. Линейный поиск (Linear Search)

Линейный поиск — самый простой алгоритм, который проверяет каждый элемент массива или списка поочередно, пока не будет найден нужный элемент. Он работает для неотсортированных и отсортированных данных.

* Сложность: O(n) в худшем и среднем случае.
* Преимущество: простота и универсальность.
* Недостаток: низкая эффективность на больших данных.

### 2. Бинарный поиск (Binary Search)

Бинарный поиск работает только на отсортированных данных. Он делит массив пополам, сравнивает середину с искомым элементом и повторяет процесс в нужной половине.

* Сложность: O(log n) в среднем и худшем случае.
* Преимущество: высокая эффективность для больших отсортированных массивов.
* Недостаток: требует предварительной сортировки данных.

### 3. Интерполяционный поиск (Interpolation Search)

Этот алгоритм похож на бинарный поиск, но предполагает, что элементы равномерно распределены. Он вычисляет индекс примерно пропорционально значению искомого элемента.

* Сложность: O(log log n) при равномерном распределении, O(n) в худшем случае.
* Преимущество: быстрее бинарного поиска на равномерно распределённых данных.
* Недостаток: чувствителен к неравномерному распределению.

### 4. Экспоненциальный поиск (Exponential Search)

Используется для поиска в отсортированных массивах. Сначала проверяются индексы, увеличивающиеся экспоненциально, чтобы найти диапазон, затем бинарный поиск применяется внутри этого диапазона.

* Сложность: O(log n)
* Преимущество: эффективен для больших массивов.
* Недостаток: работает только с отсортированными данными.

### 5. Поиск в графах

Существует несколько алгоритмов для поиска в графах:

* **Поиск в ширину (BFS)**: исследует уровни графа от начальной вершины, подходит для нахождения кратчайшего пути в невзвешенных графах. Сложность O(V+E).
  ## Поиск в ширину (BFS)
Поиск в ширину (BFS) — это метод обхода графов и деревьев, который начинается с заданной вершины и последовательно исследует её ближайших соседей перед переходом к следующему уровню. Основные особенности BFS включают:

- Используется очередь для отслеживания необработанных вершин.
- Вершины рассматриваются слой за слоем, обеспечивая равномерное расширение по горизонтали.
- Полезен для нахождения кратчайших путей в невзвешенных графах.
- Сложность алгоритма такая же, как у поиска в глубину: $O(V + E)$, где $V$ — количество вершин, $E$ — количество рёбер.
- Подходит для выявления минимальной дистанции между двумя узлами.
- Применяется в социальных сетях для поиска ближайшего окружения пользователей.
- Может использоваться для построения уровней в играх и оптимизации маршрутов доставки.
- Основное отличие от поиска в глубину заключается в порядке посещения вершин: BFS двигается горизонтально, а DFS вертикально.
* **Поиск в глубину (DFS)**: исследует граф глубже до конца пути, применим для топологической сортировки и проверки связности. Сложность O(V+E).
  ## Подробное описание поиска в глубину
Алгоритм поиска в глубину (DFS) широко используется для решения множества задач обработки графов и деревьев. Вот подробное пошаговое описание процедуры:

1. Начнём с выбора начальной вершины (корня дерева). Эта вершина добавляется в список посещённых вершин и помечается как посещённая.

2. Далее исследуем соседей выбранной вершины. Если какой-то сосед ещё не посещён, мы переходим к нему и повторяем процесс сначала с ним.

3. Когда достигнута вершина, у которой нет непросмотренных соседей, происходит возврат («backtrack») к предыдущей вершине, откуда продолжится исследование оставшихся соседних вершин.

4. Процесс продолжается таким образом, пока не будут пройдены все достижимые вершины, начиная с исходной точки.

5. По завершении посещения всех достижимых вершин, возможно наличие изолированных компонентов в графе. Для этого потребуется выбрать новую начальную точку среди оставшихся неизведанных вершин и повторить весь процесс заново.

6. Алгоритм удобно реализовывать с использованием стека либо рекурсии. Рекурсия позволяет легко отслеживать порядок возвращения к предыдущим вершинам, следуя принципу LIFO (Last In First Out).

7. Чтобы избежать повторного прохождения одной и той же вершины, важно поддерживать массив или структуру данных для хранения информации о состоянии каждой вершины (посещена / не посещена).

8. Поиск в глубину эффективен для поиска путей, особенно если цель находится глубоко внутри графа или дерева. Это связано с тем, что алгоритм стремится проникнуть как можно глубже перед возвратом обратно.

9. Несмотря на свою простоту, DFS обладает рядом полезных свойств: он способен находить кратчайшие пути в некоторых специальных случаях (например, в дереве), а также помогает обнаруживать циклы, компоненты связности и многое другое.

10. Итоговая сложность алгоритма зависит от размера графа и равна O(V + E), где V — количество вершин, а E — количество рёбер. Таким образом, эффективность достаточно высока даже для больших графов.
* **Алгоритмы поиска кратчайшего пути**: Dijkstra, Bellman-Ford, A\*. Используются для взвешенных графов.

### 6. Поиск в деревьях

* **BST Search**: поиск в двоичном дереве поиска. Сложность O(log n) в среднем, O(n) в худшем случае.
* **Обходы деревьев**: in-order, pre-order, post-order. Используются для поиска и обхода всех элементов дерева.
* ## Разновидности обходов деревьев
Три основных вида обходов деревьев (`in-order`, `pre-order` и `post-order`) отличаются порядком посещения узлов относительно их дочерних элементов:
- **In-order** (симметричный обход):
  Посещение слева направо: левое поддерево → корень → правое поддерево. Этот способ часто используют для вывода значений бинарного дерева поиска в отсортированном порядке.

- **Pre-order** (прямой обход):
  Сначала посещается корень, затем левое поддерево и далее правое поддерево. Используется для копирования дерева или вычисления выражения.

- **Post-order** (обратный обход):
  Последовательность: левое поддерево → правое поддерево → корень. Подходят для освобождения памяти, удаления дерева или оценки выражений.

Каждый вид обхода подходит для определенных операций над деревом, позволяя эффективно решать разные задачи.

---

Эти алгоритмы составляют основу поиска в различных структурах данных и лежат в основе многих прикладных задач, включая базы данных, поиск по тексту и маршрутизацию сетей.


