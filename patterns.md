[Вопросы для собеседования](README.md)

# Шаблоны проектирования
+ [Что такое _«шаблон проектирования»_?](#Что-такое-шаблон-проектирования)
+ [Назовите основные характеристики шаблонов.](#Назовите-основные-характеристики-шаблонов)
+ [Типы шаблонов проектирования.](#Типы-шаблонов-проектирования)
+ [Приведите примеры основных шаблонов проектирования.](#Приведите-примеры-основных-шаблонов-проектирования)
+ [Приведите примеры порождающих шаблонов проектирования.](#Приведите-примеры-порождающих-шаблонов-проектирования)
+ [Приведите примеры структурных шаблонов проектирования.](#Приведите-примеры-структурных-шаблонов-проектирования)
+ [Приведите примеры поведенческих шаблонов проектирования.](#Приведите-примеры-поведенческих-шаблонов-проектирования)
+ [Что такое _«антипаттерн»_? Какие антипаттерны вы знаете?](#Что-такое-антипаттерн-Какие-антипаттерны-вы-знаете)
+ [Что такое _Dependency Injection_?](#Что-такое-dependency-injection)

## Что такое _«шаблон проектирования»_?
__Шаблон (паттерн) проектирования (design pattern)__ — это проверенное и готовое к использованию решение. Это не класс и не библиотека, которую можно подключить к проекту, это нечто большее - он не зависит от языка программирования, не является законченным образцом, который может быть прямо преобразован в код и может быть реализован по-разному в разных языках программирования.

Плюсы использования шаблонов:
+ снижение сложности разработки за счёт готовых абстракций для решения целого класса проблем.
+ облегчение коммуникации между разработчиками, позволяя ссылаться на известные шаблоны.
+ унификация деталей решений: модулей и элементов проекта.
+ возможность отыскав удачное решение, пользоваться им снова и снова.
+ помощь в выборе выбрать наиболее подходящего варианта проектирования.

Минусы:
+ слепое следование некоторому выбранному шаблону может привести к усложнению программы.
+ желание попробовать некоторый шаблон в деле без особых на то оснований.

[к оглавлению](#Шаблоны-проектирования)

## Назовите основные характеристики шаблонов.
+ __Имя__ - все шаблоны имеют уникальное имя, служащее для их идентификации;
+ __Назначение__	назначение данного шаблона;
+ __Задача__ - задача, которую шаблон позволяет решить;
+ __Способ решения__ - способ, предлагаемый в шаблоне для решения задачи в том контексте, где этот шаблон был найден;
+ __Участники__	- сущности, принимающие участие в решении задачи;
+ __Следствия__	- последствия от использования шаблона как результат действий, выполняемых в шаблоне;
+ __Реализация__ - возможный вариант реализации шаблона.

[к оглавлению](#Шаблоны-проектирования)

## Типы шаблонов проектирования.
+ Основные (Fundamental) - основные строительные блоки других шаблонов. Большинство других шаблонов использует эти шаблоны в той или иной форме.
+ Порождающие шаблоны (Creational) — шаблоны проектирования, которые абстрагируют процесс создание экземпляра. Они позволяют сделать систему независимой от способа создания, композиции и представления объектов. Шаблон, порождающий классы, использует наследование, чтобы изменять созданный объект, а шаблон, порождающий объекты, делегирует создание объектов другому объекту.
+ Структурные шаблоны (Structural) определяют различные сложные структуры, которые изменяют интерфейс уже существующих объектов или его реализацию, позволяя облегчить разработку и оптимизировать программу.
+ Поведенческие шаблоны (Behavioral) определяют взаимодействие между объектами, увеличивая таким образом его гибкость.

[к оглавлению](#Шаблоны-проектирования)

## Приведите примеры основных шаблонов проектирования.
+ __Делегирование (Delegation pattern)__ - Сущность внешне выражает некоторое поведение, но в реальности передаёт ответственность за выполнение этого поведения связанному объекту.
+ __Функциональный дизайн (Functional design)__ - Гарантирует, что каждая сущность имеет только одну обязанность и исполняет её с минимумом побочных эффектов на другие.
+ __Неизменяемый интерфейс (Immutable interface)__ - Создание неизменяемого объекта.
+ __Интерфейс (Interface)__ - Общий метод структурирования сущностей, облегчающий их понимание. 
+ __Интерфейс-маркер (Marker interface)__ - В качестве атрибута (как пометки объектной сущности) применяется наличие или отсутствие реализации интерфейса-маркера. В современных языках программирования вместо этого применяются атрибуты или аннотации.
+ __Контейнер свойств (Property container)__ - Позволяет добавлять дополнительные свойства сущности в контейнер внутри себя, вместо расширения новыми свойствами.
+ __Канал событий (Event channel)__ - Создаёт централизованный канал для событий. Использует сущность-представитель для подписки и сущность-представитель для публикации события в канале. Представитель существует отдельно от реального издателя или подписчика. Подписчик может получать опубликованные события от более чем одной сущности, даже если он зарегистрирован только на одном канале.

[к оглавлению](#Шаблоны-проектирования)

## Приведите примеры порождающих шаблонов проектирования.
+ __Абстрактная фабрика (Abstract factory)__ - Класс, который представляет собой интерфейс для создания других классов.
+ __Строитель (Builder)__ - Класс, который представляет собой интерфейс для создания сложного объекта.
+ __Фабричный метод (Factory method)__ - Делегирует создание объектов наследникам родительского класса. Это позволяет использовать в коде программы не специфические классы, а манипулировать абстрактными объектами на более высоком уровне.
+ __Прототип (Prototype)__ - Определяет интерфейс создания объекта через клонирование другого объекта вместо создания через конструктор.
+ __Одиночка (Singleton)__ - Класс, который может иметь только один экземпляр.

[к оглавлению](#Шаблоны-проектирования)

## Приведите примеры структурных шаблонов проектирования.
+ __Адаптер (Adapter)__ - Объект, обеспечивающий взаимодействие двух других объектов, один из которых использует, а другой предоставляет несовместимый с первым интерфейс. 
+ __Мост (Bridge)__ - Структура, позволяющая изменять интерфейс обращения и интерфейс реализации класса независимо. 
+ __Компоновщик (Composite)__ - Объект, который объединяет в себе объекты, подобные ему самому. 
+ __Декоратор (Decorator)__ - Класс, расширяющий функциональность другого класса без использования наследования. 
+ __Фасад (Facade)__ - Объект, который абстрагирует работу с несколькими классами, объединяя их в единое целое. 
+ __Приспособленец (Flyweight)__ - Это объект, представляющий себя как уникальный экземпляр в разных местах программы, но по факту не являющийся таковым. 
+ __Заместитель (Proxy)__ - Объект, который является посредником между двумя другими объектами, и который реализует/ограничивает доступ к объекту, к которому обращаются через него.

[к оглавлению](#Шаблоны-проектирования)

## Приведите примеры поведенческих шаблонов проектирования.
+ __Цепочка обязанностей (Chain of responsibility)__ - Предназначен для организации в системе уровней ответственности.
+ __Команда (Command)__ - Представляет действие. Объект команды заключает в себе само действие и его параметры.
+ __Интерпретатор (Interpreter)__ - Решает часто встречающуюся, но подверженную изменениям, задачу.
+ __Итератор (Iterator)__ - Представляет собой объект, позволяющий получить последовательный доступ к элементам объекта-агрегата без использования описаний каждого + __из объектов, входящих в состав агрегации.
+ __Посредник (Mediator)__ - Обеспечивает взаимодействие множества объектов, формируя при этом слабую связанность и избавляя объекты от необходимости явно ссылаться друг на друга.
+ __Хранитель (Memento)__ - Позволяет, не нарушая инкапсуляцию зафиксировать и сохранить внутренние состояния объекта так, чтобы позднее восстановить его в этих состояниях.
+ __Наблюдатель (Observer)__ - Определяет зависимость типа «один ко многим» между объектами таким образом, что при изменении состояния одного объекта все зависящие от него оповещаются об этом событии.
+ __Состояние (State)__ - Используется в тех случаях, когда во время выполнения программы объект должен менять своё поведение в зависимости от своего состояния.
+ __Стратегия (Strategy)__ - Предназначен для определения семейства алгоритмов, инкапсуляции каждого из них и обеспечения их взаимозаменяемости.
+ __Шаблонный метод (Template method)__ - Определяет основу алгоритма и позволяет наследникам переопределять некоторые шаги алгоритма, не изменяя его структуру в целом.
+ __Посетитель (Visitor)__ - Описывает операцию, которая выполняется над объектами других классов. При изменении класса Visitor нет необходимости изменять обслуживаемые классы.

[к оглавлению](#Шаблоны-проектирования)

## Что такое _«антипаттерн»_? Какие антипаттерны вы знаете?
__Антипаттерн (anti-pattern)__ — это распространённый подход к решению класса часто встречающихся проблем, являющийся неэффективным, рискованным или непродуктивным.

__Poltergeists (полтергейсты)__ - это классы с ограниченной ответственностью и ролью в системе, чьё единственное предназначение — передавать информацию в другие классы. Их эффективный жизненный цикл непродолжителен. Полтергейсты нарушают стройность архитектуры программного обеспечения, создавая избыточные (лишние) абстракции, они чрезмерно запутанны, сложны для понимания и трудны в сопровождении. Обычно такие классы задумываются как классы-контроллеры, которые существуют только для вызова методов других классов, зачастую в предопределенной последовательности.

Признаки появления и последствия антипаттерна
+ Избыточные межклассовые связи.
+ Временные ассоциации.
+ Классы без состояния (содержащие только методы и константы).
+ Временные объекты и классы (с непродолжительным временем жизни).
+ Классы с единственным методом, который предназначен только для создания или вызова других классов посредством временной ассоциации.
+ Классы с именами методов в стиле «управления», такие как startProcess.

Типичные причины
+ Отсутствие объектно-ориентированной архитектуры (архитектор не понимает объектно-ориентированной парадигмы).
+ Неправильный выбор пути решения задачи.
+ Предположения об архитектуре приложения на этапе анализа требований (до объектно-ориентированного анализа) могут также вести к проблемам на подобии этого антипаттерна.

__Внесенная сложность (Introduced complexity)__: Необязательная сложность дизайна. Вместо одного простого класса выстраивается целая иерархия интерфейсов и классов. Типичный пример «Интерфейс - Абстрактный класс - Единственный класс реализующий интерфейс на основе абстрактного».

__Инверсия абстракции (Abstraction inversion)__: Сокрытие части функциональности от внешнего использования, в надежде на то, что никто не будет его использовать.

__Неопределённая точка зрения (Ambiguous viewpoint)__: Представление модели без спецификации её точки рассмотрения.

__Большой комок грязи (Big ball of mud)__: Система с нераспознаваемой структурой.

__Божественный объект (God object)__: Концентрация слишком большого количества функций в одной части системы (классе).

__Затычка на ввод данных (Input kludge)__: Забывчивость в спецификации и выполнении поддержки возможного неверного ввода.

__Раздувание интерфейса (Interface bloat)__: Разработка интерфейса очень мощным и очень сложным для реализации.

__Волшебная кнопка (Magic pushbutton)__: Выполнение результатов действий пользователя в виде неподходящего (недостаточно абстрактного) интерфейса. Например, написание прикладной логики в обработчиках нажатий на кнопку.

__Перестыковка (Re-Coupling)__: Процесс внедрения ненужной зависимости.

__Дымоход (Stovepipe System)__: Редко поддерживаемая сборка плохо связанных компонентов.

__Состояние гонки (Race hazard)__: непредвидение возможности наступления событий в порядке, отличном от ожидаемого.

__Членовредительство (Mutilation)__: Излишнее «затачивание» объекта под определенную очень узкую задачу таким образом, что он не способен будет работать с никакими иными, пусть и очень схожими задачами.

__Сохранение или смерть (Save or die)__: Сохранение изменений лишь при завершении приложения.

[к оглавлению](#Шаблоны-проектирования)

## Что такое _Dependency Injection_?
__Dependency Injection (внедрение зависимости)__ - это набор паттернов и принципов разработки програмного обеспечения, которые позволяют писать слабосвязный код. В полном соответствии с принципом единой обязанности объект отдаёт заботу о построении требуемых ему зависимостей внешнему, специально предназначенному для этого общему механизму.

[к оглавлению](#Шаблоны-проектирования)
# Введение — что такое **порождающие (creational)** паттерны
Порождающие паттерны проектирования решают, **как правильно создавать объекты**. Они помогают отделить логику создания от использования, делают код гибче, проще для тестирования и расширения. На собеседовании от вас ожидают не только определения, но и понимание **когда** и **почему** применять каждый паттерн, плюсы/минусы и практические примеры.

Ниже — подробные объяснения (простым языком), реальные сценарии и готовые Java-примеры с подробными комментариями на русском. После каждого блока — полностью рабочий пример в одном файле (один public класс + вспомогательные), чтобы вы могли скопировать и вставить в IDE.

---

# 1. Фабрика (Simple Factory) и Фабричный метод (Factory Method)
### Идея (простыми словами)
- **Simple Factory** — это просто класс/метод, который создаёт объекты разных типов по входным параметрам. Неофициальный паттерн (не в GOF), но часто используется.
- **Factory Method** — переопределяемый метод (обычно в абстрактном классе или интерфейсе), который делегирует создание конкретных объектов подклассам. Это официальный GOF-паттерн.

### Когда и зачем использовать
- Нужна централизованная логика создания объектов (когда создание — не тривиально).
- Когда нужно скрыть конкретные классы от клиента (инверсия зависимостей).
- Когда требуется расширяемость: добавление нового продукта не должно ломать код клиента.
- Simple Factory — подходит для небольших случаев; Factory Method — при потребности в расширяемости через наследование.

### Плюсы / минусы
+ Снижает связанность кода (client не знает конкретных классов).  
+ Упрощает замену/добавление новых типов.  
− Может привести к большому числу классов (особенно Factory Method).  
− Simple Factory может стать «God class», если он слишком большой.

### Пример: Factory Method — транспорт (road/ship/air)
```java
// FactoryMethodDemo.java
// Простой демонстрационный пример паттерна Factory Method.
// Все классы находятся в одном файле для удобства копирования в IDE.
// Public-класс соответствует имени файла.

// Добавлены аннотации Lombok для демонстрации их использования (хотя в простых классах Lombok не обязателен).
import lombok.NoArgsConstructor;
import lombok.ToString;

public class FactoryMethodDemo {
    public static void main(String[] args) {
        // Клиент работает с создателем, не зная конкретного транспорта.
        Creator roadCreator = new RoadLogistics();
        Transport t1 = roadCreator.createTransport();
        t1.deliver();

        Creator seaCreator = new SeaLogistics();
        Transport t2 = seaCreator.createTransport();
        t2.deliver();

        // Добавление нового транспорта = добавление нового класса Creator + Product,
        // клиентский код не изменяется.
    }
}

// --- Product интерфейс ---
interface Transport {
    void deliver(); // метод для доставки
}

// --- Concrete Products ---
@NoArgsConstructor
@ToString
class Truck implements Transport {
    @Override
    public void deliver() {
        // Конкретная реализация доставки для грузовика
        System.out.println("Доставка грузовиком по дороге");
    }
}

@NoArgsConstructor
@ToString
class Ship implements Transport {
    @Override
    public void deliver() {
        System.out.println("Доставка кораблем по морю");
    }
}

// --- Creator (абстрактный) ---
abstract class Creator {
    // Фабричный метод — возвращает интерфейс Transport.
    // Подклассы решают, какой конкретно транспорт создать.
    public abstract Transport createTransport();

    // Допустим у Creator есть общая логика:
    public void planDelivery() {
        Transport transport = createTransport();
        // общая логика использования продукта
        System.out.println("Планирование доставки...");
        transport.deliver();
    }
}

// --- Concrete Creators ---
@NoArgsConstructor
class RoadLogistics extends Creator {
    @Override
    public Transport createTransport() {
        // можно добавить логику выбора конфигурации Truck
        return new Truck();
    }
}

@NoArgsConstructor
class SeaLogistics extends Creator {
    @Override
    public Transport createTransport() {
        return new Ship();
    }
}
```

---

# 2. Абстрактная фабрика (Abstract Factory)
### Идея (простыми словами)
Абстрактная фабрика предоставляет интерфейс для создания **семейств связанных объектов** (например, виджеты для разных платформ), не указывая их конкретных классов. Это удобно, когда объекты должны работать вместе (совместимы по интерфейсу/стилю).

### Когда и зачем использовать
- Когда нужно создать семейства взаимосвязанных объектов (например, темы UI — кнопка + чекбокс + поле ввода).
- Когда важно, чтобы продукты одного семейства были совместимы.
- Когда нужно менять семейство продуктов во время выполнения (поддержка тем/платформ).

### Плюсы / минусы
+ Хорошо обеспечивает единообразие продуктов (семейства совместимы).  
+ Упрощает замену семейства продуктов целиком.  
− Усложняет добавление новых типов продуктов (добавая новый продукт — нужно изменить интерфейсы/все фабрики).

### Пример: семейства виджетов (Windows / Mac)
```java
// AbstractFactoryDemo.java
// Демонстрация Abstract Factory на примере UI-виджетов (Button + Checkbox).
// Все классы в одном файле для удобного копирования.

// Добавлены аннотации Lombok (@ToString) для демонстрации, где это уместно.
import lombok.ToString;

public class AbstractFactoryDemo {
    public static void main(String[] args) {
        UIFactory factory = new WindowsFactory();
        Button winButton = factory.createButton();
        Checkbox winCheckbox = factory.createCheckbox();
        winButton.paint();
        winCheckbox.paint();

        // Теперь сменим семью на Mac
        UIFactory macFactory = new MacFactory();
        macFactory.createButton().paint();
        macFactory.createCheckbox().paint();
    }
}

// --- Abstract Products ---
interface Button {
    void paint();
}

interface Checkbox {
    void paint();
}

// --- Concrete Products for Windows ---
@ToString
class WindowsButton implements Button {
    @Override
    public void paint() {
        System.out.println("Рисуем кнопку в стиле Windows");
    }
}

@ToString
class WindowsCheckbox implements Checkbox {
    @Override
    public void paint() {
        System.out.println("Рисуем чекбокс в стиле Windows");
    }
}

// --- Concrete Products for Mac ---
@ToString
class MacButton implements Button {
    @Override
    public void paint() {
        System.out.println("Рисуем кнопку в стиле Mac");
    }
}

@ToString
class MacCheckbox implements Checkbox {
    @Override
    public void paint() {
        System.out.println("Рисуем чекбокс в стиле Mac");
    }
}

// --- Abstract Factory ---
interface UIFactory {
    Button createButton();
    Checkbox createCheckbox();
}

// --- Concrete Factories ---
class WindowsFactory implements UIFactory {
    @Override
    public Button createButton() { return new WindowsButton(); }
    @Override
    public Checkbox createCheckbox() { return new WindowsCheckbox(); }
}

class MacFactory implements UIFactory {
    @Override
    public Button createButton() { return new MacButton(); }
    @Override
    public Checkbox createCheckbox() { return new MacCheckbox(); }
}
```

---

# 3. Builder (Строитель)
### Идея (простыми словами)
Builder отделяет процесс построения сложного объекта от его представления. Особенно полезен, когда конструктор класса принимает много параметров (особенно опциональных), и хочется избежать "конструкторского ада" (много конструкторов с разными комбинациями параметров).

### Когда и зачем использовать
- Объект имеет много полей (часто опциональных).
- Нужна читабельная и безопасная конструкция (иммутабельность).
- Требуется пошаговая конфигурация и валидация перед созданием.
- Полезен в DSL-подходе (цепочки вызовов).

### Плюсы / минусы
+ Улучшает читаемость кода при создании сложных объектов.  
+ Позволяет делать объект immutable.  
− Небольшой дополнительный код (класс Builder), но обычно оправдан.

### Пример: построение объекта `User` с множеством опциональных полей
```java
// BuilderDemo.java
// Пример паттерна Builder на классе User.
// Внутри статический вложенный Builder: класс User становится иммутабельным.

// Здесь заменяем ручной Builder на Lombok @Builder для сокращения кода.
// Lombok сгенерирует класс Builder автоматически, а также геттеры и toString.
import lombok.Builder;
import lombok.Getter;
import lombok.ToString;

public class BuilderDemo {
    public static void main(String[] args) {
        // Пример использования билдера.
        User user = User.builder()
                .email("ivan@example.com") // обязательное поле
                .firstName("Иван")
                .lastName("Иванов")
                .age(35)
                .phone("+7-900-123-45-67")
                .build();

        System.out.println(user);
    }
}

@Getter
@ToString
@Builder
final class User {
    // обязательное
    private final String email;
    // опциональные
    private final String firstName;
    private final String lastName;
    private final Integer age;
    private final String phone;
}
```

---

# 4. Singleton (Одиночка)
### Идея (простыми словами)
Паттерн обеспечивает наличие **только одного экземпляра** класса и глобальную точку доступа к нему.

### Когда и зачем использовать
- Нужно глобальное, совместно используемое состояние (например, конфигурация приложения, пул соединений, логгер).  
- Важно, чтобы экземпляр был один в рамках JVM.

### Важно на интервью
- Обсуждают проблемы многопоточности и сериализации.
- Покажите разные реализации (eager, lazy с double-check, Enum) и объясните плюсы/минусы.

### Плюсы / минусы
+ Удобен для глобального состояния.  
− Может стать глобальной переменной (anti-pattern) — усложняет тестирование (мокирование).  
− Ошибки при сериализации, клонировании и многопоточности — нужно быть аккуратным.

### Примеры: Eager, Lazy (Double-checked), Enum
```java
// SingletonDemo.java
// Три варианта реализации Singleton — в одном файле для демонстрации.
// В реальном проекте выберите один подход (часто рекомендуют enum-одиночку).

// Lombok можно использовать для генерации геттеров/логирования, например @Getter или @Slf4j.
// Здесь добавим @Getter в качестве примера.
import lombok.Getter;

public class SingletonDemo {
    public static void main(String[] args) {
        System.out.println("Eager: " + EagerSingleton.getInstance());
        System.out.println("LazyDCL: " + LazyDCLSingleton.getInstance());
        System.out.println("Enum: " + EnumSingleton.INSTANCE);

        // Проверка, что ссылки одинаковы
        System.out.println("Eager same? " + (EagerSingleton.getInstance() == EagerSingleton.getInstance()));
        System.out.println("LazyDCL same? " + (LazyDCLSingleton.getInstance() == LazyDCLSingleton.getInstance()));
        System.out.println("Enum same? " + (EnumSingleton.INSTANCE == EnumSingleton.INSTANCE));
    }
}

// --- Eager initialization (простая и потокобезопасная при загрузке класса) ---
@Getter
class EagerSingleton {
    // Экземпляр создаётся при загрузке класса
    private static final EagerSingleton INSTANCE = new EagerSingleton();

    // Приватный конструктор — нельзя создать извне
    private EagerSingleton() {}

    public static EagerSingleton getInstance() {
        return INSTANCE;
    }
}

// --- Lazy initialization с double-checked locking (DCL) ---
@Getter
class LazyDCLSingleton {
    // volatile важен для корректности double-checked locking
    private static volatile LazyDCLSingleton instance;

    private LazyDCLSingleton() {}

    public static LazyDCLSingleton getInstance() {
        // Сначала без синхронизации (быстрая проверка)
        if (instance == null) {
            synchronized (LazyDCLSingleton.class) {
                // Проверяем ещё раз внутри synchronized
                if (instance == null) {
                    instance = new LazyDCLSingleton();
                }
            }
        }
        return instance;
    }
}

// --- Enum singleton (лучший вариант в большинстве случаев) ---
enum EnumSingleton {
    INSTANCE; // единственный экземпляр

    // Можно хранить состояние и методы
    public void doSomething() {
        System.out.println("EnumSingleton doing something");
    }
}
```

**Рекомендация:** в большинстве случаев `enum`-singleton — самый безопасный и простой способ, потому что он автоматически защищён от проблем с сериализацией и отражением (reflection).

---

# 5. Prototype (Прототип)
### Идея (простыми словами)
Prototype — создаём новые объекты путём клонирования (копирования) существующего экземпляра-прототипа. Удобно, когда создание объекта «дорогое» (сложная инициализация), либо когда нужно быстро получить копию с небольшими изменениями.

### Когда и зачем использовать
- Стоимость создания нового объекта высокая (ресурсоёмкая инициализация).
- Нужно много схожих объектов, которые отличаются небольшими деталями.
- Желание получать копии без знания точного конкретного класса (через интерфейс clone).

### Важные нюансы в Java
- `Cloneable` и метод `clone()` — исторически спорны (поведение дефолтного `Object.clone()` делает поверхностное копирование).
- Для глубокого копирования часто нужно вручную клонировать вложенные объекты или использовать сериализацию/копирующие конструкторы.
- На интервью можно показать и `clone()` и альтернативный способ — копирующий конструктор/фабрика копий.

### Пример: shallow & deep clone
```java
// PrototypeDemo.java
// Демонстрация shallow и deep clone на объекте Document, содержащем Metadata.
// Используем Cloneable для примера, и также покажем копирующий конструктор для deep copy.

// Lombok используется для сокращения шаблонного кода (геттеры/сеттеры/toString)
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

public class PrototypeDemo {
    public static void main(String[] args) throws CloneNotSupportedException {
        Metadata meta = new Metadata("Иван", "2025-09-06");
        Document original = new Document("Отчёт", "Тело отчёта", meta);

        // shallow clone (через clone) — metadata будет общим (shared reference)
        Document shallow = original.clone();
        System.out.println("original metadata author: " + original.getMetadata().getAuthor());
        System.out.println("shallow metadata author:  " + shallow.getMetadata().getAuthor());

        // Изменим метаданные в shallow
        shallow.getMetadata().setAuthor("Пётр");
        System.out.println("После изменения shallow:");
        System.out.println("original metadata author: " + original.getMetadata().getAuthor()); // изменилось — демонстрация shallow

        // Deep clone через копирующий конструктор
        Document deep = new Document(original); // copy constructor
        deep.getMetadata().setAuthor("Мария");
        System.out.println("После изменения deep:");
        System.out.println("original metadata author: " + original.getMetadata().getAuthor()); // не изменилось
    }
}

@Data
@NoArgsConstructor
@AllArgsConstructor
class Metadata implements Cloneable {
    private String author;
    private String date;

    @Override
    protected Metadata clone() throws CloneNotSupportedException {
        // Для метаданных shallow clone достаточно (если все поля примитивы/immutable).
        return (Metadata) super.clone();
    }
}

@Data
class Document implements Cloneable {
    private String title;
    private String body;
    private Metadata metadata;

    public Document(String title, String body, Metadata metadata) {
        this.title = title;
        this.body = body;
        this.metadata = metadata;
    }

    // Копирующий конструктор для deep copy
    public Document(Document other) {
        this.title = other.title;
        this.body = other.body;
        // Для глубокого копирования создаём новый объект Metadata (который клонируем)
        try {
            this.metadata = other.metadata.clone();
        } catch (CloneNotSupportedException e) {
            // fallback — создать вручную
            this.metadata = new Metadata(other.metadata.getAuthor(), other.metadata.getDate());
        }
    }

    @Override
    protected Document clone() throws CloneNotSupportedException {
        // По умолчанию суперкласс делает поверхностное копирование
        return (Document) super.clone();
    }

    // геттер для metadata
    public Metadata getMetadata() { return metadata; }
}
```

**Практический совет:** на интервью можно сказать, что `Cloneable` в Java спорен, и предпочитаете контролируемое копирование (копирующие конструкторы / фабрики), особенно для глубокого копирования.

---

# Заключение — как выбирать паттерн
- Нужен один глобальный экземпляр → **Singleton** (с осторожностью; лучше enum).
- Нужна простая централизация создания → **Simple Factory**.
- Требуется расширяемость создания через подклассы → **Factory Method**.
- Нужна гибкая смена семейства совместимых продуктов → **Abstract Factory**.
- Объект создаётся с большим количеством опций / хотите immutable → **Builder**.
- Нужно клонирование/быстро создавать похожие объекты / избежать дорогой инициализации → **Prototype** (предпочтительно через контролируемые копии).

---

# Структурные паттерны проектирования (с подробным объяснением и примерами на Java + Lombok)

Структурные паттерны помогают **организовать классы и объекты в более крупные структуры**, сохраняя при этом гибкость.  
Они фокусируются на том, **как связать классы и объекты между собой**.

---

# 1. Adapter (Адаптер)
### Идея (простыми словами)
Адаптер позволяет двум несовместимым интерфейсам работать вместе. Он оборачивает один объект и предоставляет интерфейс, ожидаемый клиентом. Это особенно полезно, когда нужно использовать существующие классы без изменения их кода. Паттерн помогает интегрировать старый код с новым. Он скрывает детали преобразования интерфейсов от клиента.

### Когда использовать
- Есть готовый класс, но его интерфейс не подходит клиентскому коду.
- Не хочется или нельзя менять существующий класс.
- Нужно использовать стороннюю библиотеку с неудобным интерфейсом.

### Плюсы / минусы
+ Позволяет переиспользовать существующие классы без изменения их кода.  
+ Изолирует изменения интерфейсов.  
− Может привести к избыточному числу классов (каждый адаптер отдельно).  
− Иногда ухудшает читаемость из-за "лишнего уровня".

### Пример: `SquarePeg` и `RoundHole`
```java
// AdapterDemo.java
// Пример: у нас есть КруглоеОтверстие (RoundHole) и КруглыйКолышек (RoundPeg).
// Но появляется КвадратныйКолышек (SquarePeg), который не подходит.
// Используем адаптер, чтобы заставить квадратный колышек работать с круглым отверстием.

import lombok.AllArgsConstructor;
import lombok.Getter;

public class AdapterDemo {
    public static void main(String[] args) {
        RoundHole hole = new RoundHole(5);
        RoundPeg roundPeg = new RoundPeg(5);
        System.out.println("Круглый колышек помещается? " + hole.fits(roundPeg));

        SquarePeg smallSqPeg = new SquarePeg(5);
        SquarePeg largeSqPeg = new SquarePeg(10);

        // Адаптируем квадратные колышки
        RoundPeg smallAdapter = new SquarePegAdapter(smallSqPeg);
        RoundPeg largeAdapter = new SquarePegAdapter(largeSqPeg);

        System.out.println("Маленький квадратный колышек помещается? " + hole.fits(smallAdapter));
        System.out.println("Большой квадратный колышек помещается? " + hole.fits(largeAdapter));
    }
}

@Getter
@AllArgsConstructor
class RoundHole {
    private double radius;

    public boolean fits(RoundPeg peg) {
        return this.radius >= peg.getRadius();
    }
}

@Getter
@AllArgsConstructor
class RoundPeg {
    private double radius;
}

@Getter
@AllArgsConstructor
class SquarePeg {
    private double width;
}

// Адаптер: заставляет SquarePeg работать как RoundPeg
@AllArgsConstructor
class SquarePegAdapter extends RoundPeg {
    private SquarePeg peg;

    public double getRadius() {
        // Диагональ квадрата / 2 = радиус вписанной окружности
        return (peg.getWidth() * Math.sqrt(2)) / 2;
    }
}
```

---

# 2. Composite (Компоновщик)
### Идея
Компоновщик позволяет строить древовидные структуры объектов, где отдельные объекты и их комбинации обрабатываются одинаково. Это упрощает работу с иерархическими структурами, например, графическим деревом элементов или файловой системой. Паттерн обеспечивает единообразие интерфейса для работы с отдельными и составными объектами. Он облегчает добавление новых элементов без изменения существующего кода. Также упрощает рекурсивные операции над всей структурой.

### Когда использовать
- Когда объекты образуют иерархию "часть-целое".
- Когда нужно, чтобы клиент одинаково работал как с одиночными объектами, так и с их комбинациями.

### Плюсы / минусы
+ Унифицированный способ работы с отдельными объектами и группами.  
+ Легко строить сложные иерархии.  
− Может быть сложно ограничить доступные операции для "листьев" и "композитов".  
− Может быть трудно контролировать структуру (например, запретить пустые папки).

### Пример: файловая система (Файл и Папка)
```java
// CompositeDemo.java
// Демонстрация: Папка содержит как файлы, так и другие папки.
// Оба реализуют общий интерфейс FileSystemComponent.

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.ToString;

import java.util.ArrayList;
import java.util.List;

public class CompositeDemo {
    public static void main(String[] args) {
        File file1 = new File("file1.txt");
        File file2 = new File("file2.txt");
        Directory dir = new Directory("docs");
        dir.add(file1);
        dir.add(file2);

        Directory root = new Directory("root");
        root.add(dir);
        root.add(new File("readme.md"));

        root.show();
    }
}

interface FileSystemComponent {
    void show();
}

@Getter
@AllArgsConstructor
@ToString
class File implements FileSystemComponent {
    private String name;

    @Override
    public void show() {
        System.out.println("Файл: " + name);
    }
}

@Getter
@AllArgsConstructor
class Directory implements FileSystemComponent {
    private String name;
    private List<FileSystemComponent> children = new ArrayList<>();

    public Directory(String name) {
        this.name = name;
    }

    public void add(FileSystemComponent component) {
        children.add(component);
    }

    @Override
    public void show() {
        System.out.println("Папка: " + name);
        for (FileSystemComponent child : children) {
            child.show();
        }
    }
}
```

---

# 3. Proxy (Заместитель)
### Идея
Заместитель предоставляет объект с тем же интерфейсом, что и реальный объект, и управляет доступом к нему. Он может использоваться для ленивой инициализации, контроля доступа или логирования вызовов. Паттерн позволяет скрыть сложность реального объекта от клиента. Также можно внедрить кэширование или другие вспомогательные функции без изменения реального объекта. Заместитель выступает посредником между клиентом и реальным объектом.

### Когда использовать
- Ленивое создание "тяжёлого" объекта (виртуальный прокси).
- Добавление доступа/логирования без изменения реального объекта.
- Удалённые прокси (работа через сеть).

### Плюсы / минусы
+ Позволяет контролировать доступ и добавлять функциональность.  
+ Поддержка ленивой загрузки.  
− Усложняет код (ещё один уровень абстракции).  
− Может быть лишним, если дополнительных функций нет.

### Пример: ленивое создание "тяжёлого" объекта
```java
// ProxyDemo.java
// Пример: загружаем "тяжёлое" изображение только тогда, когда оно реально нужно.

public class ProxyDemo {
    public static void main(String[] args) {
        Image image = new ProxyImage("photo.jpg");

        // Файл ещё не загружен
        image.display();

        // Повторный вызов: файл уже загружен
        image.display();
    }
}

interface Image {
    void display();
}

// Реальный объект
class RealImage implements Image {
    private String filename;

    public RealImage(String filename) {
        this.filename = filename;
        loadFromDisk();
    }

    private void loadFromDisk() {
        System.out.println("Загрузка изображения: " + filename);
    }

    @Override
    public void display() {
        System.out.println("Отображение: " + filename);
    }
}

// Прокси: откладывает создание RealImage
class ProxyImage implements Image {
    private String filename;
    private RealImage realImage;

    public ProxyImage(String filename) {
        this.filename = filename;
    }

    @Override
    public void display() {
        if (realImage == null) {
            realImage = new RealImage(filename);
        }
        realImage.display();
    }
}
```

---

# 4. Flyweight (Легковес)
### Идея
Легковес позволяет использовать разделяемые объекты для уменьшения потребления памяти. Вместо создания множества похожих объектов, общий объект используется повторно с различными состояниями. Это особенно важно для систем с большим количеством однотипных объектов, например, символов текста или графических элементов. Паттерн разделяет внутреннее состояние (общие данные) и внешнее (конкретное для каждого использования). Он повышает эффективность памяти и производительность.

### Когда использовать
- Нужно создать огромное количество похожих объектов (например, символы текста, частицы в игре).
- Внутреннее состояние объектов одинаковое, а уникальное можно вынести наружу.

### Плюсы / минусы
+ Сильно экономит память.  
+ Ускоряет создание новых объектов (берём из кэша).  
− Усложняет код (нужно разделять состояние).  
− Сложно поддерживать, если много разных вариантов состояний.

### Пример: символы в тексте
```java
// FlyweightDemo.java
// Демонстрация: у нас есть много "символов".
// Общая часть (глиф) хранится в Flyweight, а позиция — внешний контекст.

import java.util.HashMap;
import java.util.Map;

public class FlyweightDemo {
    public static void main(String[] args) {
        GlyphFactory factory = new GlyphFactory();

        Glyph g1 = factory.getGlyph('a');
        Glyph g2 = factory.getGlyph('a');
        Glyph g3 = factory.getGlyph('b');

        g1.draw(1, 1);
        g2.draw(2, 2);
        g3.draw(3, 3);
    }
}

interface Glyph {
    void draw(int x, int y);
}

// Конкретный легковес
class CharacterGlyph implements Glyph {
    private final char symbol;

    public CharacterGlyph(char symbol) {
        this.symbol = symbol;
    }

    @Override
    public void draw(int x, int y) {
        System.out.println("Рисуем '" + symbol + "' в позиции (" + x + "," + y + ")");
    }
}

// Фабрика легковесов
class GlyphFactory {
    private final Map<Character, Glyph> cache = new HashMap<>();

    public Glyph getGlyph(char c) {
        return cache.computeIfAbsent(c, CharacterGlyph::new);
    }
}
```

---

# 5. Facade (Фасад)
Фасад предоставляет упрощённый интерфейс для работы со сложной системой. Клиент взаимодействует с фасадом, не зная всех деталей и внутренних компонентов системы. Паттерн упрощает использование системы и скрывает сложность её реализации. Он снижает связность между клиентом и компонентами системы. Фасад также облегчает поддержку и модификацию системы.

### Когда использовать
- Сложная система, много классов и зависимостей.
- Хотите упростить работу клиента и скрыть детали.

### Плюсы / минусы
+ Упрощает интерфейс системы.  
+ Скрывает детали реализации.  
− Может превратиться в "God object", если в него тянуть слишком много функций.  
− Иногда скрывает слишком много и ограничивает гибкость.

### Пример: Домашний кинотеатр
```java
// FacadeDemo.java
// Демонстрация: клиент включает кинотеатр одной командой, а не кучей.

public class FacadeDemo {
    public static void main(String[] args) {
        HomeTheaterFacade theater = new HomeTheaterFacade(
                new Amplifier(),
                new Projector(),
                new Screen()
        );

        theater.watchMovie("Inception");
        theater.endMovie();
    }
}

// Подсистемы
class Amplifier {
    public void on() { System.out.println("Усилитель включен"); }
    public void off() { System.out.println("Усилитель выключен"); }
}

class Projector {
    public void on() { System.out.println("Проектор включен"); }
    public void off() { System.out.println("Проектор выключен"); }
}

class Screen {
    public void down() { System.out.println("Экран опущен"); }
    public void up() { System.out.println("Экран поднят"); }
}

// Фасад
class HomeTheaterFacade {
    private Amplifier amp;
    private Projector projector;
    private Screen screen;

    public HomeTheaterFacade(Amplifier amp, Projector projector, Screen screen) {
        this.amp = amp;
        this.projector = projector;
        this.screen = screen;
    }

    public void watchMovie(String movie) {
        System.out.println("Готовим кинотеатр к просмотру...");
        screen.down();
        amp.on();
        projector.on();
        System.out.println("Запускаем фильм: " + movie);
    }

    public void endMovie() {
        System.out.println("Выключаем кинотеатр...");
        screen.up();
        projector.off();
        amp.off();
    }
}
```

---

# 6. Bridge (Мост)
### Идея
Мост разделяет абстракцию и реализацию на два отдельных класса, которые могут изменяться независимо. Это позволяет создавать разные реализации абстракции без модификации её интерфейса. Паттерн помогает уменьшить количество подклассов при сочетании разных вариантов абстракции и реализации. Он делает систему более гибкой и расширяемой. Используется, когда требуется разделение интерфейса и реализации.

### Когда использовать
- Нужно разделить уровни (например, разные виды форм + разные способы отрисовки).
- Когда абстракция и реализация должны изменяться независимо.

### Плюсы / минусы
+ Абстракция и реализация независимы.  
+ Легко добавлять новые реализации и новые абстракции.  
− Усложняет структуру кода (дополнительный слой).  
− Может быть избыточен для маленьких систем.

### Пример: фигуры и способы их рисования
```java
// BridgeDemo.java
// Демонстрация: фигура (Shape) использует интерфейс Renderer для рисования.
// Можно легко добавлять новые фигуры или новые способы рендера.

public class BridgeDemo {
    public static void main(String[] args) {
        Renderer vector = new VectorRenderer();
        Renderer raster = new RasterRenderer();

        Shape circle1 = new Circle(vector);
        Shape circle2 = new Circle(raster);

        circle1.draw();
        circle2.draw();
    }
}

interface Renderer {
    void renderCircle(float radius);
}

class VectorRenderer implements Renderer {
    public void renderCircle(float radius) {
        System.out.println("Рисуем круг в векторном виде с радиусом " + radius);
    }
}

class RasterRenderer implements Renderer {
    public void renderCircle(float radius) {
        System.out.println("Рисуем пиксельный круг с радиусом " + radius);
    }
}

// Абстракция
abstract class Shape {
    protected Renderer renderer;

    public Shape(Renderer renderer) {
        this.renderer = renderer;
    }

    public abstract void draw();
}

class Circle extends Shape {
    private float radius = 5;

    public Circle(Renderer renderer) {
        super(renderer);
    }

    @Override
    public void draw() {
        renderer.renderCircle(radius);
    }
}
```

---

# 7. Decorator (Декоратор)
### Идея
Декоратор позволяет динамически добавлять новые функциональные возможности объекту без изменения его структуры. Каждый декоратор реализует тот же интерфейс, что и исходный объект, и может оборачивать его. Паттерн упрощает расширение функциональности по сравнению с наследованием. Он делает систему гибкой и позволяет комбинировать декораторы. Применяется, когда нужно добавлять поведение объектам во время выполнения.
### Когда использовать
- Нужно добавлять новые обязанности объектам на лету.
- Не хочется создавать кучу подклассов.

### Плюсы / минусы
+ Позволяет гибко добавлять функциональность без изменения исходного кода.  
+ Можно комбинировать несколько декораторов.  
− Много мелких классов, которые могут усложнить понимание.  
− Не всегда очевидно, в каком порядке применяются декораторы.

### Пример: добавление функциональности кофе
```java
// DecoratorDemo.java
// Демонстрация: есть базовый кофе, и мы можем добавлять "ингредиенты" (молоко, сахар).
// Каждый декоратор оборачивает исходный объект.

public class DecoratorDemo {
    public static void main(String[] args) {
        Coffee coffee = new SimpleCoffee();
        System.out.println(coffee.getDescription() + " = " + coffee.getCost());

        coffee = new MilkDecorator(coffee);
        System.out.println(coffee.getDescription() + " = " + coffee.getCost());

        coffee = new SugarDecorator(coffee);
        System.out.println(coffee.getDescription() + " = " + coffee.getCost());
    }
}

interface Coffee {
    String getDescription();
    double getCost();
}

// Базовый класс
class SimpleCoffee implements Coffee {
    @Override
    public String getDescription() {
        return "Обычный кофе";
    }

    @Override
    public double getCost() {
        return 2.0;
    }
}

// Декоратор
abstract class CoffeeDecorator implements Coffee {
    protected Coffee decoratedCoffee;

    public CoffeeDecorator(Coffee coffee) {
        this.decoratedCoffee = coffee;
    }
}

// Конкретные декораторы
class MilkDecorator extends CoffeeDecorator {
    public MilkDecorator(Coffee coffee) {
        super(coffee);
    }

    @Override
    public String getDescription() {
        return decoratedCoffee.getDescription() + ", молоко";
    }

    @Override
    public double getCost() {
        return decoratedCoffee.getCost() + 0.5;
    }
}

class SugarDecorator extends CoffeeDecorator {
    public SugarDecorator(Coffee coffee) {
        super(coffee);
    }

    @Override
    public String getDescription() {
        return decoratedCoffee.getDescription() + ", сахар";
    }

    @Override
    public double getCost() {
        return decoratedCoffee.getCost() + 0.2;
    }
}
```

---


# Заключение
- **Adapter** — подключаем несовместимые интерфейсы.  
- **Composite** — дерево объектов (часть-целое).  
- **Proxy** — контролируем доступ к объекту.  
- **Flyweight** — экономим память, разделяя общее состояние.  
- **Facade** — упрощаем доступ к сложной системе.  
- **Bridge** — разделяем абстракцию и реализацию.  
- **Decorator** — добавляем функциональность объекту динамически.

# Поведенческие паттерны проектирования

## 1. Template Method (Шаблонный метод)
**Описание:** Шаблонный метод позволяет определить общий алгоритм в виде последовательности шагов в базовом классе, при этом оставляя конкретную реализацию отдельных шагов подклассам. Такой подход помогает повторно использовать код и обеспечивает единообразие алгоритмов, при этом позволяя подклассам менять только детали без изменения общей структуры.

**Плюсы:**
- Централизованное управление алгоритмом.
- Возможность переопределять отдельные шаги алгоритма.

**Минусы:**
- Подклассы жестко зависят от структуры базового класса.
- Меньшая гибкость по сравнению с Strategy.

**Когда применять:**
- Когда есть повторяющаяся структура алгоритма и необходимо менять только отдельные шаги.

```java
import lombok.extern.slf4j.Slf4j;

@Slf4j
abstract class DataProcessor {
    public final void process() {
        readData();  // шаг 1: чтение данных
        processData(); // шаг 2: обработка данных
        saveData();    // шаг 3: сохранение данных
    }

    protected abstract void readData();
    protected abstract void processData();
    protected abstract void saveData();
}

@Slf4j
class CSVDataProcessor extends DataProcessor {
    @Override
    protected void readData() {
        log.info("Чтение CSV данных");
    }

    @Override
    protected void processData() {
        log.info("Обработка CSV данных");
    }

    @Override
    protected void saveData() {
        log.info("Сохранение CSV данных");
    }
}

public class Main {
    public static void main(String[] args) {
        DataProcessor processor = new CSVDataProcessor();
        processor.process();
    }
}
```

---

## 2. Mediator (Посредник)
**Описание:** Посредник централизует взаимодействие между объектами. Вместо того чтобы компоненты напрямую ссылались друг на друга, они общаются через посредника. Это снижает связность и упрощает поддержку сложных систем с большим количеством взаимозависимых объектов.

**Плюсы:**
- Уменьшение связности компонентов.
- Упрощение изменений и добавления новых взаимодействий.

**Минусы:**
- Посредник может стать слишком сложным и тяжёлым для поддержки.

**Когда применять:**
- Когда много объектов взаимодействуют друг с другом и необходимо централизовать это взаимодействие.

```java
import lombok.Data;
import lombok.extern.slf4j.Slf4j;

@Slf4j
class Mediator {
    public void notify(Component sender, String event) {
        if (event.equals("A")) {
            log.info("Mediator реагирует на событие A и инициирует действия B");
        } else if (event.equals("B")) {
            log.info("Mediator реагирует на событие B и инициирует действия A");
        }
    }
}

@Data
class Component {
    private Mediator mediator;

    public void trigger(String event) {
        log.info("Component триггерит событие: {}", event);
        mediator.notify(this, event);
    }
}

public class Main {
    public static void main(String[] args) {
        Mediator mediator = new Mediator();
        Component comp1 = new Component();
        Component comp2 = new Component();

        comp1.setMediator(mediator);
        comp2.setMediator(mediator);

        comp1.trigger("A");
        comp2.trigger("B");
    }
}
```

---

## 3. Chain of Responsibility (Цепочка обязанностей)
**Описание:** Позволяет передавать запрос по цепочке объектов до тех пор, пока один из них не обработает его. Отправитель запроса не знает, какой объект его обработает, что делает систему гибкой и легко расширяемой.

**Плюсы:**
- Гибкость в обработке запросов.
- Разделение обязанностей.

**Минусы:**
- Нет гарантии, что запрос будет обработан.
- Цепочка может стать слишком длинной.

**Когда применять:**
- Когда запрос может быть обработан несколькими объектами и нужно избегать жёсткой зависимости.

```java
import lombok.extern.slf4j.Slf4j;

@Slf4j
abstract class Handler {
    protected Handler next;

    public void setNext(Handler next) {
        this.next = next;
    }

    public abstract void handle(String request);
}

@Slf4j
class ConcreteHandlerA extends Handler {
    @Override
    public void handle(String request) {
        if (request.equals("A")) {
            log.info("Handler A обработал запрос");
        } else if (next != null) {
            next.handle(request);
        }
    }
}

@Slf4j
class ConcreteHandlerB extends Handler {
    @Override
    public void handle(String request) {
        if (request.equals("B")) {
            log.info("Handler B обработал запрос");
        } else if (next != null) {
            next.handle(request);
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Handler handlerA = new ConcreteHandlerA();
        Handler handlerB = new ConcreteHandlerB();
        handlerA.setNext(handlerB);

        handlerA.handle("B");
    }
}
```

---

## 4. Observer (Наблюдатель)
**Описание:** Наблюдатель позволяет объектам подписываться на события другого объекта и автоматически получать уведомления об изменениях. Основная цель — слабая связка между объектами: субъекты уведомляют наблюдателей без знания их внутренней реализации.

**Плюсы:**
- Слабая связка между объектами.
- Легкое добавление новых наблюдателей.

**Минусы:**
- Сложно отследить всех подписчиков.
- Массовое уведомление может снизить производительность.

**Когда применять:**
- Когда один объект должен уведомлять множество других о своих изменениях.

```java
import lombok.extern.slf4j.Slf4j;
import java.util.ArrayList;
import java.util.List;

@Slf4j
interface Observer {
    void update(String message);
}

@Slf4j
class ConcreteObserver implements Observer {
    private String name;

    public ConcreteObserver(String name) {
        this.name = name;
    }

    @Override
    public void update(String message) {
        log.info("Observer {} получил сообщение: {}", name, message);
    }
}

@Slf4j
class Subject {
    private List<Observer> observers = new ArrayList<>();

    public void addObserver(Observer observer) {
        observers.add(observer);
    }

    public void notifyObservers(String message) {
        for (Observer observer : observers) {
            observer.update(message);
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Subject subject = new Subject();
        subject.addObserver(new ConcreteObserver("A"));
        subject.addObserver(new ConcreteObserver("B"));

        subject.notifyObservers("Событие произошло");
    }
}
```

---

## 5. Strategy (Стратегия)
**Описание:** Стратегия позволяет менять алгоритм или поведение объекта во время выполнения. Основная идея — вынести алгоритмы в отдельные классы и использовать их через общий интерфейс, что обеспечивает гибкость и слабую связку.

**Плюсы:**
- Легкая замена алгоритмов.
- Слабая связка между контекстом и стратегиями.

**Минусы:**
- Увеличение количества классов.

**Когда применять:**
- Когда требуется менять поведение объекта во время выполнения.

```java
import lombok.extern.slf4j.Slf4j;

@Slf4j
interface PaymentStrategy {
    void pay(int amount);
}

@Slf4j
class CreditCardPayment implements PaymentStrategy {
    @Override
    public void pay(int amount) {
        log.info("Оплата {} кредитной картой", amount);
    }
}

@Slf4j
class PayPalPayment implements PaymentStrategy {
    @Override
    public void pay(int amount) {
        log.info("Оплата {} через PayPal", amount);
    }
}

@Slf4j
class ShoppingCart {
    private PaymentStrategy strategy;

    public void setPaymentStrategy(PaymentStrategy strategy) {
        this.strategy = strategy;
    }

    public void checkout(int amount) {
        strategy.pay(amount); // делегирование оплаты выбранной стратегии
    }
}

public class Main {
    public static void main(String[] args) {
        ShoppingCart cart = new ShoppingCart();
        cart.setPaymentStrategy(new CreditCardPayment());
        cart.checkout(500);

        cart.setPaymentStrategy(new PayPalPayment());
        cart.checkout(1000);
    }
}

---

## 6. Command (Команда)
**Описание:** Паттерн Команда инкапсулирует запрос как объект, позволяя параметризовать объекты действиями, ставить их в очередь или журналировать. Он отделяет отправителя запроса от объекта, который выполняет действие. Такой подход облегчает реализацию отмены и повтора операций, а также поддержку макросов. Паттерн обеспечивает гибкость и расширяемость системы, позволяя легко добавлять новые команды без изменения существующих классов. Команды могут быть сохранены и выполнены позже, что делает их удобными для отложенных действий.

**Плюсы:**
- Инкапсуляция действий.
- Возможность реализовать отмену и повтор операций.
- Упрощает поддержку макросов и отложенного выполнения.

**Минусы:**
- Увеличение числа классов.
- Может усложнить структуру проекта при большом количестве команд.

**Когда применять:**
- Когда нужно параметризовать объекты действиями.
- Когда требуется сохранять, журналировать или откатывать действия.

```java
import lombok.extern.slf4j.Slf4j;

// Интерфейс команды с методом execute
@Slf4j
interface Command {
    void execute();
}

// Класс устройства, на котором выполняются команды
@Slf4j
class Light {
    public void turnOn() {
        log.info("Свет включен");
    }

    public void turnOff() {
        log.info("Свет выключен");
    }
}

// Конкретная команда включения света
@Slf4j
class TurnOnCommand implements Command {
    private Light light;

    public TurnOnCommand(Light light) {
        this.light = light;
    }

    @Override
    public void execute() {
        light.turnOn(); // делегируем действие устройству
    }
}

// Пульт управления, который вызывает команды
@Slf4j
class RemoteControl {
    private Command command;

    public void setCommand(Command command) {
        this.command = command;
    }

    public void pressButton() {
        command.execute(); // выполняем команду
    }
}

public class Main {
    public static void main(String[] args) {
        Light light = new Light();
        Command turnOn = new TurnOnCommand(light);
        RemoteControl remote = new RemoteControl();
        remote.setCommand(turnOn);
        remote.pressButton(); // включение света через команду
    }
}
```

---

## 7. State (Состояние)
**Описание:** Паттерн Состояние позволяет объекту изменять поведение при изменении его внутреннего состояния. Каждый объект состояния инкапсулирует определённое поведение, что заменяет громоздкие конструкции if/else или switch. Паттерн повышает читаемость и расширяемость кода. Объект делегирует выполнение методов своему текущему состоянию, что делает систему более гибкой. Легко добавлять новые состояния без изменения существующих классов.

**Плюсы:**
- Упрощает код с множеством условий.
- Легко добавлять новые состояния.
- Повышает читаемость и поддержку.

**Минусы:**
- Увеличение числа классов.
- Сложнее отследить все состояния в больших системах.

**Когда применять:**
- Когда поведение объекта зависит от его состояния.
- Когда необходимо легко расширять систему новыми состояниями.

```java
import lombok.extern.slf4j.Slf4j;

// Интерфейс состояния
@Slf4j
interface State {
    void handle();
}

// Конкретное состояние включенного устройства
@Slf4j
class OnState implements State {
    @Override
    public void handle() {
        log.info("Состояние ON: устройство работает");
    }
}

// Конкретное состояние выключенного устройства
@Slf4j
class OffState implements State {
    @Override
    public void handle() {
        log.info("Состояние OFF: устройство выключено");
    }
}

// Контекст, который меняет состояния
@Slf4j
class Device {
    private State state;

    public void setState(State state) {
        this.state = state; // изменение текущего состояния
    }

    public void request() {
        state.handle(); // делегирование поведения текущему состоянию
    }
}

public class Main {
    public static void main(String[] args) {
        Device device = new Device();
        device.setState(new OnState());
        device.request(); // устройство работает
        device.setState(new OffState());
        device.request(); // устройство выключено
    }
}
```

---

## 8. Visitor (Посетитель)
**Описание:** Паттерн Visitor позволяет добавлять новые операции для группы объектов, не изменяя их классы. Он отделяет алгоритмы от объектов, над которыми эти алгоритмы выполняются. Это особенно полезно для сложных иерархий, где часто добавляются новые операции. Паттерн делает код более открытым к расширению и закрытым к модификации. Он упрощает поддержку и тестирование различных операций.

**Плюсы:**
- Легко добавлять новые операции.
- Подходит для сложных структур объектов.
- Снижает связность между классами элементов и операциями.

**Минусы:**
- Трудно добавлять новые типы элементов.
- Требуется строгая структура иерархии.

**Когда применять:**
- Когда нужно выполнять разные операции над объектами сложной структуры.
- Когда операции часто меняются или добавляются.

```java
import lombok.extern.slf4j.Slf4j;

// Интерфейс посетителя
@Slf4j
interface Visitor {
    void visit(Book book);
    void visit(CD cd);
}

// Конкретный посетитель для вывода цены
@Slf4j
class PriceVisitor implements Visitor {
    @Override
    public void visit(Book book) {
        log.info("Цена книги: {}", book.getPrice());
    }

    @Override
    public void visit(CD cd) {
        log.info("Цена CD: {}", cd.getPrice());
    }
}

// Элемент структуры
@Slf4j
interface Item {
    void accept(Visitor visitor);
}

// Конкретные элементы
@Slf4j
class Book implements Item {
    private int price;

    public Book(int price) {
        this.price = price;
    }

    public int getPrice() {
        return price;
    }

    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
}

@Slf4j
class CD implements Item {
    private int price;

    public CD(int price) {
        this.price = price;
    }

    public int getPrice() {
        return price;
    }

    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
}

public class Main {
    public static void main(String[] args) {
        Item[] items = {new Book(100), new CD(200)};
        Visitor visitor = new PriceVisitor();
        for (Item item : items) {
            item.accept(visitor);
        }
    }
}
```

---

## 9. Interpreter (Интерпретатор)
**Описание:** Паттерн Интерпретатор определяет грамматику простого языка и интерпретирует предложения этого языка. Он позволяет создавать интерпретаторы для специализированных языков и выражений. Паттерн упрощает анализ и обработку выражений, делая код более структурированным. Легко расширять новые правила и синтаксис. Особенно полезен для вычисления, проверки и интерпретации формул или DSL.

**Плюсы:**
- Легко расширять синтаксис и правила.
- Четкая структура грамматики.

**Минусы:**
- Сложность поддержки для сложного языка.
- Может создавать много небольших классов.

**Когда применять:**
- Для интерпретации выражений специализированного языка.
- Для построения компиляторов, парсеров или простых DSL.

```java
import lombok.extern.slf4j.Slf4j;

// Интерфейс выражения
@Slf4j
interface Expression {
    boolean interpret(String context);
}

// Конкретное терминальное выражение
@Slf4j
class TerminalExpression implements Expression {
    private String data;

    public TerminalExpression(String data) {
        this.data = data;
    }

    @Override
    public boolean interpret(String context) {
        return context.contains(data);
    }
}

// Операция ИЛИ над выражениями
@Slf4j
class OrExpression implements Expression {
    private Expression expr1;
    private Expression expr2;

    public OrExpression(Expression expr1, Expression expr2) {
        this.expr1 = expr1;
        this.expr2 = expr2;
    }

    @Override
    public boolean interpret(String context) {
        return expr1.interpret(context) || expr2.interpret(context);
    }
}

public class Main {
    public static void main(String[] args) {
        Expression expr1 = new TerminalExpression("Java");
        Expression expr2 = new TerminalExpression("Python");
        Expression orExpression = new OrExpression(expr1, expr2);

        log.info("Результат интерпретации: {}", orExpression.interpret("Java"));
    }
}
```

---

## 10. Iterator (Итератор)
**Описание:** Итератор позволяет последовательно обходить элементы коллекции, не раскрывая её внутреннюю структуру. Паттерн предоставляет единый интерфейс для обхода разных типов коллекций. Он делает код обхода универсальным и повторно используемым. Позволяет реализовать несколько способов обхода для одной коллекции. Упрощает работу с комплексными структурами данных.

**Плюсы:**
- Универсальный способ обхода.
- Слабая связка между коллекцией и обходом.

**Минусы:**
- Дополнительные объекты-итераторы.
- Могут усложнить код при очень больших коллекциях.

**Когда применять:**
- Когда требуется последовательный доступ к элементам коллекции.
- Когда нужно скрыть внутреннюю структуру коллекции.

```java
import lombok.extern.slf4j.Slf4j;
import java.util.ArrayList;
import java.util.List;
import java.util.Iterator;

@Slf4j
public class Main {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("A");
        list.add("B");
        list.add("C");

       

---

## 10. Iterator (Итератор)
**Описание:** Итератор позволяет последовательно обходить элементы коллекции, не раскрывая её внутреннюю структуру. Он предоставляет единый интерфейс обхода для различных типов коллекций. Это упрощает работу с комплексными структурами данных и делает код более универсальным и повторно используемым. Паттерн поддерживает несколько способов обхода одной коллекции. Он также позволяет безопасно перебирать элементы, не зависимо от внутренней реализации коллекции.

**Плюсы:**
- Универсальный способ обхода элементов.
- Слабая связка между коллекцией и обходом.
- Возможность реализовать разные стратегии обхода.

**Минусы:**
- Дополнительные объекты-итераторы.
- Может увеличивать использование памяти при больших коллекциях.

**Когда применять:**
- Когда требуется последовательный доступ к элементам коллекции.
- Когда нужно скрыть внутреннюю структуру коллекции.

```java
import lombok.extern.slf4j.Slf4j;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

@Slf4j
public class Main {
    public static void main(String[] args) {
        // Создаем коллекцию элементов
        List<String> list = new ArrayList<>();
        list.add("A");
        list.add("B");
        list.add("C");

        // Получаем итератор для обхода коллекции
        Iterator<String> iterator = list.iterator();

        // Проходим по всем элементам, не зная внутренней структуры коллекции
        while (iterator.hasNext()) {
            String item = iterator.next();
            log.info("Элемент коллекции: {}", item); // выводим текущий элемент
        }
    }
}
```

---

## 11. Memento (Хранитель)
**Описание:** Memento позволяет сохранять и восстанавливать прошлое состояние объекта, не нарушая инкапсуляцию. Это полезно для реализации undo/redo и отката изменений. Хранитель отделяет состояние объекта от его поведения, обеспечивая сохранение истории изменений без вмешательства в код объекта. Паттерн повышает гибкость системы, позволяя легко восстанавливать прежние состояния. Он также упрощает тестирование и откат ошибок в сложных объектах.

**Плюсы:**
- Сохраняет инкапсуляцию объекта.
- Позволяет реализовать undo/redo и откат состояний.
- Упрощает тестирование и управление сложными объектами.

**Минусы:**
- Может потреблять много памяти при частом сохранении состояний.
- Требует дополнительного кода для управления хранителями.

**Когда применять:**
- Когда необходимо сохранять и восстанавливать состояния объектов.
- При реализации undo/redo и сохранении истории изменений.

```java
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

// Хранитель, содержащий состояние
@Slf4j
@Getter
class Memento {
    private final String state;

    public Memento(String state) {
        this.state = state;
    }
}

// Объект, состояние которого нужно сохранять
@Slf4j
class Originator {
    @Setter
    private String state;

    // Сохраняем текущее состояние
    public Memento save() {
        log.info("Сохраняем состояние: {}", state);
        return new Memento(state);
    }

    // Восстанавливаем предыдущее состояние
    public void restore(Memento memento) {
        state = memento.getState();
        log.info("Восстановлено состояние: {}", state);
    }
}

@Slf4j
public class Main {
    public static void main(String[] args) {
        Originator originator = new Originator();
        originator.setState("Состояние1");
        Memento saved = originator.save(); // сохраняем текущее состояние

        originator.setState("Состояние2");
        log.info("Текущее состояние изменилось: {}", originator.getState());

        originator.restore(saved); // откат к предыдущему состоянию
    }
}



# Общая вводная
SOLID — набор пяти принципов объектно-ориентированного проектирования, предложенных Робертом Мартином (Uncle Bob). Цель SOLID — сделать код более гибким, поддерживаемым, тестируемым и понятным. Эти принципы часто применяют вместе: соблюдение одного помогает соблюдению остальных, но и чрезмерное применение (перегиб в сторону абстракций) — источник проблем. Ниже — подробный разбор.

---

# 1) Single Responsibility Principle (SRP)
**Кратко:** каждый класс/модуль должен иметь ровно одну причину для изменения — одну ответственность.

**Развёрнутое объяснение (несколько абзацев):**  
SRP говорит, что класс должен фокусироваться на одной «ответственности» — одной логической задаче или аспекте системы. Под «причиной для изменения» понимают ситуацию, когда из-за изменения в требованиях нужно править класс. Если у класса много обязанностей, то изменения в одной области сломают логику в другой, сложится сильная связанность (coupling) и класс станет сложен для тестирования.

Важная тонкость — granularity (гранулярность): что считать «одной ответственностью»? Для модуля/класса уровня высокоуровневой бизнес-логики ответственность может означать «обработка заказов», тогда внутренние детали (логирование, валидация, пересылка уведомлений) выносятся в отдельные классы. При этом не следует дробить до абсурда — слишком много мелких классов создаёт сложность в навигации (cognitive load) и усложняет поддержку.

SRP тесно связан с тестированием: классы с одной обязанностью легче мокать и тестировать единично (unit tests). В Java SRP часто реализуют через сервисы, репозитории, DTO и утилитные классы — каждый слой отвечает за свою зону (слой данных, бизнес-логика, представление).

**Где применяется в Java:** сервисы в Spring (`@Service`) — одна ответственность (бизнес-логика), репозитории (`@Repository`) — доступ к данным, контроллеры (`@Controller`) — обработка HTTP/маршрутизация. Также SRP применяется при проектировании утилит/хелперов — не смешивать форматирование и доступ к БД.

**Подводные камни и тонкости:**
- SRP не значит «1 файл = 1 метод». Нужно здравое разделение по смыслу.  
- Слишком ранняя декомпозиция (premature decomposition) увеличит число классов и усложнит навигацию.  
- Нельзя забывать о связях: иногда несколько мелких классов создают чрезмерное количество зависимостей — балансируйте.  

## Java — плохой пример (нарушение SRP)
```java
// Плохой пример: класс ReportManager нарушает SRP — делает слишком много задач одновременно:
// - формирует данные из БД
// - форматирует отчет
// - сохраняет отчет в файл
// - отправляет отчет по e-mail
public class ReportManager {
    // Метод формирует и распределяет отчёт
    public void generateAndSendReport() {
        // 1) Получаем данные — доступ к БД (логика доступа к данным)
        // В реальности это должен быть отдельный репозиторий/DAO
        List<String> data = loadDataFromDatabase(); // <-- смешаны уровни: БД внутри менеджера

        // 2) Форматируем отчет (Presentation/Formatting)
        String report = formatReport(data); // <-- форматирование в том же классе — нарушение SRP

        // 3) Сохраняем в файл (I/O)
        saveReportToFile(report, "/tmp/report.txt"); // <-- I/O и бизнес в одном месте

        // 4) Отправляем по email (интеграция с внешним сервисом)
        sendEmail("boss@example.com", "Отчет", report); // <-- сетевые операции в том же классе
    }

    private List<String> loadDataFromDatabase() {
        // заглушка — в реальном коде здесь SQL/ORM
        return Arrays.asList("A", "B", "C");
    }

    private String formatReport(List<String> data) {
        // простая строковая сборка — но логика форматирования внутри
        StringBuilder sb = new StringBuilder();
        for (String s : data) {
            sb.append(s).append("
");
        }
        return sb.toString();
    }

    private void saveReportToFile(String report, String path) {
        // простой пример записи в файл — но ответственность класса теперь I/O
        try (PrintWriter out = new PrintWriter(path)) {
            out.print(report);
        } catch (FileNotFoundException e) {
            // плохой способ управления ошибками — логика ошибки смешана с бизнесом
            e.printStackTrace();
        }
    }

    private void sendEmail(String to, String subject, String body) {
        // заглушка — в реальном проекте это интеграция с SMTP/API
        System.out.println("Отправка письма: " + to);
    }
}
```

## Java — хороший пример (соответствие SRP)
```java
// Правильный пример: разделяем ответственности на несколько классов.
// 1) Репозиторий — доступ к данным
// 2) Форматтер — отвечает за формат отчета
// 3) Хранилище (file storage) — отвечает за сохранение
// 4) MailSender — отвечает за отправку писем
// 5) Сервис — orchestrator, который использует абстракции

// Интерфейс репозитория — ответственность: доступ к данным
interface ReportRepository {
    List<String> loadData(); // метод получения данных
}

// Конкретная реализация репозитория (например, через JPA/DAO)
class DatabaseReportRepository implements ReportRepository {
    @Override
    public List<String> loadData() {
        // Здесь реальная логика доступа к БД (JPA/Hibernate/SQL)
        return Arrays.asList("A", "B", "C");
    }
}

// Форматтер — ответственность: преобразование данных в текст отчёта
class ReportFormatter {
    // Форматировать список строк в тело отчёта
    public String format(List<String> data) {
        StringBuilder sb = new StringBuilder();
        for (String s : data) {
            sb.append(s).append(System.lineSeparator());
        }
        return sb.toString();
    }
}

// Хранилище файлов — ответственность: сохранение отчёта
class FileStorage {
    // Сохранить текст в файл по указанному пути
    public void save(String path, String content) throws IOException {
        try (PrintWriter out = new PrintWriter(path)) {
            out.print(content);
        }
    }
}

// Отправка почты — ответственность: взаимодействие с почтовым сервисом
class MailSender {
    public void send(String to, String subject, String body) {
        // В реальном коде — использовать JavaMailSender или внешнее API
        System.out.println("Simulate sending mail to " + to);
    }
}

// Сервис-оркестратор — ответственность: стек операций для формирования и отправки отчета.
// Важное замечание: сервис зависит от абстракций/конкретных классов, но каждая из зависимостей
// имеет свою ясную ответственность.
class ReportService {
    private final ReportRepository repository; // зависимость: доступ к данным
    private final ReportFormatter formatter;   // зависимость: форматирование
    private final FileStorage storage;         // зависимость: сохранение в файл
    private final MailSender mailSender;       // зависимость: отправка почты

    // Конструктор — зависимости внедряются извне (удобно для тестирования)
    public ReportService(ReportRepository repository,
                         ReportFormatter formatter,
                         FileStorage storage,
                         MailSender mailSender) {
        this.repository = repository;
        this.formatter = formatter;
        this.storage = storage;
        this.mailSender = mailSender;
    }

    // Операция, описывающая один сценарий — сама по себе короткая,
    // делегирует детали специализированным классам.
    public void generateAndSendReport(String path, String recipient) throws IOException {
        // 1) Получаем данные — репозиторий отвечает за этот аспект
        List<String> data = repository.loadData();

        // 2) Форматируем — форматтер отвечает за представление
        String report = formatter.format(data);

        // 3) Сохраняем — FileStorage отвечает за I/O
        storage.save(path, report);

        // 4) Отправляем — MailSender отвечает за интеграцию с почтой
        mailSender.send(recipient, "Отчет", report);
    }
}
```

---

# 2) Open/Closed Principle (OCP)
**Кратко:** сущности должны быть открыты для расширения, но закрыты для изменения.

**Развёрнутое объяснение:**  
OCP означает, что поведение модуля/класса должно быть расширяемым без изменения существующего кода. На практике это достигают через абстракции (интерфейсы, абстрактные классы, стратегии, плагинную архитектуру). Идея — при добавлении новой функциональности не ломать проверенный код, а добавлять новые реализации абстракций.

Тонкость: «закрыт для изменения» не значит «всегда никогда не менять». Иногда рефакторинг и исправление багов требует изменения существующего кода; OCP — ориентир проектирования, а не догма. Кроме того, OCP часто реализуют с преднамеренным использованием наследования/композиции и DI. В Java добавление новых `enum`-типов или switch/case по типу обычно нарушает OCP — каждый switch может потребовать правки при появлении нового кейса.

OCP важен для поддержки в масштабе: если у вас модуль используется многими командами, изменение базового поведения может вызвать регрессии. Поэтому проектируют расширяемые точки, а остальное закрывают.

**Где применяется в Java:** паттерны Strategy, Template Method, Chain of Responsibility, использование интерфейсов и Spring-бинов с профилями/фабриками; плагинные архитектуры (ServiceLoader), обработчики событий.

**Подводные камни:**
- Излишняя абстракция и интерфейсы «на всё» — усложняет код и повышает трудозатраты.
- OCP обычно достигается через интерфейсы/абстракции — следите за тем, чтобы интерфейсы были стабильны и понятны.
- Иногда проще изменить код, чем выдумывать сложную архитектуру.

## Java — плохой пример (нарушение OCP)
```java
// Плохой пример: калькулятор скидок с switch по типу клиента.
// При добавлении нового типа нужно изменить существующий класс — нарушение OCP.
public class DiscountCalculator {
    public enum CustomerType { REGULAR, VIP }

    // Метод вычисляет скидку в зависимости от типа клиента
    public double calculateDiscount(CustomerType type, double amount) {
        // switch — каждый новый тип заставит менять этот код
        switch (type) {
            case REGULAR:
                return amount * 0.05; // 5% для обычных
            case VIP:
                return amount * 0.15; // 15% для VIP
            default:
                return 0;
        }
    }
}
```

## Java — хороший пример (соответствие OCP)
```java
// Правильный пример: используем абстракцию DiscountPolicy.
// Добавление нового типа скидки — реализация нового класса, без изменения калькулятора.

interface DiscountPolicy {
    double applyDiscount(double amount); // абстрактный контракт для скидки
}

// Конкретная стратегия: стандартная скидка
class RegularDiscountPolicy implements DiscountPolicy {
    @Override
    public double applyDiscount(double amount) {
        return amount * 0.05; // 5%
    }
}

// Конкретная стратегия: VIP скидка
class VipDiscountPolicy implements DiscountPolicy {
    @Override
    public double applyDiscount(double amount) {
        return amount * 0.15; // 15%
    }
}

// Класс-агрегатор/калькулятор — закрыт для изменения: он просто использует политику
class DiscountCalculator {
    private final DiscountPolicy policy; // зависит от абстракции

    // Внедряем политику через конструктор (DI)
    public DiscountCalculator(DiscountPolicy policy) {
        this.policy = policy;
    }

    // Вычисление скидки делегируется политике — при добавлении новых политик класс не меняется
    public double calculateDiscount(double amount) {
        return policy.applyDiscount(amount);
    }
}

// Добавление новой политики (например, SeasonalDiscountPolicy) не потребует изменения DiscountCalculator.
```

---

# 3) Liskov Substitution Principle (LSP)
**Кратко:** объекты подклассов должны быть взаимозаменяемы с объектами базового класса без нарушения корректности программы (предикат: экземпляр подкласса должен вести себя как экземпляр суперкласса).

**Развёрнутое объяснение:**  
LSP — это формализация корректного наследования: подклассы должны сохранять поведение, ожидаемое от базового типа. Это касается пред- и постусловий методов, инвариантов и побочных эффектов. Если клиент кода ожидает поведение базового класса, замена его на подкласс не должна ломать программу.

Классический пример нарушения LSP — наследование `Square` от `Rectangle`. В `Rectangle` у вас есть `setWidth` и `setHeight`. Для квадрата изменение ширины меняет высоту, что ломает ожидание клиента, который думает, что `setWidth` не затрагивает высоту. Следовательно `Square` не соответствует контракту `Rectangle`.

Тонкости: LSP — это не только сигнатуры методов (типовые сигнатуры), но и поведение: исключения, изменения состояния, побочные эффекты, производительность (в редких случаях существенная деградация производительности может считаться нарушением, если код ожидает характеристики). В Java также важно учитывать ковариантность возвращаемых типов и неизменяемость — immutable классы проще соответствовать LSP.

**Где применяется в Java:** при проектировании иерархий классов, коллекций, API библиотек; при наследовании от стандартных классов Java (например, `InputStream`) — всегда думайте о контракте суперкласса.

**Подводные камни:**
- Простая замена `extends` на `implements` или композицию часто решает проблему.  
- Нарушение LSP может быть тонким: изменение хранимого состояния, ожидание вызова `equals`/`hashCode`, сериализация — всё это может ломать поведение.  
- Документируйте контракты методов (JavaDoc): pre/post-условия, возможные исключения — чтобы унаследовавшие классы знали гарантии.

## Java — плохой пример (нарушение LSP — Rectangle/Square)
```java
// Пример классического нарушения LSP: Square наследует Rectangle,
// но поведение методов setWidth/setHeight становится неожиданным.

class Rectangle {
    protected int width;
    protected int height;

    // Установить ширину
    public void setWidth(int width) {
        this.width = width;
    }

    // Установить высоту
    public void setHeight(int height) {
        this.height = height;
    }

    // Получить площадь
    public int getArea() {
        return width * height;
    }
}

// Square наследует Rectangle — кажется логичным с точки зрения "is-a",
// но поведение нарушает ожидания: у квадрата установка ширины должна менять высоту.
class Square extends Rectangle {
    @Override
    public void setWidth(int width) {
        // чтобы оставаться "квадратом", ширину и высоту синхронизируем
        this.width = width;
        this.height = width; // побочный эффект — нарушает контракт Rectangle
    }

    @Override
    public void setHeight(int height) {
        this.width = height;
        this.height = height; // аналогично
    }
}

// Клиентский код, который ожидает Rectangle, может ломаться:
class Client {
    // Ожидается, что setWidth не повлияет на высоту — но для Square это не так
    public static void main(String[] args) {
        Rectangle r = new Square();
        r.setWidth(5);
        r.setHeight(4);
        // Ожидаемая площадь: 5*4=20, но для Square после setHeight(4) width==4 -> площадь 16
        System.out.println("Area = " + r.getArea()); // неожиданное поведение
    }
}
```

## Java — хороший пример (соответствие LSP)
```java
// Решение: не наследовать Square от Rectangle; вместо этого:
// 1) Создать интерфейс Shape (поведение: area)
// 2) Конкретные реализации Rectangle и Square не наследуют друг друга.
// Это сохраняет LSP — объекты взаимозаменяемы по интерфейсу Shape.

interface Shape {
    int getArea(); // контракт: возвращает площадь
}

class RectangleShape implements Shape {
    private final int width;
    private final int height;

    // Rectangle - неизменяемый объект (immutable) — меньше шансов нарушить контракт
    public RectangleShape(int width, int height) {
        this.width = width;
        this.height = height;
    }

    @Override
    public int getArea() {
        return width * height;
    }
}

class SquareShape implements Shape {
    private final int side;

    public SquareShape(int side) {
        this.side = side;
    }

    @Override
    public int getArea() {
        return side * side;
    }
}

// Клиентский код использует Shape и не зависит от деталей реализации.
// Замена RectangleShape на SquareShape не ломает контракт getArea().
class Client {
    public static void main(String[] args) {
        Shape rect = new RectangleShape(5, 4);
        Shape square = new SquareShape(4);

        System.out.println("Rect area = " + rect.getArea());   // 20
        System.out.println("Square area = " + square.getArea()); // 16
    }
}
```

---

# 4) Interface Segregation Principle (ISP)
**Кратко:** клиент не должен быть вынужден зависеть от интерфейсов, которые он не использует — разделяйте «толстые» интерфейсы на узконаправленные.

**Развёрнутое объяснение:**  
Когда интерфейс содержит много методов, разные клиенты могут нуждаться только в подмножестве этих методов. Если класс вынужден реализовать интерфейс целиком, он получает методы, которые ему не нужны — это ведёт к пустым реализациям, заглушкам и усложнению кода. ISP призывает проектировать множество маленьких, «тонких» интерфейсов, специализированных по задаче: каждый клиент реализует только те интерфейсы, которые ему действительно нужны.

Тонкость: разделение интерфейсов должно быть семантически мотивировано. Не стоит дробить интерфейс ради дробления. Java 8 ввёл default-методы в интерфейсах — они облегчают эволюцию интерфейсов, но злоупотребление default может скрыть плохую проектную модель (люди могут начать добавлять поведение в интерфейсы, объединяя обязанности).

**Где применяется в Java:** designing service interfaces, API, DTO, Spring Beans (не заставляйте бины реализовывать лишние методы), JDK interfaces (например, `List` vs `Collection` — JDK уже дробит интерфейсы). В микросервисной архитектуре — отдельные контракты на чтение/запись (CQRS) — тоже пример ISP.

**Подводные камни:**
- Слишком маленькие интерфейсы -> множество интерфейсных типов, что усложняет кодовую базу.  
- Default методы часто используются для обратной совместимости — но они могут нарушить явное разделение обязанностей.  

## Java — плохой пример (нарушение ISP)
```java
// Плохой пример: большой интерфейс MultiFunctionDevice содержит много методов.
// Принуждает имплементаторов реализовывать ненужные операции.
interface MultiFunctionDevice {
    void print(String doc);
    void scan(String doc);
    void fax(String doc);
    void staple(String doc);
}

// Принципиально простой принтер вынужден реализовать все методы,
// даже если он не умеет fax или staple.
class SimplePrinter implements MultiFunctionDevice {
    @Override
    public void print(String doc) {
        System.out.println("Печать: " + doc);
    }

    @Override
    public void scan(String doc) {
        // Этот принтер не умеет сканировать — приходится делать заглушку
        throw new UnsupportedOperationException("Scan not supported");
    }

    @Override
    public void fax(String doc) {
        // заглушка
        throw new UnsupportedOperationException("Fax not supported");
    }

    @Override
    public void staple(String doc) {
        // заглушка
        throw new UnsupportedOperationException("Staple not supported");
    }
}
```

## Java — хороший пример (соответствие ISP)
```java
// Правильный пример: разделяем один большой интерфейс на несколько маленьких.
// Printer, Scanner, Fax, Stapler — клиенты реализуют только нужное.

interface Printer {
    void print(String doc); // ответственность: печать
}

interface Scanner {
    void scan(String doc); // ответственность: сканирование
}

interface Fax {
    void fax(String doc); // ответственность: факс
}

interface Stapler {
    void staple(String doc); // ответственность: степлер
}

// Класс, который только печатает — реализует только Printer
class SimplePrinter2 implements Printer {
    @Override
    public void print(String doc) {
        System.out.println("Печать: " + doc);
    }
}

// Комбинированный многофункциональный девайс может реализовать несколько интерфейсов,
// но каждая реализация остаётся чистой и явной.
class MultiFunctionPrinter implements Printer, Scanner, Stapler {
    @Override
    public void print(String doc) {
        System.out.println("MFP печать: " + doc);
    }

    @Override
    public void scan(String doc) {
        System.out.println("MFP сканирование: " + doc);
    }

    @Override
    public void staple(String doc) {
        System.out.println("MFP сшивание: " + doc);
    }
}
```

---

# 5) Dependency Inversion Principle (DIP)
**Кратко:** модули верхнего уровня не должны зависеть от модулей нижнего уровня — оба должны зависеть от абстракций. Абстракции не должны зависеть от деталей; детали должны зависеть от абстракций.

**Развёрнутое объяснение:**  
DIP говорит: код высокого уровня (бизнес-правила) не должен напрямую зависеть от реализации низкоуровневых модулей (хранилищ, сетевых клиентов). Вместо этого оба уровня должны зависеть от абстракций (интерфейсов). Это облегчает замену реализаций, тестирование (mock), и уменьшает связанность.

В Java DIP реализуют через интерфейсы и внедрение зависимостей (Dependency Injection — вручную или с помощью контейнеров как Spring). Вместо `new ConcreteRepo()` в бизнес-коде используют `Repository repo` в конструкторе и предоставляют конкретную реализацию извне. Это также упрощает написание тестов: в тестах внедряется мок/фейк.

**Где применяется в Java:** везде: сервисы, DAO, репозитории в Spring, абстракции над внешними API, тестируемые компоненты. Также DIP связан с уровнем модулей/пакетов — gradle/maven модули могут зависеть друг от друга только в направлении абстракций.

**Подводные камни:**
- DIP требует больше кода (интерфейсы, фабрики), что может казаться избыточным для небольших проектов.  
- Чрезмерное применение DIP (интерфейсы для всего) — приводит к «interface pollution». Хорошая практика: создавать интерфейс, когда планируется несколько реализаций или когда требуется тестирование.  
- Не забывайте про конфигурацию DI: неправильная конфигурация контейнера приведёт к runtime-ошибкам.

## Java — плохой пример (нарушение DIP)
```java
// Плохой пример: класс OrderService напрямую зависит от конкретной реализации OrderRepositoryImpl.
// Это делает тестирование и замену реализации тяжёлыми.

class OrderRepositoryImpl {
    public void saveOrder(String order) {
        // Конкретная реализация сохранения (например, JDBC)
        System.out.println("Сохранение заказа в БД: " + order);
    }
}

class OrderServiceBad {
    private final OrderRepositoryImpl repository; // зависимость от конкретного класса

    public OrderServiceBad() {
        // явная привязка к конкретной реализации внутри конструктора
        this.repository = new OrderRepositoryImpl();
    }

    public void placeOrder(String order) {
        // бизнес-логика, но мы не можем легко подменить репозиторий (трудно тестировать)
        repository.saveOrder(order);
    }
}
```

## Java — хороший пример (соответствие DIP)
```java
// Правильный пример: зависимость от абстракции (интерфейса), реализация внедряется извне.
// Это упрощает тестирование и замену реализации.

interface OrderRepository {
    void saveOrder(String order); // контракт — абстракция для репозитория
}

class OrderRepositoryJdbc implements OrderRepository {
    @Override
    public void saveOrder(String order) {
        // Конкретная реализация через JDBC/ORM
        System.out.println("Сохранение заказа в БД (JDBC): " + order);
    }
}

// Сервис верхнего уровня зависит от абстракции OrderRepository, а не от конкретики.
// Это позволяет легко подменять реализацию (моки/фейковые репозитории) в тестах.
class OrderService {
    private final OrderRepository repository; // зависимость от интерфейса

    // Конструктор принимает интерфейс — реализация передаётся извне (DI)
    public OrderService(OrderRepository repository) {
        this.repository = repository;
    }

    public void placeOrder(String order) {
        // бизнес-логика — сервис не знает деталей хранения
        repository.saveOrder(order);
    }
}

// Пример конфигурации вручную (в простом приложении)
// В реальном проекте эту работу делает Spring/Guice
class App {
    public static void main(String[] args) {
        // В приложении создаём конкретную реализацию и передаём её в сервис
        OrderRepository repo = new OrderRepositoryJdbc();
        OrderService service = new OrderService(repo); // DI вручную
        service.placeOrder("order#1");
    }
}
```

---

# Общие тонкости при подготовке к собеседованию (senior Java developer)
1. **Баланс абстракций и простоты.** На собеседовании ожидают понимания, когда применять SOLID и когда — нет. Частая ошибка — чрезмерная абстракция (интерфейсы для всего) без явной нужды. Докажите практическим примерами: «я создаю интерфейс, когда ожидаю >1 реализации или когда нужно мокирование/тестирование».

2. **Покажите знание инструментов Java/Spring.** Для DIP и SRP можно привести примеры с `@Autowired`, конфигурацией `@Bean`, `@Profile`, Factory Beans. Объясните разницу constructor injection vs field injection (конструктор предпочтительнее для immutability и тестирования).

3. **Поведение, контракты и документация.** LSP — прежде всего про контракт. Упомяните JavaDoc: указывайте pre/post условия и исключения; обсудите неизменяемость и побочные эффекты. Упомяните про `equals/hashCode` и контракт serializable.

4. **Backward compatibility и OCP.** В Java 8 добавлены default методы — их используют для эволюции интерфейсов, но это может нарушать ISP (интерфейсы начинают содержать поведение).

5. **Performance vs design.** Иногда прямой вызов `new` быстрее и проще; в высокопроизводительных участках слишком сложный DI может добавить накладные расходы. Проведите анализ и профайлинг перед оптимизацией.

6. **Архитектурные границы.** SOLID применяется локально в модуле/сервисе. На уровне микросервисов часто применяют CQRS, event sourcing — эти паттерны отражают принципы ISP/OCP (разделение команд/запросов).

7. **Тестирование и TDD.** SOLID упрощает Unit testing и Mocking. Покажите примеры (Mockito, junit5), почему интерфейсы упрощают создание стаба.

8. **Practical examples at scale.** Можете привести примеры из реальной практики: рефакторинг монолита по SRP (вынос слоёв), введение плагинов через ServiceLoader (OCP), исправление LSP-нарушения в старом коде (перехождение от наследования к композиции).

---

# Резюме — что можно упомянуть на собеседовании (короткая шпаргалка)
- SRP — «одна причина для изменения»; примеры: разделение репозитория/сервиса/форматтера.  
- OCP — «закрыт для изменения, открыт для расширения» через интерфейсы/стратегии/плагины.  
- LSP — подклассы должны быть взаимозаменяемы по контракту (избегать неправильного наследования, использовать композицию).  
- ISP — маленькие интерфейсы; клиенты реализуют только необходимое.  
- DIP — зависеть от абстракций; внедрение зависимостей (constructor injection), использовать Spring/Guice.


# DRY и KISS — подробное объяснение, примеры, тонкости для senior Java собеседования

Отлично — разберём два фундаментальных принципа разработки: **DRY** (Don’t Repeat Yourself) и **KISS** (Keep It Simple, Stupid / Keep It Short & Simple). Для каждого принципа дам несколько больших абзацев с объяснениями и тонкостями, где и как применяется в Java, затем покажу **два Java-примера**: нарушение и соблюдение. В коде будут подробные комментарии на русском — построчно и по методам — чтобы вы могли детально объяснить их на интервью. В конце — практические советы, конфликты между принципами и типичные ловушки.

---

# 1) DRY — Don’t Repeat Yourself

**Кратко:** избегай дублирования знания — логики, конфигурации, требований, строковых констант, SQL-запросов, правил валидации и т. п. Если один и тот же смысл/правило повторяется в нескольких местах — вынеси его в одно место и используй повторно.

**Развёрнутое объяснение (несколько больших абзацев):**  
DRY — это не только про «не копировать и вставлять код». Это про отсутствие дублирования знаний в системе: бизнес-правил, формул, текста сообщений, схемы данных, конфигураций. Повторяющийся код — это источник багов: если правило меняется, нужно править все копии, легко забыть одно место и получить рассинхронизацию. DRY повышает поддерживаемость, уменьшает площадь, которую нужно тестировать, и делает поведение системы предсказуемым.

Однако DRY требует здравого смысла: есть разные виды повторения. Повторение кода, вызванное сходной, но семантически разной логикой — это false positive: агрессивное устранение такого повторения может привести к неправильной общей абстракции (например, попытка объединить методы с чуть разной семантикой). Также существует «повторение в тестах», которое иногда уместно — тесты могут дублировать вызовы, чтобы быть максимально ясными и независимыми. Главное — различать **повторение знания** (нужно устранить) и **повторение действий** (иногда допустимо для ясности).

DRY в больших Java-проектах проявляется на многих уровнях: общие утилиты, базовые классы, константы (вынесенные в `constants`), единые слои доступа к данным (репозитории), общие DTO, общие исключения, единая библиотека валидации, shared modules в многомодульном maven/gradle проекте. Инструменты для поддержки DRY: модульность (maven/gradle), общие библиотеки, internal SDK, шаблоны кода (archetype), code generation (если абстракцию сложно поддерживать вручную), а также отказ от копипаста через code reviews и линтеры.

**Подводные камни и тонкости:**
- **Premature abstraction (преждевременная абстракция):** вынесение слишком ранних абстракций для устранения копипаста может создать «чужую» абстракцию, которую сложнее понять и изменить.  
- **Wrong shared abstraction:** если вы вынесли логику, но она вынуждает разные участки кода подстраиваться под неё, может появиться высокое coupling.  
- **Over-DRY:** превращение проекта в монолитную утилиту с большим количеством configuration flags, чтобы угодить всем, часто ухудшает читаемость.  
- **Тесты и DRY:** дублирование тестовых данных иногда полезно — test duplication ≠ production duplication; тесты должны быть читаемы и независимы.

---

## DRY — Плохой пример (нарушение DRY)

```java
// Пример нарушения DRY: в двух сервисах повторяется одна и та же логика валидации.
// Копипаст делает поддержку рискованной — если правило проверки изменится, придётся править оба места.

public class UserService {
    // Метод регистрации пользователя — содержит встроенную валидацию
    public void registerUser(String username, String email) {
        // Валидация: имя не пустое и длина >= 3
        if (username == null || username.trim().isEmpty() || username.length() < 3) {
            throw new IllegalArgumentException("username must be at least 3 chars");
        }
        // Валидация: простая проверка e-mail
        if (email == null || !email.contains("@")) {
            throw new IllegalArgumentException("invalid email");
        }
        // далее логика сохранения
        // ...
    }
}

public class AdminService {
    // Почти та же самая валидация, скопированная из UserService
    public void createAdmin(String username, String email) {
        // КОПИРАЙТЕ-КОПИРАЙТЕ — дублирование
        if (username == null || username.trim().isEmpty() || username.length() < 3) {
            throw new IllegalArgumentException("username must be at least 3 chars");
        }
        if (email == null || !email.contains("@")) {
            throw new IllegalArgumentException("invalid email");
        }
        // логика создания администратора
        // ...
    }
}
```

Комментарии: здесь мы видим дублирование правил валидации в двух разных классах. Если правило изменится (например, минимальная длина станет 5 или валидация email усложнится), небрежный разработчик может обновить только один сервис — баги гарантированы.

---

## DRY — Хороший пример (соблюдение DRY)

```java
// Правильный пример: вынесли валидацию в отдельный класс-валидатор и переиспользуем.
// Благодаря этому правило централизовано и легко тестируемо.

public class UserValidator {
    // Метод валидирует username и email по единому контракту.
    public void validateUsernameAndEmail(String username, String email) {
        // Проверяем username
        if (username == null || username.trim().isEmpty() || username.length() < 3) {
            throw new IllegalArgumentException("username must be at least 3 chars");
        }
        // Проверяем email (базовая проверка)
        if (email == null || !email.contains("@")) {
            throw new IllegalArgumentException("invalid email");
        }
    }
}

// Сервис для пользователей — использует общий валидатор
public class UserService2 {
    private final UserValidator validator;

    // Внедряем валидатор (DI) — удобно для тестов
    public UserService2(UserValidator validator) {
        this.validator = validator;
    }

    public void registerUser(String username, String email) {
        // Делегируем валидацию общему компоненту
        validator.validateUsernameAndEmail(username, email);
        // Сохранение, логирование и т.д.
    }
}

// Сервис для админов — тот же валидатор переиспользуется
public class AdminService2 {
    private final UserValidator validator;

    public AdminService2(UserValidator validator) {
        this.validator = validator;
    }

    public void createAdmin(String username, String email) {
        // Делегируем ту же валидацию — одна точка правки
        validator.validateUsernameAndEmail(username, email);
        // Специфичная логика для админов
    }
}
```

Комментарии: теперь правило валидации централизовано. Тесты покрывают `UserValidator` один раз, и при изменении правила довольно безопасно обновлять одно место.

---

# 2) KISS — Keep It Simple, Stupid (или Keep It Short & Simple)

**Кратко:** проектируй простые и понятные решения. Сложность — основной источник ошибок. Предпочти понятный код «красивому» и многослойному, если сложность не обоснована.

**Развёрнутое объяснение (несколько больших абзацев):**  
KISS — призыв к простоте: ясные интерфейсы, понятные названия, маленькие методы, отсутствие ненужных уровней абстракции. Простая реализация легче читать, сопровождать и тестировать. KISS не значит «нынешний хак — хороший», он уравновешивает необходимость простоты и долгосрочной поддержки: код должен быть простым **и** правильным, а не просто кратким.

Сложность исчисляется по-разному: cyclomatic complexity (ветвления), number of moving parts (модули/флаги), глубина наследования, количество конфигурационных опций, непонятные именования, отвлечённые паттерны. KISS рекомендует разбивать проблему на простые подзадачи, избегать избыточных паттернов (например, сложная фабрика для простых объектов), избегать «умных» трюков ради краткости (магические one-liners, глубокие лямбда-цепочки без комментариев).

В Java KISS выглядит как: понятные классы с одной ответственностью, простые POJO/DTO, минимальная и понятная конфигурация Spring, использование стандартных коллекций, избегание чрезмерного обобщения (универсальные утилиты, которые пытаются покрыть всё), предпочтение композиции над сложным наследованием. KISS особенно важен для высокого уровня — API, публичных контрактов, микросервисных границ: если ваш API сложен, клиенты будут делать ошибки.

**Подводные камни и тонкости:**
- **Простота ≠ примитивность:** иногда простое выглядит как трюк. Нужно объяснить почему выбран именно такой, а не более «правильный, но сложный» вариант.  
- **KISS vs DRY:** иногда устранение дублирования (DRY) приводит к сложной абстракции, что нарушает KISS. Нужно балансировать: лучше иметь небольшое дублирование, чем запутанную универсальную реализацию.  
- **YAGNI (You Aren’t Gonna Need It):** KISS близок к YAGNI — не добавляйте фичи/абстракции «на будущее». Но будьте осторожны: иногда знание о возможных расширениях (OCP) оправдывает лёгкую абстракцию.  
- **Документация и KISS:** простой код всё-таки требует документации: почему архитектура такова, где границы, почему не применили фабрики и т. п.

---

## KISS — Плохой пример (нарушение KISS)

```java
// Пример сложности: один метод делает кучу задач, использует вложенные if/else, много побочных эффектов.
// Такой код тяжело читать, поддерживать и тестировать.

public class ComplexProcessor {

    // Метод обрабатывает заказ: валидация, расчёт, логирование, сохранение, внешние вызовы
    public void processOrder(Order order, boolean calculateTax, boolean notifyUser, int priorityLevel) {
        // Слишком много логики в одном методе — KISS нарушен.

        // Валидация (множество условий)
        if (order == null) {
            throw new IllegalArgumentException("order is null");
        }
        if (order.getItems() == null || order.getItems().isEmpty()) {
            throw new IllegalArgumentException("no items");
        }

        // Сложные вложенные правила расчёта
        double total = 0;
        for (OrderItem it : order.getItems()) {
            double price = it.getPrice();
            if (it.isDiscounted()) {
                // Неструктурированная логика расчёта скидки
                price = price * (1 - it.getDiscountRate());
            } else {
                // разные способы округления и CPA условия
                if (priorityLevel > 5) {
                    price = Math.round(price * 100.0) / 100.0;
                } else {
                    price = (double) Math.round(price);
                }
            }
            total += price * it.getQuantity();
        }

        // Несколько побочных эффектов: сохранение, логирование, внешняя отправка
        saveToDatabase(order, total);      // напрямую внутри метода
        if (notifyUser) {
            // внешний HTTP вызов прямо здесь
            callExternalNotificationService(order.getUserId(), "Your order processed");
        }

        if (calculateTax) {
            // налог вычисляем в теле — тут трудно подменить логику
            double tax = total * 0.2; // жестко прописанный налог
            updateOrderWithTax(order, tax);
        }
    }

    // Заглушки для иллюстрации
    private void saveToDatabase(Order order, double total) {}
    private void callExternalNotificationService(String userId, String message) {}
    private void updateOrderWithTax(Order order, double tax) {}
}
```

Комментарии: метод большой, делает всё подряд, содержит флаги (`calculateTax`, `notifyUser`) которые меняют поведение. Такие флаги делают тестирование комбинаторно сложным, увеличивают ветвление и вероятность ошибок.

---

## KISS — Хороший пример (соблюдение KISS)

```java
// Правильный пример: разбиваем сложную операцию на мелкие понятные методов/классы.
// Каждый класс/метод делает одну вещь — проще тестировать и понимать.
// Комментарии по-русски поясняют каждую строчку.

public class OrderProcessor { // класс-координатор: orchestrates процесс обработки

    private final OrderValidator validator;           // валидатор: отвечает только за валидацию
    private final PriceCalculator priceCalculator;    // калькулятор цен: расчёт итогов
    private final OrderRepository orderRepository;    // репозиторий: сохранение в БД
    private final NotificationService notificationService; // уведомления: внешний вызов
    private final TaxService taxService;              // налоговый сервис: вычисление и правило налога

    // Конструктор — зависимости внедряются (удобно для тестов)
    public OrderProcessor(OrderValidator validator,
                          PriceCalculator priceCalculator,
                          OrderRepository orderRepository,
                          NotificationService notificationService,
                          TaxService taxService) {
        this.validator = validator;
        this.priceCalculator = priceCalculator;
        this.orderRepository = orderRepository;
        this.notificationService = notificationService;
        this.taxService = taxService;
    }

    // Публичный метод — короткий и читаемый: описывает высокоуровневую последовательность.
    public void process(Order order, boolean notifyUser) {
        // 1) Валидация — делегируем валидатору
        validator.validate(order);

        // 2) Расчёт итоговой цены — делегируем калькулятору
        double total = priceCalculator.calculateTotal(order);

        // 3) Сохранение — делегируем репозиторию
        orderRepository.save(order, total);

        // 4) Уведомление — делегируем отдельному сервису (и только если нужно)
        if (notifyUser) {
            notificationService.notifyUser(order.getUserId(), "Ваш заказ обработан");
        }

        // 5) Налог — делегируем отдельному сервису, чтобы логику можно было менять независимо
        double tax = taxService.calculateTax(total);
        orderRepository.updateTax(order, tax);
    }
}

// Примеры зависимостей — каждая отвечает за одну область
class OrderValidator {
    public void validate(Order order) {
        if (order == null) throw new IllegalArgumentException("order is null");
        if (order.getItems() == null || order.getItems().isEmpty()) throw new IllegalArgumentException("no items");
    }
}

class PriceCalculator {
    public double calculateTotal(Order order) {
        double total = 0;
        for (OrderItem it : order.getItems()) {
            double price = it.getPrice();
            // вынесенные отдельные правила обработки скидок и округления
            if (it.isDiscounted()) {
                price = applyDiscount(price, it.getDiscountRate());
            }
            price = applyRounding(price, it);
            total += price * it.getQuantity();
        }
        return total;
    }

    private double applyDiscount(double price, double rate) {
        return price * (1 - rate);
    }

    private double applyRounding(double price, OrderItem item) {
        // простой и ясный метод, легко тестируемый
        return Math.round(price * 100.0) / 100.0;
    }
}

interface OrderRepository {
    void save(Order order, double total);
    void updateTax(Order order, double tax);
}

interface NotificationService {
    void notifyUser(String userId, String message);
}

interface TaxService {
    double calculateTax(double total);
}
```

Комментарии: публичный метод `process` — краткий и читабельный. Логика разделена на отдельные компоненты, каждый из которых прост и тестируем. Такой подход соответствует KISS и облегчает поддержку.

---

# Где применяется в Java (DRY и KISS)

- **Модули и библиотеки:** вынос общих утилит/помощников в shared-модули (DRY), при этом каждый модуль должен быть простым и иметь ясную ответственность (KISS).
- **API и публичные интерфейсы:** делайте прозрачные и простые контрактные методы (KISS). Общую логику валидации/форматирования выносите в одну библиотеку или util-класс (DRY).
- **Тесты:** DRY применим в интеграционных тестах (shared test fixtures), но не злоупотребляйте — иногда явные повторяющиеся сцены тестов повышают читаемость. KISS — держите тесты короткими и прямыми.
- **Конфигурация:** централизованная конфигурация (DRY) через `application.yml`/`properties`. KISS — не делайте конфигурации чрезмерно параметризованной без нужды.
- **Архитектура микросервисов:** если бизнес-правило используется во многих сервисах, вынесите его в библиотеку или отдельный сервис (DRY). Но API и взаимодействия между сервисами должны быть простыми (KISS).
- **Кодогенерация и шаблоны:** иногда DRY достигают генерацией кода (например, OpenAPI -> Java client), но нужно следить за простотой генерируемых слоёв (KISS).

---

# Конфликт DRY ↔ KISS — как балансировать

- Если устранение дублирования приводит к **слишком общей, тяжело понимаемой абстракции**, предпочитайте небольшой дублирующийся фрагмент кода и сохраняйте ясность (KISS). Затем, когда появится реальная необходимость (два повторения — первый сигнал, но не приговор), рефакторьте в общую абстракцию.
- Делайте **рефакторинг шагами**: сначала выделите общие части, покройте тестами, затем вынесите абстракцию. Тесты — главный инструмент безопасности.
- Используйте **внутренние библиотеки** (shared modules) для истинного общего знания, но следите, чтобы они имели маленький и простой API (KISS).
- Обсуждайте архитектурные изменения с командой: иногда абстракция нужна для будущих расширений (OCP), но не всегда — решение должно быть обосновано.

---

# Тонкости и «подводные камни», которые стоит упомянуть на собеседовании

1. **Premature abstraction** — частая ошибка: люди вынуждают систему подстраиваться под абстракцию, а не наоборот. Покажите пример, как вы проверяете необходимость абстракции (сколько мест повторяется, есть ли тесты, ожидается ли несколько реализаций).  
2. **Тестируемость как аргумент за DRY:** единая логика упрощает создание unit-тестов; но иногда тесты лучше читаются с небольшим дублированием.  
3. **KISS и производительность:** упрощение кода не должно приносить значительную деградацию производительности в горячих путях. Всегда можно профилировать и оптимизировать локально.  
4. **API-совместимость:** при выносе общей логики в библиотеку учитывайте backward compatibility — изменяя общую библиотеку, вы можете сломать много клиентов. Здесь важны semantic versioning и CI.  
5. **Документирование абстракций:** когда вы выносите общую логику — документируйте контракт, ограничения и ожидаемое поведение (JavaDoc), чтобы избежать неправильного использования.  
6. **Семантические различия:** похожие, но не одинаковые случаи не следует объединять в одну абстракцию — это приводит к «пропускам» и багам.  
7. **Code reviews & linters:** внедряйте правила (код-ревью, статические анализаторы), которые выявляют копипаст и излишнюю сложность.  

---

# Как это говорить на собеседовании (ключевые тезисы)

- DRY: «Я ищу повторяющееся знание, а не только повторение строк. Если вижу копипаст — сначала добавляю тесты, затем выношу общую логику в компонент/библиотеку. Но я избегаю преждевременных абстракций.»  
- KISS: «Я предпочитаю понятные решения. Если требуемая функциональность проста — не усложняю архитектуру. Для критичных кейсов применяю простые шаблоны: маленькие методы, явные зависимости, избегаю флагов поведения.»  
- Баланс: «DRY и KISS — оба важны. Я предпочитаю маленькую проблему решить простым дублированием, но если дублирование растёт — рефакторю в чистую абстракцию и покрываю тестами.»  
- Примеры: расскажите из опыта: «Мы вынесли общий валидатор/код доступа в shared module и избежали рассинхронизации правил.» Или: «Я видел проект, где ради DRY сделали одну супер-утилиту с 50 параметрами — это убило читаемость; мы откатились и сделали 3 простые функции.»  

---

# Итог / резюме (шпаргалка для интервью)

- DRY = не дублируй знание: вынеси правила/константы/функции в одно место; используй shared modules. Но не абстрагируй преждевременно.  
- KISS = держи всё простым и понятным: маленькие методы, явные зависимости, избегание флагов поведения и глубокой вложенности.  
- Баланс — критичен: иногда небольшое дублирование лучше, чем сложная абстракция; но если повторение растёт — рефакторь.  
- Практические техники: dependency injection, модульность (maven/gradle), code reviews, unit tests, небольшие классы и интерфейсы, документирование абстракций.

---




