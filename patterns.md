[Вопросы для собеседования](README.md)

# Шаблоны проектирования
+ [Что такое _«шаблон проектирования»_?](#Что-такое-шаблон-проектирования)
+ [Назовите основные характеристики шаблонов.](#Назовите-основные-характеристики-шаблонов)
+ [Типы шаблонов проектирования.](#Типы-шаблонов-проектирования)
+ [Приведите примеры основных шаблонов проектирования.](#Приведите-примеры-основных-шаблонов-проектирования)
+ [Приведите примеры порождающих шаблонов проектирования.](#Приведите-примеры-порождающих-шаблонов-проектирования)
+ [Приведите примеры структурных шаблонов проектирования.](#Приведите-примеры-структурных-шаблонов-проектирования)
+ [Приведите примеры поведенческих шаблонов проектирования.](#Приведите-примеры-поведенческих-шаблонов-проектирования)
+ [Что такое _«антипаттерн»_? Какие антипаттерны вы знаете?](#Что-такое-антипаттерн-Какие-антипаттерны-вы-знаете)
+ [Что такое _Dependency Injection_?](#Что-такое-dependency-injection)

## Что такое _«шаблон проектирования»_?
__Шаблон (паттерн) проектирования (design pattern)__ — это проверенное и готовое к использованию решение. Это не класс и не библиотека, которую можно подключить к проекту, это нечто большее - он не зависит от языка программирования, не является законченным образцом, который может быть прямо преобразован в код и может быть реализован по-разному в разных языках программирования.

Плюсы использования шаблонов:
+ снижение сложности разработки за счёт готовых абстракций для решения целого класса проблем.
+ облегчение коммуникации между разработчиками, позволяя ссылаться на известные шаблоны.
+ унификация деталей решений: модулей и элементов проекта.
+ возможность отыскав удачное решение, пользоваться им снова и снова.
+ помощь в выборе выбрать наиболее подходящего варианта проектирования.

Минусы:
+ слепое следование некоторому выбранному шаблону может привести к усложнению программы.
+ желание попробовать некоторый шаблон в деле без особых на то оснований.

[к оглавлению](#Шаблоны-проектирования)

## Назовите основные характеристики шаблонов.
+ __Имя__ - все шаблоны имеют уникальное имя, служащее для их идентификации;
+ __Назначение__	назначение данного шаблона;
+ __Задача__ - задача, которую шаблон позволяет решить;
+ __Способ решения__ - способ, предлагаемый в шаблоне для решения задачи в том контексте, где этот шаблон был найден;
+ __Участники__	- сущности, принимающие участие в решении задачи;
+ __Следствия__	- последствия от использования шаблона как результат действий, выполняемых в шаблоне;
+ __Реализация__ - возможный вариант реализации шаблона.

[к оглавлению](#Шаблоны-проектирования)

## Типы шаблонов проектирования.
+ Основные (Fundamental) - основные строительные блоки других шаблонов. Большинство других шаблонов использует эти шаблоны в той или иной форме.
+ Порождающие шаблоны (Creational) — шаблоны проектирования, которые абстрагируют процесс создание экземпляра. Они позволяют сделать систему независимой от способа создания, композиции и представления объектов. Шаблон, порождающий классы, использует наследование, чтобы изменять созданный объект, а шаблон, порождающий объекты, делегирует создание объектов другому объекту.
+ Структурные шаблоны (Structural) определяют различные сложные структуры, которые изменяют интерфейс уже существующих объектов или его реализацию, позволяя облегчить разработку и оптимизировать программу.
+ Поведенческие шаблоны (Behavioral) определяют взаимодействие между объектами, увеличивая таким образом его гибкость.

[к оглавлению](#Шаблоны-проектирования)

## Приведите примеры основных шаблонов проектирования.
+ __Делегирование (Delegation pattern)__ - Сущность внешне выражает некоторое поведение, но в реальности передаёт ответственность за выполнение этого поведения связанному объекту.
+ __Функциональный дизайн (Functional design)__ - Гарантирует, что каждая сущность имеет только одну обязанность и исполняет её с минимумом побочных эффектов на другие.
+ __Неизменяемый интерфейс (Immutable interface)__ - Создание неизменяемого объекта.
+ __Интерфейс (Interface)__ - Общий метод структурирования сущностей, облегчающий их понимание. 
+ __Интерфейс-маркер (Marker interface)__ - В качестве атрибута (как пометки объектной сущности) применяется наличие или отсутствие реализации интерфейса-маркера. В современных языках программирования вместо этого применяются атрибуты или аннотации.
+ __Контейнер свойств (Property container)__ - Позволяет добавлять дополнительные свойства сущности в контейнер внутри себя, вместо расширения новыми свойствами.
+ __Канал событий (Event channel)__ - Создаёт централизованный канал для событий. Использует сущность-представитель для подписки и сущность-представитель для публикации события в канале. Представитель существует отдельно от реального издателя или подписчика. Подписчик может получать опубликованные события от более чем одной сущности, даже если он зарегистрирован только на одном канале.

[к оглавлению](#Шаблоны-проектирования)

## Приведите примеры порождающих шаблонов проектирования.
+ __Абстрактная фабрика (Abstract factory)__ - Класс, который представляет собой интерфейс для создания других классов.
+ __Строитель (Builder)__ - Класс, который представляет собой интерфейс для создания сложного объекта.
+ __Фабричный метод (Factory method)__ - Делегирует создание объектов наследникам родительского класса. Это позволяет использовать в коде программы не специфические классы, а манипулировать абстрактными объектами на более высоком уровне.
+ __Прототип (Prototype)__ - Определяет интерфейс создания объекта через клонирование другого объекта вместо создания через конструктор.
+ __Одиночка (Singleton)__ - Класс, который может иметь только один экземпляр.

[к оглавлению](#Шаблоны-проектирования)

## Приведите примеры структурных шаблонов проектирования.
+ __Адаптер (Adapter)__ - Объект, обеспечивающий взаимодействие двух других объектов, один из которых использует, а другой предоставляет несовместимый с первым интерфейс. 
+ __Мост (Bridge)__ - Структура, позволяющая изменять интерфейс обращения и интерфейс реализации класса независимо. 
+ __Компоновщик (Composite)__ - Объект, который объединяет в себе объекты, подобные ему самому. 
+ __Декоратор (Decorator)__ - Класс, расширяющий функциональность другого класса без использования наследования. 
+ __Фасад (Facade)__ - Объект, который абстрагирует работу с несколькими классами, объединяя их в единое целое. 
+ __Приспособленец (Flyweight)__ - Это объект, представляющий себя как уникальный экземпляр в разных местах программы, но по факту не являющийся таковым. 
+ __Заместитель (Proxy)__ - Объект, который является посредником между двумя другими объектами, и который реализует/ограничивает доступ к объекту, к которому обращаются через него.

[к оглавлению](#Шаблоны-проектирования)

## Приведите примеры поведенческих шаблонов проектирования.
+ __Цепочка обязанностей (Chain of responsibility)__ - Предназначен для организации в системе уровней ответственности.
+ __Команда (Command)__ - Представляет действие. Объект команды заключает в себе само действие и его параметры.
+ __Интерпретатор (Interpreter)__ - Решает часто встречающуюся, но подверженную изменениям, задачу.
+ __Итератор (Iterator)__ - Представляет собой объект, позволяющий получить последовательный доступ к элементам объекта-агрегата без использования описаний каждого + __из объектов, входящих в состав агрегации.
+ __Посредник (Mediator)__ - Обеспечивает взаимодействие множества объектов, формируя при этом слабую связанность и избавляя объекты от необходимости явно ссылаться друг на друга.
+ __Хранитель (Memento)__ - Позволяет, не нарушая инкапсуляцию зафиксировать и сохранить внутренние состояния объекта так, чтобы позднее восстановить его в этих состояниях.
+ __Наблюдатель (Observer)__ - Определяет зависимость типа «один ко многим» между объектами таким образом, что при изменении состояния одного объекта все зависящие от него оповещаются об этом событии.
+ __Состояние (State)__ - Используется в тех случаях, когда во время выполнения программы объект должен менять своё поведение в зависимости от своего состояния.
+ __Стратегия (Strategy)__ - Предназначен для определения семейства алгоритмов, инкапсуляции каждого из них и обеспечения их взаимозаменяемости.
+ __Шаблонный метод (Template method)__ - Определяет основу алгоритма и позволяет наследникам переопределять некоторые шаги алгоритма, не изменяя его структуру в целом.
+ __Посетитель (Visitor)__ - Описывает операцию, которая выполняется над объектами других классов. При изменении класса Visitor нет необходимости изменять обслуживаемые классы.

[к оглавлению](#Шаблоны-проектирования)

## Что такое _«антипаттерн»_? Какие антипаттерны вы знаете?
__Антипаттерн (anti-pattern)__ — это распространённый подход к решению класса часто встречающихся проблем, являющийся неэффективным, рискованным или непродуктивным.

__Poltergeists (полтергейсты)__ - это классы с ограниченной ответственностью и ролью в системе, чьё единственное предназначение — передавать информацию в другие классы. Их эффективный жизненный цикл непродолжителен. Полтергейсты нарушают стройность архитектуры программного обеспечения, создавая избыточные (лишние) абстракции, они чрезмерно запутанны, сложны для понимания и трудны в сопровождении. Обычно такие классы задумываются как классы-контроллеры, которые существуют только для вызова методов других классов, зачастую в предопределенной последовательности.

Признаки появления и последствия антипаттерна
+ Избыточные межклассовые связи.
+ Временные ассоциации.
+ Классы без состояния (содержащие только методы и константы).
+ Временные объекты и классы (с непродолжительным временем жизни).
+ Классы с единственным методом, который предназначен только для создания или вызова других классов посредством временной ассоциации.
+ Классы с именами методов в стиле «управления», такие как startProcess.

Типичные причины
+ Отсутствие объектно-ориентированной архитектуры (архитектор не понимает объектно-ориентированной парадигмы).
+ Неправильный выбор пути решения задачи.
+ Предположения об архитектуре приложения на этапе анализа требований (до объектно-ориентированного анализа) могут также вести к проблемам на подобии этого антипаттерна.

__Внесенная сложность (Introduced complexity)__: Необязательная сложность дизайна. Вместо одного простого класса выстраивается целая иерархия интерфейсов и классов. Типичный пример «Интерфейс - Абстрактный класс - Единственный класс реализующий интерфейс на основе абстрактного».

__Инверсия абстракции (Abstraction inversion)__: Сокрытие части функциональности от внешнего использования, в надежде на то, что никто не будет его использовать.

__Неопределённая точка зрения (Ambiguous viewpoint)__: Представление модели без спецификации её точки рассмотрения.

__Большой комок грязи (Big ball of mud)__: Система с нераспознаваемой структурой.

__Божественный объект (God object)__: Концентрация слишком большого количества функций в одной части системы (классе).

__Затычка на ввод данных (Input kludge)__: Забывчивость в спецификации и выполнении поддержки возможного неверного ввода.

__Раздувание интерфейса (Interface bloat)__: Разработка интерфейса очень мощным и очень сложным для реализации.

__Волшебная кнопка (Magic pushbutton)__: Выполнение результатов действий пользователя в виде неподходящего (недостаточно абстрактного) интерфейса. Например, написание прикладной логики в обработчиках нажатий на кнопку.

__Перестыковка (Re-Coupling)__: Процесс внедрения ненужной зависимости.

__Дымоход (Stovepipe System)__: Редко поддерживаемая сборка плохо связанных компонентов.

__Состояние гонки (Race hazard)__: непредвидение возможности наступления событий в порядке, отличном от ожидаемого.

__Членовредительство (Mutilation)__: Излишнее «затачивание» объекта под определенную очень узкую задачу таким образом, что он не способен будет работать с никакими иными, пусть и очень схожими задачами.

__Сохранение или смерть (Save or die)__: Сохранение изменений лишь при завершении приложения.

[к оглавлению](#Шаблоны-проектирования)

## Что такое _Dependency Injection_?
__Dependency Injection (внедрение зависимости)__ - это набор паттернов и принципов разработки програмного обеспечения, которые позволяют писать слабосвязный код. В полном соответствии с принципом единой обязанности объект отдаёт заботу о построении требуемых ему зависимостей внешнему, специально предназначенному для этого общему механизму.

[к оглавлению](#Шаблоны-проектирования)
# Введение — что такое **порождающие (creational)** паттерны
Порождающие паттерны проектирования решают, **как правильно создавать объекты**. Они помогают отделить логику создания от использования, делают код гибче, проще для тестирования и расширения. На собеседовании от вас ожидают не только определения, но и понимание **когда** и **почему** применять каждый паттерн, плюсы/минусы и практические примеры.

Ниже — подробные объяснения (простым языком), реальные сценарии и готовые Java-примеры с подробными комментариями на русском. После каждого блока — полностью рабочий пример в одном файле (один public класс + вспомогательные), чтобы вы могли скопировать и вставить в IDE.

---
# Абстрактная фабрика (Abstract Factory)

Абстрактная фабрика — это порождающий паттерн проектирования, который позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам. Основная идея паттерна заключается в том, чтобы клиентский код мог работать с наборами продуктов, которые логически связаны между собой, через общие интерфейсы. Таким образом, можно легко изменять семейства продуктов (например, мебель разных стилей или элементы UI для разных ОС), не меняя сам клиентский код.

Паттерн особенно полезен в ситуациях, когда необходимо обеспечить совместимость создаваемых объектов. Например, нельзя допустить, чтобы программа создавала кнопку в стиле Windows и чекбокс в стиле macOS в одном интерфейсе. Поэтому фабрика всегда возвращает продукты одной и той же вариации.

# Структура

Структура паттерна состоит из:

* **Абстрактных продуктов** (например, `Button`, `Checkbox`), которые определяют общий интерфейс для всех вариаций.
* **Конкретных продуктов** (`WinButton`, `MacButton`, и т. д.), которые реализуют эти интерфейсы.
* **Абстрактной фабрики** (`GUIFactory`), объявляющей методы для создания продуктов.
* **Конкретных фабрик** (`WinFactory`, `MacFactory`), которые создают продукты конкретных вариаций.
* **Клиентского кода** (`Application`), который работает только с интерфейсами и не зависит от конкретных реализаций.

# Пример на Java

```java
// Этот паттерн предполагает, что у вас есть несколько семейств
// продуктов, находящихся в отдельных иерархиях классов
// (Button/Checkbox). Продукты одного семейства должны иметь
// общий интерфейс.
interface Button {
    void paint();
}

// Семейства продуктов имеют те же вариации (macOS/Windows).
class WinButton implements Button {
    @Override
    public void paint() {
        // Отрисовать кнопку в стиле Windows.
        System.out.println("Rendering a Windows style button.");
    }
}

class MacButton implements Button {
    @Override
    public void paint() {
        // Отрисовать кнопку в стиле macOS.
        System.out.println("Rendering a MacOS style button.");
    }
}

interface Checkbox {
    void paint();
}

class WinCheckbox implements Checkbox {
    @Override
    public void paint() {
        // Отрисовать чекбокс в стиле Windows.
        System.out.println("Rendering a Windows style checkbox.");
    }
}

class MacCheckbox implements Checkbox {
    @Override
    public void paint() {
        // Отрисовать чекбокс в стиле macOS.
        System.out.println("Rendering a MacOS style checkbox.");
    }
}

// Абстрактная фабрика знает обо всех абстрактных типах продуктов.
interface GUIFactory {
    Button createButton();
    Checkbox createCheckbox();
}

// Каждая конкретная фабрика знает и создаёт только продукты своей вариации.
class WinFactory implements GUIFactory {
    @Override
    public Button createButton() {
        return new WinButton();
    }

    @Override
    public Checkbox createCheckbox() {
        return new WinCheckbox();
    }
}

class MacFactory implements GUIFactory {
    @Override
    public Button createButton() {
        return new MacButton();
    }

    @Override
    public Checkbox createCheckbox() {
        return new MacCheckbox();
    }
}

// Для кода, использующего фабрику, не важно, с какой конкретно фабрикой он работает.
// Все получатели продуктов работают с ними через общие интерфейсы.
class Application {
    private GUIFactory factory;
    private Button button;

    public Application(GUIFactory factory) {
        this.factory = factory;
    }

    public void createUI() {
        this.button = factory.createButton();
    }

    public void paint() {
        button.paint();
    }
}

// Приложение выбирает тип конкретной фабрики и создаёт её
// динамически, исходя из конфигурации или окружения.
class ApplicationConfigurator {
    public static void main(String[] args) {
        String configOS = "Windows"; // имитация чтения из конфигурации

        GUIFactory factory;
        if (configOS.equals("Windows")) {
            factory = new WinFactory();
        } else if (configOS.equals("Mac")) {
            factory = new MacFactory();
        } else {
            throw new RuntimeException("Error! Unknown operating system.");
        }

        Application app = new Application(factory);
        app.createUI();
        app.paint();
    }
}
```

## Преимущества и недостатки

**Преимущества:**

* Гарантирует сочетаемость создаваемых продуктов.
* Избавляет клиентский код от привязки к конкретным классам.
* Выделяет код производства продуктов в одно место, упрощая поддержку.
* Упрощает добавление новых продуктов.
* Реализует принцип открытости/закрытости.

**Недостатки:**

* Усложняет код из-за введения множества дополнительных классов.
* Требует наличия всех типов продуктов в каждой вариации.

## Строитель
Строитель — это порождающий паттерн проектирования, который позволяет создавать сложные объекты пошагово. Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов.
Паттерн предлагает разбить процесс конструирования объекта на отдельные шаги (например, построитьСтены, вставитьДвери и другие). Чтобы создать объект, вам нужно поочерёдно вызывать методы строителя. Причём не нужно запускать все шаги, а только те, что нужны для производства объекта определённой конфигурации.
Например, один строитель делает стены из дерева и стекла, другой из камня и железа, третий из золота и бриллиантов. Вызвав одни и те же шаги строительства, в первом случае вы получите обычный жилой дом, во втором — маленькую крепость, а в третьем — роскошное жилище. Замечу, что код, который вызывает шаги строительства, должен работать со строителями через общий интерфейс, чтобы их можно было свободно взаимозаменять.

## Фабричный метод
Фабричный метод — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.
Представьте, что вы создаёте программу управления грузовыми перевозками. Сперва вы рассчитываете перевозить товары только на автомобилях. Поэтому весь ваш код работает с объектами класса Грузовик.

В какой-то момент ваша программа становится настолько известной, что морские перевозчики выстраиваются в очередь и просят добавить поддержку морской логистики в программу. 
Отличные новости, правда?! Но как насчёт кода? Большая часть существующего кода жёстко привязана к классам Грузовиков. Чтобы добавить в программу классы морских Судов, понадобится перелопатить всю программу. Более того, если вы потом решите добавить в программу ещё один вид транспорта, то всю эту работу придётся повторить.

В итоге вы получите ужасающий код, наполненный условными операторами, которые выполняют то или иное действие, в зависимости от класса транспорта.

 Решение
Паттерн Фабричный метод предлагает создавать объекты не напрямую, используя оператор new, а через вызов особого фабричного метода. Не пугайтесь, объекты всё равно будут создаваться при помощи new, но делать это будет фабричный метод. На первый взгляд, это может показаться бессмысленным: мы просто переместили вызов конструктора из одного конца программы в другой. Но теперь вы сможете переопределить фабричный метод в подклассе, чтобы изменить тип создаваемого продукта.

Чтобы эта система заработала, все возвращаемые объекты должны иметь общий интерфейс. Подклассы смогут производить объекты различных классов, следующих одному и тому же интерфейсу.

# Пример

```java
// Паттерн Фабричный метод применим тогда, когда в программе
// есть иерархия классов продуктов.
interface Button {
    void render();
    void onClick(String f);
}

class WindowsButton implements Button {
    @Override
    public void render() {
        // Отрисовать кнопку в стиле Windows.
    }

    @Override
    public void onClick(String f) {
        // Навесить на кнопку обработчик событий Windows.
    }
}

class HTMLButton implements Button {
    @Override
    public void render() {
        // Вернуть HTML-код кнопки.
    }

    @Override
    public void onClick(String f) {
        // Навесить на кнопку обработчик события браузера.
    }
}

// Базовый класс фабрики. Заметьте, что «фабрика» — это всего
// лишь дополнительная роль для класса. Скорее всего, он уже
// имеет какую-то бизнес-логику, в которой требуется создание
// разнообразных продуктов.
abstract class Dialog {
    public void render() {
        // Чтобы использовать фабричный метод, вы должны
        // убедиться в том, что эта бизнес-логика не зависит от
        // конкретных классов продуктов. Button — это общий
        // интерфейс кнопок, поэтому все хорошо.
        Button okButton = createButton();
        okButton.onClick("closeDialog");
        okButton.render();
    }

    // Мы выносим весь код создания продуктов в особый метод,
    // который называют «фабричным».
    public abstract Button createButton();
}

// Конкретные фабрики переопределяют фабричный метод и
// возвращают из него собственные продукты.
class WindowsDialog extends Dialog {
    @Override
    public Button createButton() {
        return new WindowsButton();
    }
}

class WebDialog extends Dialog {
    @Override
    public Button createButton() {
        return new HTMLButton();
    }
}

class Application {
    private Dialog dialog;

    // Приложение создаёт определённую фабрику в зависимости от
    // конфигурации или окружения.
    public void initialize() {
        String config = "Windows"; // имитация чтения конфигурации

        if (config.equals("Windows")) {
            dialog = new WindowsDialog();
        } else if (config.equals("Web")) {
            dialog = new WebDialog();
        } else {
            throw new RuntimeException("Error! Unknown operating system.");
        }
    }

    // Если весь остальной клиентский код работает с фабриками и
    // продуктами только через общий интерфейс, то для него
    // будет не важно, какая фабрика была создана изначально.
    public void main() {
        this.initialize();
        dialog.render();
    }
}
```


# Применимость

* Когда заранее неизвестны типы и зависимости объектов, с которыми должен работать ваш код.
* Когда вы хотите отделить код производства продуктов от остального кода, который эти продукты использует.
* Когда вы хотите дать возможность пользователям расширять части вашего фреймворка или библиотеки.

# Преимущества

* Избавляет код от привязки к конкретным классам продуктов.
* Упрощает расширение кода, позволяя добавлять новые продукты без изменения существующего.
* Реализует принцип открытости/закрытости.

# Недостатки

* Может привести к появлению большого количества дополнительных классов.
* Усложняет код из-за необходимости создания иерархии фабрик.

## Адаптер (Adapter)

Адаптер — это структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе. Его основная идея заключается в том, чтобы создать промежуточный объект — адаптер, который преобразует интерфейс одного объекта в интерфейс, ожидаемый другим.

# Проблема

Представьте, что вы пишете приложение для торговли на бирже. Оно получает котировки в формате **XML** и строит графики. Но в какой-то момент вы решаете использовать стороннюю библиотеку аналитики, которая принимает данные только в формате **JSON**. Переписывать библиотеку под XML невозможно, и доступ к её исходникам у вас отсутствует.

Чтобы решить эту проблему, мы используем адаптер. Он оборачивает существующий объект и переводит его данные или вызовы в совместимый формат. Клиентский код при этом не узнаёт, что внутри используется несоответствующий сервис.

# Решение

Адаптер выступает «переводчиком» между несовместимыми интерфейсами. Он реализует интерфейс клиента, а внутри использует сервисный объект, трансформируя данные и вызовы так, чтобы они были совместимы. Таким образом, клиентский код работает с адаптером так, словно это обычный объект.

Существует два варианта адаптера:

* **Адаптер объектов** — реализует интерфейс клиента и содержит ссылку на сервис (агрегация).
* **Адаптер классов** — наследует как интерфейс клиента, так и сервис (возможен только в языках с поддержкой множественного наследования, например, C++).

# Пример на псевдокоде

```java
// Классы с совместимыми интерфейсами: КруглоеОтверстие и КруглыйКолышек.
class RoundHole {
    private double radius;

    public RoundHole(double radius) {
        this.radius = radius;
    }

    public double getRadius() {
        // Вернуть радиус отверстия.
        return radius;
    }

    public boolean fits(RoundPeg peg) {
        // Проверить, помещается ли колышек в отверстие.
        return this.getRadius() >= peg.getRadius();
    }
}

class RoundPeg {
    private double radius;

    public RoundPeg(double radius) {
        this.radius = radius;
    }

    public double getRadius() {
        // Вернуть радиус круглого колышка.
        return radius;
    }
}

// Устаревший, несовместимый класс: КвадратныйКолышек.
class SquarePeg {
    private double width;

    public SquarePeg(double width) {
        this.width = width;
    }

    public double getWidth() {
        // Вернуть ширину квадратного колышка.
        return width;
    }
}

// Адаптер позволяет использовать квадратные колышки и круглые отверстия вместе.
class SquarePegAdapter extends RoundPeg {
    private SquarePeg peg;

    public SquarePegAdapter(SquarePeg peg) {
        super(0);
        this.peg = peg;
    }

    @Override
    public double getRadius() {
        // Вычислить половину диагонали квадратного колышка по теореме Пифагора.
        return peg.getWidth() * Math.sqrt(2) / 2;
    }
}

// Где-то в клиентском коде.
RoundHole hole = new RoundHole(5);
RoundPeg rpeg = new RoundPeg(5);
hole.fits(rpeg); // TRUE

SquarePeg smallSqpeg = new SquarePeg(5);
SquarePeg largeSqpeg = new SquarePeg(10);
// hole.fits(smallSqpeg); // Ошибка компиляции, несовместимые типы

SquarePegAdapter smallSqpegAdapter = new SquarePegAdapter(smallSqpeg);
SquarePegAdapter largeSqpegAdapter = new SquarePegAdapter(largeSqpeg);
hole.fits(smallSqpegAdapter); // TRUE
hole.fits(largeSqpegAdapter); // FALSE
```

# Применимость

* Когда вы хотите использовать сторонний класс, но его интерфейс не соответствует остальному коду приложения.
* Когда нужно адаптировать существующие классы без изменения их кода.
* Когда необходимо использовать несколько подклассов, но в них отсутствует общая функциональность. Вместо дублирования можно вынести её в адаптер.

# Преимущества

* Изолирует и скрывает от клиента сложность преобразований интерфейсов.
* Позволяет использовать существующие классы без изменения их кода.
* Поддерживает принцип открытости/закрытости.
* Делает код более гибким при работе с внешними библиотеками.

# Недостатки

* Усложняет код из-за введения дополнительных классов.
* Может ухудшить читаемость, если адаптеров слишком много.
* Иногда снижает производительность из-за лишних преобразований.

##  Мост (Bridge)

Мост — это структурный паттерн проектирования, который разделяет один или несколько классов на две отдельные иерархии — **абстракцию** и **реализацию**, позволяя изменять их независимо друг от друга.

# Проблема

Представим, что у нас есть класс `Фигура` с подклассами `Круг` и `Квадрат`. Теперь мы хотим расширить иерархию по цветам, чтобы были «синие фигуры» и «красные фигуры». В итоге появятся комбинации: `СинийКруг`, `КрасныйКвадрат` и т.д. С ростом числа фигур и цветов количество подклассов будет расти в геометрической прогрессии.

Это неудобно и ведёт к раздуванию дерева классов.

# Решение

Паттерн **Мост** предлагает вынести одну из независимых плоскостей (например, Цвет) в отдельную иерархию и связать её с другой (Фигура) через композицию. Таким образом, класс Фигура будет содержать ссылку на объект Цвета. Это и есть «мост» между абстракцией и реализацией.

Теперь можно:

* Добавлять новые цвета без изменения классов фигур.
* Добавлять новые фигуры без изменения классов цветов.

# Абстракция и Реализация

Термины звучат академично, но всё просто:

* **Абстракция** — слой управления (например, GUI), который делегирует работу реализации.
* **Реализация** — низкоуровневый слой (например, API ОС).

Абстракции и реализации могут развиваться независимо. Например, можно развивать разные типы GUI и поддерживать разные API ОС. При этом классы не будут мешать друг другу.

# Защита от изменений

Когда код разделён на абстракции и реализации, проще вносить изменения. Мы можем добавлять новые ОС (реализации) или новые виды интерфейсов (абстракции), не трогая уже существующие классы.

# Структура

* **Абстракция** — управляющая логика, делегирует работу реализации.
* **Реализация** — общий интерфейс, который используют абстракции.
* **Конкретные реализации** — содержат платформозависимый код.
* **Расширенные абстракции** — варианты управляющей логики.
* **Клиент** работает только с абстракцией.

# Псевдокод

```java
// Класс пультов имеет ссылку на устройство, которым управляет.
// Методы этого класса делегируют работу методам связанного устройства.
class Remote {
    protected Device device;

    public Remote(Device device) {
        this.device = device;
    }

    public void togglePower() {
        if (device.isEnabled()) {
            device.disable();
        } else {
            device.enable();
        }
    }

    public void volumeDown() {
        device.setVolume(device.getVolume() - 10);
    }

    public void volumeUp() {
        device.setVolume(device.getVolume() + 10);
    }

    public void channelDown() {
        device.setChannel(device.getChannel() - 1);
    }

    public void channelUp() {
        device.setChannel(device.getChannel() + 1);
    }
}

// Вы можете расширять класс пультов, не трогая код устройств.
class AdvancedRemote extends Remote {
    public AdvancedRemote(Device device) {
        super(device);
    }

    public void mute() {
        device.setVolume(0);
    }
}

// Все устройства имеют общий интерфейс. Поэтому с ними может работать любой пульт.
interface Device {
    boolean isEnabled();
    void enable();
    void disable();
    int getVolume();
    void setVolume(int percent);
    int getChannel();
    void setChannel(int channel);
}

// Но каждое устройство имеет особую реализацию.
class Tv implements Device {
    private boolean on = false;
    private int volume = 30;
    private int channel = 1;

    public boolean isEnabled() { return on; }
    public void enable() { on = true; }
    public void disable() { on = false; }
    public int getVolume() { return volume; }
    public void setVolume(int percent) { volume = percent; }
    public int getChannel() { return channel; }
    public void setChannel(int channel) { this.channel = channel; }
}

class Radio implements Device {
    private boolean on = false;
    private int volume = 20;
    private int channel = 1;

    public boolean isEnabled() { return on; }
    public void enable() { on = true; }
    public void disable() { on = false; }
    public int getVolume() { return volume; }
    public void setVolume(int percent) { volume = percent; }
    public int getChannel() { return channel; }
    public void setChannel(int channel) { this.channel = channel; }
}

// Где-то в клиентском коде.
Tv tv = new Tv();
Remote remote = new Remote(tv);
remote.togglePower();

Radio radio = new Radio();
AdvancedRemote advancedRemote = new AdvancedRemote(radio);
advancedRemote.mute();
```

# Применимость

* Когда нужно разделить монолитный класс с несколькими реализациями.
* Когда класс нужно расширять в двух независимых направлениях.
* Когда реализацию нужно менять во время выполнения программы.

# Преимущества

* Уменьшает количество классов комбинаций.
* Позволяет изменять абстракцию и реализацию независимо.
* Упрощает поддержку и расширяемость.
* Поддерживает принцип единственной ответственности.

# Недостатки

* Усложняет структуру кода за счёт введения дополнительных классов.
* Увеличивает количество уровней абстракции, что может затруднить отладку.


## Паттерн «Декоратор» — кратко и с примером на Java

Ниже — сжатое и упорядоченное описание паттерна, его принципа работы, когда применять, плюсы/минусы, и **полный** пример на Java с подробными комментариями и демонстрацией сборки стека декораторов.

---

# Описание (основные моменты)
Декоратор (Decorator) — структурный паттерн, который позволяет динамически добавлять объектам новую функциональность, оборачивая их в «обёртки» (декораторы). Обёртки и оборачиваемые объекты имеют общий интерфейс, поэтому клиентский код работает с ними одинаково.

Ключевая идея: вместо роста числа подклассов для каждой комбинации поведения используем композицию — создаём набор независимых декораторов и комбинируем их во время выполнения.

---

# Принцип работы
1. Есть общий интерфейс (например, `Notifier` с методом `send(String message)`).
2. Конкретный компонент (`EmailNotifier`) реализует базовое поведение.
3. Базовый декоратор (`NotifierDecorator`) содержит ссылку на `Notifier` (wrappee) и делегирует вызовы этому объекту.
4. Конкретные декораторы расширяют поведение, выполняя дополнительную работу до или после делегирования.
5. Клиент во время настройки «заворачивает» базовый объект в нужные декораторы (можно в несколько), получая комбинированное поведение.

---

# Когда применять (Применимость)
- Нужно добавлять обязанности объектам на лету, не меняя клиентский код.
- Нельзя (или не хочется) расширять класс через наследование (например, класс помечен `final`).
- Требуется гибко комбинировать разные дополнительные поведения без комбинаторного взрыва подклассов.

---

# Плюсы
- Гибкость: добавлять и комбинировать поведение во время выполнения.
- Избегает большого числа подклассов (комбинаторный взрыв).
- Декораторы сосредоточены на одной дополнительной ответственности — лучше разделение обязанностей.
- Клиентский код не зависит от конкретных декораторов — использует общий интерфейс.

# Минусы
- Увеличивает число небольших классов/объектов.
- Сложнее отладка — стек декораторов может затруднить трассировку поведения.
- Нарушает простоту конструкции: нужно явно собирать (настраивать) стек декораторов.
- Если интерфейс слишком богат — обязанность поддерживать весь интерфейс в декораторах увеличивает шаблонный код.

---

# Пример: реализация библиотеки уведомлений (Java)

```java
import java.util.List;
import java.util.Arrays;

/**
 * Общий интерфейс компонента — все нотификаторы и декораторы
 * реализуют этот интерфейс.
 */
interface Notifier {
    /**
     * Отправить уведомление (в простом виде — строковое сообщение).
     * В реальной жизни сюда можно передавать более богатую модель.
     */
    void send(String message);
}

/**
 * Конкретный компонент — базовая реализация отправки по Email.
 * Эта реализация отвечает за простую логику отправки email.
 */
class EmailNotifier implements Notifier {
    private final List<String> recipients;

    public EmailNotifier(List<String> recipients) {
        this.recipients = recipients;
    }

    @Override
    public void send(String message) {
        // В реальной библиотеке здесь будет интеграция с SMTP/API.
        // Для примера — просто имитируем отправку.
        System.out.println("[Email] Отправка по Email следующим получателям: " + recipients);
        System.out.println("[Email] Тело сообщения: " + message);
    }
}

/**
 * Базовый декоратор. Хранит ссылку на обёрнутый компонент (wrappee)
 * и по умолчанию делегирует вызовы ему.
 *
 * Конкретные декораторы расширяют этот класс и добавляют своё поведение.
 */
abstract class NotifierDecorator implements Notifier {
    protected final Notifier wrappee;

    protected NotifierDecorator(Notifier wrappee) {
        this.wrappee = wrappee;
    }

    @Override
    public void send(String message) {
        // По умолчанию — делегируем обёрнутому объекту.
        wrappee.send(message);
    }
}

/**
 * Конкретный декоратор — отправка SMS.
 * Выполняет свою задачу, а затем (или до) делегирует дальнейшую работу.
 */
class SmsNotifierDecorator extends NotifierDecorator {
    private final List<String> phoneNumbers;

    public SmsNotifierDecorator(Notifier wrappee, List<String> phoneNumbers) {
        super(wrappee);
        this.phoneNumbers = phoneNumbers;
    }

    @Override
    public void send(String message) {
        // Дополнительное поведение: отправляем SMS
        sendSms(message);
        // Делегирование — дальше сообщение по прежнему обрабатывается wrappee
        super.send(message);
    }

    private void sendSms(String message) {
        // Заглушка: в реальности интеграция с SMS-шлюзом
        System.out.println("[SMS] Отправка SMS: " + phoneNumbers + " -> " + message);
    }
}

/**
 * Конкретный декоратор — отправка в Facebook (пример).
 */
class FacebookNotifierDecorator extends NotifierDecorator {
    private final String pageOrUserId;

    public FacebookNotifierDecorator(Notifier wrappee, String pageOrUserId) {
        super(wrappee);
        this.pageOrUserId = pageOrUserId;
    }

    @Override
    public void send(String message) {
        // Можно изменить формат сообщения для FB
        String fbMessage = formatForFacebook(message);
        sendFacebookPost(fbMessage);
        super.send(message);
    }

    private String formatForFacebook(String message) {
        return "[FB] " + message; // пример форматирования
    }

    private void sendFacebookPost(String message) {
        // Заглушка: в реальности вызов Facebook API
        System.out.println("[Facebook] Пост на страницу/пользователя " + pageOrUserId + ": " + message);
    }
}

/**
 * Конкретный декоратор — отправка в Slack.
 */
class SlackNotifierDecorator extends NotifierDecorator {
    private final String channel;

    public SlackNotifierDecorator(Notifier wrappee, String channel) {
        super(wrappee);
        this.channel = channel;
    }

    @Override
    public void send(String message) {
        // Можно отправлять в Slack до (или после) делегирования
        postToSlack(message);
        super.send(message);
    }

    private void postToSlack(String message) {
        // Заглушка: в реальности интеграция с Slack Webhook/API
        System.out.println("[Slack] Сообщение в канал " + channel + ": " + message);
    }
}

/**
 * Демонстрация использования: сборка стека декораторов и отправка.
 */
public class NotifierExample {
    public static void main(String[] args) {
        // Базовый компонент — Email
        Notifier email = new EmailNotifier(Arrays.asList("admin@example.com", "ops@example.com"));

        // Клиент может "обернуть" базовый компонент нужными декораторами.
        // Порядок: самый внешний декоратор — тот объект, с которым будет работать клиент.
        Notifier notifier = new SlackNotifierDecorator(
                                new FacebookNotifierDecorator(
                                    new SmsNotifierDecorator(
                                        email,
                                        Arrays.asList("+420777111222", "+420777333444")
                                    ),
                                    "companyPageOrId"
                                ),
                                "#alerts"
                             );

        // Теперь клиенту не важно, сколько декораторов внутри — интерфейс тот же.
        notifier.send("Критическая ошибка: переполнение памяти на сервере A1");

        // Пример другой конфигурации: только Email + SMS
        Notifier emailPlusSms = new SmsNotifierDecorator(email, Arrays.asList("+420777111222"));
        emailPlusSms.send("Информационное сообщение: задача выполнена успешно.");
    }
}
```

---

# Что делает код (коротко)
- `EmailNotifier` — базовая отправка по e-mail.
- `NotifierDecorator` — общий базовый декоратор, содержит `wrappee`.
- `SmsNotifierDecorator`, `FacebookNotifierDecorator`, `SlackNotifierDecorator` — добавляют свои каналы отправки и затем делегируют остальную работу внутреннему компоненту.
- В `main` показано, как собрать стек декораторов и получить комбинированное поведение (Slack → Facebook → SMS → Email). Клиент вызывает `send()` у внешнего объекта, а внутри последовательно выполняются все обёртки.

---

# Пару практических замечаний
- Декораторы могут модифицировать входящее сообщение (например, форматировать), могут фильтровать, изменять список адресатов, логировать или добавлять retry.
- Если нужен обратный контроль (например, узнать, какие декораторы применены) — можно добавить вспомогательные методы/маркерные интерфейсы или использовать композицию с явной конфигурацией.
- В реальных системах операции отправки обычно асинхронные; декоратор не отменяет необходимости проектировать обработку ошибок и повторных попыток.

---

## Паттерн «Фасад» — кратко и с примером на Java

Ниже — сжатое и упорядоченное описание паттерна «Фасад», его принципа работы, когда применять, плюсы/минусы, и **полный** пример на Java с подробными комментариями и демонстрацией использования фасада для упрощения сложной подсистемы.

---

# Описание (основные моменты)
Фасад (Facade) — структурный паттерн, который предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку. Фасад скрывает детали реализации подсистемы и даёт клиенту удобную упрощённую точку входа для выполнения типичных задач.

Ключевая идея: объединить взаимодействие с набором сложных классов в один (или несколько) фасадных классов, которые инкапсулируют порядок вызовов, конфигурацию объектов и трансформацию данных, необходимых для решения конкретной задачи.

---

# Принцип работы
1. Существует сложная подсистема, состоящая из множества взаимосвязанных классов (часто — сторонний фреймворк или набор библиотечных классов).
2. Клиенту не нужно знать все детали подсистемы и порядок обращений к ней.
3. Фасад предоставляет ограниченный (урезанный) интерфейс, реализующий наиболее востребованные операции поверх подсистемы (например, `convert(filename, format)`).
4. Внутри фасада находятся все необходимые шаги: инициализация, подбор компонентов, последовательные вызовы методов подсистемы и агрегация результатов.
5. Клиент взаимодействует с фасадом — это уменьшает связанность и упрощает код клиента. При замене подсистемы нужно менять только фасад.

---

# Когда применять (Применимость)
- Когда вам нужно представить простой или урезанный интерфейс к сложной подсистеме.
- Когда подсистема развилась и стала громоздкой: много мелких классов, которые неудобно настраивать напрямую.
- Когда нужно разделить подсистему на уровни и организовать точки входа на каждый уровень.
- Когда требуется уменьшить зависимость кода приложения от конкретной реализации внешней библиотеки — фасад скрывает реализацию за простым API.

---

# Плюсы
- Упрощает использование сложной подсистемы для клиента.
- Снижает связанность между клиентским кодом и подсистемой — проще менять подсистему (только фасад).
- Централизует конфигурацию и порядок вызовов, упрощая поддержку.
- Может предоставить более безопасный и понятный API, ограничив доступ к небезопасным или ненужным операциям подсистемы.

# Минусы
- Фасад может стать «перегруженным», если в нём аккумулировать слишком много разных задач.
- Урезанный интерфейс может не покрывать все возможности подсистемы — иногда потребуется обходить фасад и работать с подсистемой напрямую.
- Дополнительный уровень абстракции — ещё один компонент, который нужно тестировать и поддерживать.

---

# Пример: реализация фасада для видеоконвертации (Java)

Ниже приведён пример, где сложная подсистема видеоконвертации скрыта за простым фасадом `VideoConverter`. Код демонстрационный: реальная интеграция с кодеками/фреймворками потребует внешних зависимостей, здесь использованы заглушки и имитации поведения.

```java
import java.io.File;

/**
 * Эти классы представляют собой "сложную подсистему" — кодеки,
 * читатели/писатели, миксеры и т. п. В реальной жизни они могут
 * принадлежать внешней библиотеке или фреймворку.
 *
 * В примере — простые заглушки с минимальной логикой.
 */

class VideoFile {
    private final String name;

    public VideoFile(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}

class OggCompressionCodec {
    @Override
    public String toString() {
        return "OggCompressionCodec";
    }
}

class MPEG4CompressionCodec {
    @Override
    public String toString() {
        return "MPEG4CompressionCodec";
    }
}

class CodecFactory {
    public Object extract(VideoFile file) {
        // В реальности логика выбора кодека основана на формате файла.
        // Здесь — простая заглушка.
        System.out.println("[CodecFactory] Извлекаем кодек для " + file.getName());
        return new OggCompressionCodec();
    }
}

class BitrateReader {
    public static String read(String filename, Object codec) {
        // Чтение и декодирование байт-буфера из файла с использованием codec
        System.out.println("[BitrateReader] Чтение " + filename + " с кодеком " + codec);
        return "rawBuffer(" + filename + ")";
    }

    public static String convert(String buffer, Object destinationCodec) {
        // Конвертация буфера в целевой формат
        System.out.println("[BitrateReader] Конвертация буфера " + buffer + " в " + destinationCodec);
        return "converted(" + buffer + "->" + destinationCodec + ")";
    }
}

class AudioMixer {
    public String fix(String result) {
        // Совмещение аудиопотока и финальная правка
        System.out.println("[AudioMixer] Исправляем и миксуем аудио в результате: " + result);
        return "fixed(" + result + ")";
    }
}

/**
 * Фасад: упрощённый интерфейс для работы со сложной подсистемой.
 * Клиент вызывает только метод convert, не зная о множестве внутренних классов.
 */
class VideoConverterFacade {
    /**
     * Преобразовать файл в указанный формат и вернуть объект File с результатом.
     * Внимание: в этом демонстрационном примере возвращается объект File,
     * созданный из строки-результата для простоты представления.
     */
    public File convert(String filename, String format) {
        System.out.println("[VideoConverterFacade] Запущена конвертация: " + filename + " -> " + format);

        VideoFile file = new VideoFile(filename);

        CodecFactory codecFactory = new CodecFactory();
        Object sourceCodec = codecFactory.extract(file);

        Object destinationCodec;
        if ("mp4".equalsIgnoreCase(format)) {
            destinationCodec = new MPEG4CompressionCodec();
        } else {
            destinationCodec = new OggCompressionCodec();
        }

        String buffer = BitrateReader.read(filename, sourceCodec);
        String intermediate = BitrateReader.convert(buffer, destinationCodec);

        AudioMixer audioMixer = new AudioMixer();
        String result = audioMixer.fix(intermediate);

        // Для демонстрации — создаём объект File, имитирующий конечный файл.
        String resultFilename = filename + "." + format;
        System.out.println("[VideoConverterFacade] Конвертация завершена, результат: " + resultFilename);
        return new File(resultFilename);
    }
}

/**
 * Приложение (клиент), использующее фасад. Клиент не знает о внутренних классах.
 */
public class FacadeExample {
    public static void main(String[] args) {
        VideoConverterFacade converter = new VideoConverterFacade();
        File mp4 = converter.convert("funny-cats-video.ogg", "mp4");
        // В реальном приложении мы бы сохранили файл или передали дальше.
        System.out.println("[Application] Результирующий файл: " + mp4.getName());
    }
}
```

---

# Что делает код (коротко)
- Несколько классов (`VideoFile`, `CodecFactory`, `BitrateReader`, `AudioMixer`, кодеки) образуют сложную подсистему видеоконвертации.
- `VideoConverterFacade` инкапсулирует весь порядок шагов и даёт простой метод `convert(filename, format)`.
- Клиент (`FacadeExample`) использует только фасад и не зависит от внутренней структуры подсистемы.

---

# Пару практических замечаний
- Если подсистема содержит логически разные части, полезно создавать несколько специализированных фасадов, чтобы не перегружать один класс разнородной функциональностью.
- Фасад не запрещает обращаться к подсистеме напрямую, если вам нужны расширенные возможности. Но стоит использовать фасад как стандартную точку входа.
- Фасады хорошо подходят для реализации слоёв в архитектуре (например, API-слой вызывает фасад уровня бизнес-логики или интеграции).

---

# Если хочешь — могу:
- добавить пример, где фасад используется вместе с паттерном Адаптер,
- показать unit-тесты для фасада,
- преобразовать демонстрацию в асинхронную обработку (например, сохранение файла в облако),
- или сохранить этот материал в Markdown-файл и дать ссылку для скачивания (если нужно).




## Паттерн «Заместитель» (Proxy) — кратко и с примером на Java

Ниже — сжатое и упорядоченное описание паттерна «Заместитель» (Proxy), его принципа работы, когда применять, плюсы/минусы, и **полный** пример на Java с подробными комментариями и демонстрацией разных вариантов прокси (кеширующий/виртуальный/защищающий).

---

# Описание (основные моменты)
Заместитель (Proxy) — структурный паттерн, который позволяет подставлять вместо реальных объектов специальные объекты-заменители (proxy). Прокси перехватывает вызовы к оригинальному объекту и может выполнить дополнительную логику до или после делегирования вызова реальному объекту.

Ключевая идея: у прокси и у реального сервиса общий интерфейс, поэтому прокси можно передавать в код, ожидающий сервисный объект, не меняя этот код.

---

# Принцип работы
1. Определён общий интерфейс сервиса (например, `ThirdPartyYouTubeLib`).
2. Реальная реализация этого интерфейса (`ThirdPartyYouTubeClass`) содержит тяжёлую/удалённую/чувствительную логику.
3. Класс-прокси (`CachedYouTubeProxy`, `ProtectionProxy` и т.д.) также реализует интерфейс и содержит ссылку на реальный объект.
4. При вызове методов прокси может:
   - лениво создать реальный объект (виртуальный прокси),
   - кешировать результаты и возвращать их без обращения к реальному объекту (кеширующий прокси),
   - проверять права доступа перед делегированием (защищающий прокси),
   - логировать вызовы, трансформировать данные или перенаправлять вызовы по сети (удалённый прокси) и т.д.
5. Клиент работает с прокси так же, как с реальным сервисом.

---

# Когда применять (Применимость)
- Ленивое создание тяжёлых объектов (виртуальный прокси).
- Кеширование результатов дорогих запросов (кеширующий прокси).
- Контроль доступа к ресурсу (защищающий/аутентифицирующий прокси).
- Запросы к удалённому сервису (удалённый прокси, который сериализует/десериализует данные).
- Логирование/мониторинг обращений к сервису.
- Управление жизненным циклом реального объекта (умная ссылка).

---

# Плюсы
- Скрывает от клиента дополнительную служебную логику (инициализация, кеш, безопасность).
- Позволяет экономить ресурсы (ленивость, кеширование).
- Централизует контроль доступа и/или логирование.
- Не требует изменения клиентского кода — прокси реализует тот же интерфейс.

# Минусы
- Дополнительный уровень абстракции (ещё один класс).
- Может добавлять задержки (если прокси делает дорогостоящие проверки).
- Сложнее тестировать (надо тестировать и прокси, и реальный объект).
- Избыточность, если прокси выполняет тривиальную работу.

---

# Пример: реализация прокси для сторонней библиотеки YouTube (Java)

В этом примере показываются:
- `ThirdPartyYouTubeLib` — интерфейс сервиса.
- `ThirdPartyYouTubeClass` — «реальная» библиотека (заглушка).
- `CachedYouTubeProxy` — прокси, который делает ленивую инициализацию и кеширует результаты.
- `ProtectionProxy` — пример защищающего прокси, проверяющего права.
- `YouTubeManager` — клиентский класс, использующий сервис через интерфейс.

```java
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;

/**
 * Интерфейс удалённого сервиса.
 */
interface ThirdPartyYouTubeLib {
    List<String> listVideos();
    String getVideoInfo(String id);
    void downloadVideo(String id);
}

/**
 * "Реальная" реализация сторонней библиотеки.
 * В реальной жизни это был бы внешний SDK, мы его не контролируем.
 * Здесь — простая имитация длительных сетевых операций.
 */
class ThirdPartyYouTubeClass implements ThirdPartyYouTubeLib {

    public ThirdPartyYouTubeClass() {
        // Инициализация может быть дорогой (например, открытие сетевых подключений)
        heavyInitialConfiguration();
    }

    private void heavyInitialConfiguration() {
        System.out.println("[ThirdPartyYouTubeClass] Выполняется тяжёлая инициализация...");
        try {
            Thread.sleep(500); // Имитация задержки при инициализации
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }

    @Override
    public List<String> listVideos() {
        // Имитация сетевого запроса
        simulateNetworkLatency();
        List<String> list = new ArrayList<>();
        list.add("cat_video_id_1");
        list.add("funny_dogs_42");
        list.add("java_tutorial_99");
        System.out.println("[ThirdPartyYouTubeClass] Получен список видео.");
        return list;
    }

    @Override
    public String getVideoInfo(String id) {
        simulateNetworkLatency();
        String info = "VideoInfo(" + id + ")";
        System.out.println("[ThirdPartyYouTubeClass] Получена информация о видео: " + id);
        return info;
    }

    @Override
    public void downloadVideo(String id) {
        simulateNetworkLatency();
        System.out.println("[ThirdPartyYouTubeClass] Видео скачано: " + id);
    }

    private void simulateNetworkLatency() {
        try {
            Thread.sleep(300); // Имитация задержки запроса
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}

/**
 * Кеширующий и виртуальный прокси.
 * Делает ленивую инициализацию реального сервиса и кеширует результаты.
 */
class CachedYouTubeProxy implements ThirdPartyYouTubeLib {

    private ThirdPartyYouTubeLib service;
    private List<String> listCache;
    private Map<String, String> infoCache;
    private boolean needReset = false;

    public CachedYouTubeProxy() {
        this.infoCache = new HashMap<>();
    }

    // Лениво создаём реальный сервис только при первом обращении
    private synchronized ThirdPartyYouTubeLib getService() {
        if (service == null) {
            System.out.println("[CachedYouTubeProxy] Создаём реальный сервис...");
            service = new ThirdPartyYouTubeClass();
        }
        return service;
    }

    @Override
    public List<String> listVideos() {
        if (listCache == null || needReset) {
            System.out.println("[CachedYouTubeProxy] Кеш пуст или сброшен, запрашиваем у сервиса...");
            listCache = getService().listVideos();
        } else {
            System.out.println("[CachedYouTubeProxy] Возвращаем список из кеша.");
        }
        return listCache;
    }

    @Override
    public String getVideoInfo(String id) {
        if (!infoCache.containsKey(id) || needReset) {
            System.out.println("[CachedYouTubeProxy] Инфо не в кеше или кеш сброшен, запрашиваем у сервиса...");
            String info = getService().getVideoInfo(id);
            infoCache.put(id, info);
        } else {
            System.out.println("[CachedYouTubeProxy] Возвращаем инфо из кеша для " + id);
        }
        return infoCache.get(id);
    }

    @Override
    public void downloadVideo(String id) {
        // Для операций загрузки обычно не кешируем — делегируем реальному сервису.
        System.out.println("[CachedYouTubeProxy] Делегируем загрузку реальному сервису для " + id);
        getService().downloadVideo(id);
    }

    public void resetCache() {
        System.out.println("[CachedYouTubeProxy] Сбрасываем кеш.");
        needReset = true;
    }
}

/**
 * Пример защищающего прокси, выполняющего проверку прав доступа
 * перед делегированием к реальному сервису.
 */
class ProtectionProxy implements ThirdPartyYouTubeLib {

    private final ThirdPartyYouTubeLib service;
    private final String userRole;

    public ProtectionProxy(ThirdPartyYouTubeLib service, String userRole) {
        this.service = service;
        this.userRole = userRole;
    }

    private boolean hasAccess(String operation) {
        // Простая демонстрация прав: только "admin" может скачивать видео.
        if ("download".equals(operation)) {
            return "admin".equalsIgnoreCase(userRole);
        }
        // Другие операции доступны всем
        return true;
    }

    @Override
    public List<String> listVideos() {
        if (!hasAccess("list")) {
            throw new SecurityException("Нет прав для получения списка видео");
        }
        return service.listVideos();
    }

    @Override
    public String getVideoInfo(String id) {
        if (!hasAccess("info")) {
            throw new SecurityException("Нет прав для получения информации о видео");
        }
        return service.getVideoInfo(id);
    }

    @Override
    public void downloadVideo(String id) {
        if (!hasAccess("download")) {
            throw new SecurityException("Нет прав для скачивания видео");
        }
        service.downloadVideo(id);
    }
}

/**
 * Клиентский класс, использующий сервис через интерфейс.
 * Ему безразлично, работает ли он с реальным сервисом или прокси.
 */
class YouTubeManager {
    protected ThirdPartyYouTubeLib service;

    public YouTubeManager(ThirdPartyYouTubeLib service) {
        this.service = service;
    }

    public void renderVideoPage(String id) {
        String info = service.getVideoInfo(id);
        System.out.println("[YouTubeManager] Рендер страницы видео: " + info);
    }

    public void renderListPanel() {
        List<String> list = service.listVideos();
        System.out.println("[YouTubeManager] Список видео: " + list);
    }

    public void reactOnUserInput(String id) {
        renderVideoPage(id);
        renderListPanel();
    }
}

/**
 * Демонстрация использования различных прокси.
 */
public class ProxyExample {
    public static void main(String[] args) {
        System.out.println("=== Пример с кеширующим и виртуальным прокси ===");
        CachedYouTubeProxy cachedProxy = new CachedYouTubeProxy();
        YouTubeManager managerWithCache = new YouTubeManager(cachedProxy);

        // Первый вызов — будет лениво создан реальный сервис и результаты закешированы
        managerWithCache.reactOnUserInput("cat_video_id_1");
        System.out.println();

        // Второй вызов — данные возьмутся из кеша, реальный сервис не будет обращаться к сети
        managerWithCache.reactOnUserInput("cat_video_id_1");
        System.out.println();

        System.out.println("=== Пример с защищающим прокси ===");
        // Создадим настоящий сервис и затем обернём его защитным прокси для пользователя "guest"
        ThirdPartyYouTubeLib realService = new ThirdPartyYouTubeClass();
        ProtectionProxy guestProxy = new ProtectionProxy(realService, "guest");
        YouTubeManager managerForGuest = new YouTubeManager(guestProxy);

        managerForGuest.renderListPanel();
        try {
            // Попытка скачать видео от гостя — ожидаем ошибку
            guestProxy.downloadVideo("funny_dogs_42");
        } catch (SecurityException ex) {
            System.out.println("[Application] Ошибка безопасности: " + ex.getMessage());
        }

        System.out.println();

        // Теперь админ имеет право скачивать
        ProtectionProxy adminProxy = new ProtectionProxy(realService, "admin");
        adminProxy.downloadVideo("funny_dogs_42");
    }
}
```

## Поведенческие паттерны

## Цепочка обязанностей
Цепочка обязанностей — это поведенческий паттерн проектирования, который позволяет передавать запросы последовательно по цепочке обработчиков. Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи.

# Паттерн «Стратегия» — кратко и с примером на Java

Ниже — сжатое и упорядоченное описание паттерна «Стратегия», его принципа работы, когда применять, плюсы/минусы, и **полный** пример на Java с подробными комментариями. Комментарии в коде сохранены как в исходном описании.

---

# Описание (основные моменты)
Стратегия (Strategy) — поведенческий паттерн, который определяет семейство схожих алгоритмов и помещает каждый из них в собственный класс. После этого алгоритмы можно взаимозаменять прямо во время выполнения программы. Контекст использует один из объектов-стратегий через общий интерфейс, не завися от конкретной реализации.

Ключевая идея: вынести изменяемые/расширяемые алгоритмы в отдельные классы (стратегии), а в основном классе (контексте) держать только ссылку на стратегию и делегировать ей выполнение задачи.

---

# Принцип работы
1. Определён общий интерфейс стратегий (например, `Strategy` с методом `execute(a, b)`).
2. Каждая конкретная стратегия реализует этот интерфейс своим способом (сложность/поведение алгоритма инкапсулировано в классе стратегии).
3. Контекст содержит ссылку на интерфейс стратегии и в нужный момент вызывает `strategy.execute(...)`.
4. Клиент создаёт конкретную стратегию и передаёт её в контекст; стратегию можно менять в рантайме через сеттер.

---

# Когда применять (Применимость)
- Когда нужно использовать разные вариации какого‑то алгоритма внутри одного объекта.
- Когда есть множество похожих классов, отличающихся только поведением: стратегия позволяет свести их к одному классу с настраиваемым поведением.
- Когда не хочется раскрывать детали реализации алгоритмов другим классам.
- Когда в коде встречается большой условный оператор (switch/if-else) с ветками-алгоритмами — каждую ветку можно вынести в отдельную стратегию.

---

# Плюсы
- Разделение алгоритмов по классам — легче поддерживать и тестировать.
- Возможность менять поведение объекта во время выполнения.
- Уменьшение связности: контекст не зависит от конкретных реализаций стратегий.
- Легко добавлять новые стратегии, не меняя код контекста или существующих стратегий.

# Минусы
- Рост количества классов в проекте (каждый алгоритм — отдельный класс).
- Клиент должен знать, какую стратегию выбрать и передать в контекст.
- При богатом интерфейсе стратегий придётся реализовывать много методов в каждой стратегии, что увеличит шаблонный код.

---

# Пример: арифметические стратегии (Java)

В этом примере показано, как вынести разные арифметические операции в свои стратегии и использовать их через контекст.

```java
/**
 * Общий интерфейс всех стратегий.
 */
interface Strategy {
    /**
     * Выполнить операцию над двумя числами.
     * @param a первое число
     * @param b второе число
     * @return результат операции
     */
    int execute(int a, int b);
}

/**
 * Каждая конкретная стратегия реализует общий интерфейс своим способом.
 */
class ConcreteStrategyAdd implements Strategy {
    @Override
    public int execute(int a, int b) {
        return a + b;
    }
}

class ConcreteStrategySubtract implements Strategy {
    @Override
    public int execute(int a, int b) {
        return a - b;
    }
}

class ConcreteStrategyMultiply implements Strategy {
    @Override
    public int execute(int a, int b) {
        return a * b;
    }
}

/**
 * Контекст всегда работает со стратегиями через общий интерфейс.
 * Он не знает, какая именно стратегия ему подана.
 */
class Context {
    private Strategy strategy;

    /**
     * Позволяет менять стратегию на лету.
     * @param strategy объект-стратегия
     */
    public void setStrategy(Strategy strategy) {
        this.strategy = strategy;
    }

    /**
     * Выполнить операцию, делегируя работу стратегии.
     * @param a первое число
     * @param b второе число
     * @return результат выполнения стратегии
     */
    public int executeStrategy(int a, int b) {
        if (strategy == null) {
            throw new IllegalStateException("Стратегия не установлена");
        }
        return strategy.execute(a, b);
    }
}

/**
 * Конкретная стратегия выбирается на более высоком уровне,
 * например, конфигуратором всего приложения. Готовый объект-
 * стратегия подаётся в клиентский объект, а затем может быть
 * заменён другой стратегией в любой момент на лету.
 */
public class StrategyExample {
    public static void main(String[] args) {
        Context context = new Context();

        int n1 = 10;
        int n2 = 5;

        // 1. Выбираем операцию — сложение
        context.setStrategy(new ConcreteStrategyAdd());
        int resultAdd = context.executeStrategy(n1, n2);
        System.out.println("Addition result: " + resultAdd); // 15

        // 2. Меняем стратегию на вычитание
        context.setStrategy(new ConcreteStrategySubtract());
        int resultSub = context.executeStrategy(n1, n2);
        System.out.println("Subtraction result: " + resultSub); // 5

        // 3. Меняем стратегию на умножение
        context.setStrategy(new ConcreteStrategyMultiply());
        int resultMul = context.executeStrategy(n1, n2);
        System.out.println("Multiplication result: " + resultMul); // 50

        // Пример динамической подстановки стратегии в рантайме
        // (например, пользователь выбрал тип маршрута в UI).
    }
}
```

---

# Что делает код (коротко)
- `Strategy` — общий интерфейс для всех алгоритмов.
- `ConcreteStrategyAdd`, `ConcreteStrategySubtract`, `ConcreteStrategyMultiply` — конкретные стратегии, каждая реализует алгоритм.
- `Context` — класс, использующий стратегию через интерфейс; стратегия может быть установлена и заменена в любом месте программы.
- `StrategyExample` демонстрирует смену стратегий и выполнение операций.

---

# Практические замечания
- Стратегии должны быть взаимозаменяемыми и не держать большого количества внешних зависимостей.
- Если стратегии тяжелые для создания, можно комбинировать с фабрикой стратегий или использовать ленивую загрузку/кеширование.
- При использовании в многопоточном окружении убедитесь, что выбранная стратегия либо потокобезопасна, либо создавайте отдельный экземпляр стратегии для каждого потока.
- Часто удобно передавать стратегии через конструктор контекста (injection) или управлять ими через DI-контейнер.

---

## Паттерн «Состояние» — кратко и с примером на Java

Ниже — сжатое и упорядоченное описание паттерна «Состояние», его принципа работы, когда применять, плюсы/минусы, и **полный** пример на Java с подробными комментариями. Комментарии в коде сохранены и отражают идеи из исходного описания.

---

# Описание (основные моменты)
Состояние (State) — поведенческий паттерн, который позволяет объектам менять поведение в зависимости от своего внутреннего состояния. Создаётся впечатление, что класс объекта изменился: поведение делегируется дочерним объектам‑состояниям.

Ключевая идея: вынести поведение, зависящее от состояний, в отдельные классы‑состояния; контекст хранит ссылку на текущее состояние и делегирует ему соответствующие вызовы. Состояния и контекст могут знать друг о друге и инициировать переходы.

---

# Принцип работы
1. Определён общий интерфейс состояний (например, `State` с методами для действий контекста).
2. Для каждого логического состояния создаётся класс, реализующий этот интерфейс.
3. Контекст содержит ссылку на текущее состояние и делегирует ему обработку входящих событий/вызовов.
4. Конкретные состояния могут вызывать `changeState` у контекста, инициируя переходы между состояниями.
5. Изменение поведения достигается заменой объекта‑состояния в контексте.

---

# Когда применять (Применимость)
- Когда поведение объекта кардинально меняется в зависимости от внутренних состояний.
- Когда в коде много крупных условных операторов (if/switch), выбирающих поведение по значению поля — их можно вынести в классы состояний.
- Когда нужно организовать иерархию состояний и уменьшить дублирование.
- Когда требуется гибко управлять переходами между состояниями (логика переходов может жить в состояниях).

---

# Плюсы
- Устраняет громоздкие условные операторы и улучшает читаемость.
- Легче тестировать отдельные состояния.
- Позволяет добавлять новые состояния без изменения контекста и других состояний (локализация изменений).
- Состояния могут иметь собственные поля и методы, связанные только с этим состоянием.

# Минусы
- Приводит к увеличению числа классов.
- Может усложнить код из‑за распределения логики по множеству объектов.
- При неправильной организации переходов можно запутать логику — надо документировать возможные переходы.

---

# Пример: музыкальный плеер (Java)

Пример демонстрирует, как UI‑действия делегируются разным объектам‑состояниям (Locked, Ready, Playing), а сами состояния могут менять состояние контекста.

```java
/**
 * Общий интерфейс всех состояний.
 */
abstract class State {
    // Контекст, с которым связано состояние (проигрыватель).
    protected AudioPlayer player;

    /**
     * Контекст передаёт себя в конструктор состояния, чтобы
     * состояние могло обращаться к его данным и методам в
     * будущем, если потребуется.
     */
    public State(AudioPlayer player) {
        this.player = player;
    }

    public abstract void clickLock();
    public abstract void clickPlay();
    public abstract void clickNext();
    public abstract void clickPrevious();
}

/**
 * Конкретные состояния реализуют методы абстрактного состояния
 * по-своему.
 */
class LockedState extends State {

    public LockedState(AudioPlayer player) {
        super(player);
    }

    /**
     * При разблокировке проигрывателя с заблокированными
     * клавишами он может принять одно из двух состояний.
     */
    @Override
    public void clickLock() {
        if (player.isPlaying()) {
            player.changeState(new PlayingState(player));
        } else {
            player.changeState(new ReadyState(player));
        }
    }

    @Override
    public void clickPlay() {
        // Ничего не делать.
    }

    @Override
    public void clickNext() {
        // Ничего не делать.
    }

    @Override
    public void clickPrevious() {
        // Ничего не делать.
    }
}

class ReadyState extends State {
    public ReadyState(AudioPlayer player) {
        super(player);
    }

    @Override
    public void clickLock() {
        player.changeState(new LockedState(player));
    }

    @Override
    public void clickPlay() {
        player.startPlayback();
        player.changeState(new PlayingState(player));
    }

    @Override
    public void clickNext() {
        player.nextSong();
    }

    @Override
    public void clickPrevious() {
        player.previousSong();
    }
}

class PlayingState extends State {
    public PlayingState(AudioPlayer player) {
        super(player);
    }

    @Override
    public void clickLock() {
        player.changeState(new LockedState(player));
    }

    @Override
    public void clickPlay() {
        player.stopPlayback();
        player.changeState(new ReadyState(player));
    }

    @Override
    public void clickNext() {
        // В реальном коде можно проверять, был ли двойной клик
        // Здесь просто симулируем поведение.
        player.nextSong();
    }

    @Override
    public void clickPrevious() {
        player.previousSong();
    }
}

/**
 * Проигрыватель выступает в роли контекста.
 */
class AudioPlayer {
    private State state;
    // Поля контекста: UI, громкость, плейлист, текущий трек и т.д.
    private boolean playing;
    private int currentSongIndex;
    private String[] playlist;

    public AudioPlayer() {
        // Изначальное состояние — готовность к воспроизведению.
        this.state = new ReadyState(this);
        this.playing = false;
        this.currentSongIndex = 0;
        this.playlist = new String[] {"Song A", "Song B", "Song C"};

        // Контекст заставляет состояние реагировать на
        // пользовательский ввод вместо себя. Реакция может быть
        // разной, в зависимости от того, какое состояние сейчас
        // активно.
        // Для демонстрации мы не реализуем настоящую UI‑связку,
        // а вызовем методы напрямую в main.
    }

    /**
     * Другие объекты тоже должны иметь возможность заменять
     * состояние проигрывателя.
     */
    public void changeState(State state) {
        System.out.println("[AudioPlayer] Переход в состояние: " + state.getClass().getSimpleName());
        this.state = state;
    }

    // Методы UI будут делегировать работу активному состоянию.
    public void clickLock() {
        state.clickLock();
    }

    public void clickPlay() {
        state.clickPlay();
    }

    public void clickNext() {
        state.clickNext();
    }

    public void clickPrevious() {
        state.clickPrevious();
    }

    // Сервисные методы контекста, вызываемые состояниями.
    public void startPlayback() {
        System.out.println("[AudioPlayer] Запуск воспроизведения: " + playlist[currentSongIndex]);
        this.playing = true;
    }

    public void stopPlayback() {
        System.out.println("[AudioPlayer] Остановка воспроизведения.");
        this.playing = false;
    }

    public void nextSong() {
        currentSongIndex = (currentSongIndex + 1) % playlist.length;
        System.out.println("[AudioPlayer] Следующая композиция: " + playlist[currentSongIndex]);
    }

    public void previousSong() {
        currentSongIndex = (currentSongIndex - 1 + playlist.length) % playlist.length;
        System.out.println("[AudioPlayer] Предыдущая композиция: " + playlist[currentSongIndex]);
    }

    public void fastForward(int seconds) {
        System.out.println("[AudioPlayer] Перемотка вперёд на " + seconds + " секунд.");
    }

    public void rewind(int seconds) {
        System.out.println("[AudioPlayer] Перемотка назад на " + seconds + " секунд.");
    }

    public boolean isPlaying() {
        return playing;
    }
}

/**
 * Демонстрация использования State-паттерна.
 */
public class StateExample {
    public static void main(String[] args) {
        AudioPlayer player = new AudioPlayer();

        // Нажимаем Play — должны перейти в PlayingState и начать воспроизведение.
        player.clickPlay();
        System.out.println();

        // Нажимаем Lock — при играющем треке перейдём в LockedState.
        player.clickLock();
        System.out.println();

        // Нажимаем Lock снова — разблокируем и вернёмся в PlayingState (если играет) или ReadyState.
        player.clickLock();
        System.out.println();

        // Нажимаем Next — текущая стратегия обработает команду по‑разному в зависимости от состояния.
        player.clickNext();
        System.out.println();

        // Останавливаем воспроизведение через Play (в PlayingState Play останавливает).
        player.clickPlay();
        System.out.println();

        // Пытаемся нажать Next в ReadyState — он просто переключит трек.
        player.clickNext();
    }
}
```

---

# Что делает код (коротко)
- `State` — общий интерфейс (абстрактный класс) для всех состояний.
- `LockedState`, `ReadyState`, `PlayingState` — конкретные состояния, реализующие поведение для каждого состояния.
- `AudioPlayer` — контекст, который хранит текущее состояние и делегирует UI‑вызовы текущему состоянию.
- В примере демонстрируется, как смена состояний меняет реакцию на одни и те же методы (clickPlay, clickNext и т.д.).

---

# Практические замечания
- Паттерн Состояние часто применяется к конечным автоматам/стейт‑машинам. Убедитесь, что транзиции между состояниями хорошо задокументированы.
- Состояния могут быть реализованы как одиночки (Singleton), если они не хранят изменяемые данные.
- Можно комбинировать State с другими паттернами (Factory для создания состояний, Strategy для отдельных алгоритмов внутри состояния).
- Для сложных машин состояний полезно рисовать диаграммы переходов и тестировать их отдельно.

---


## Паттерн «Цепочка обязанностей» — кратко и с примером на Java

Ниже — сжатое и упорядоченное описание паттерна «Цепочка обязанностей» (Chain of Responsibility), его принципа работы, когда применять, плюсы/минусы, и **полный** пример на Java с сохранёнными комментариями из описания.

---

# Описание (основные моменты)
Цепочка обязанностей (Chain of Responsibility, CoR) — поведенческий паттерн, который позволяет передавать запросы последовательно по цепочке обработчиков. Каждый обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи.

Ключевая идея: каждую отдельную проверку/обработчик вынести в отдельный объект и связать эти объекты ссылками «next». Отправляя запрос первому обработчику, вы гарантируете, что он пройдет по всей цепочке, при этом любой обработчик может остановить дальнейшую обработку.

---

# Принцип работы
1. Определён общий интерфейс обработчика (например, `Handler` или `ComponentWithContextualHelp`).
2. Каждый конкретный обработчик реализует этот интерфейс и содержит ссылку на следующий обработчик в цепи.
3. При получении запроса обработчик либо обрабатывает его, либо передаёт следующему (или и то, и другое).
4. Клиент создаёт цепочку, связывая обработчики, и отправляет запрос первому обработчику.
5. Цепочку можно настроить динамически: добавлять/удалять/перестраивать звенья.

---

# Когда применять (Применимость)
- Когда нужно обработать запрос несколькими способами, заранее неизвестно, какой обработчик это сделает.
- Когда надо выполнить ряд независимых проверок в строгом порядке (например, аутентификация, валидация, throttle, кеш).
- Когда набор обработчиков должен быть динамическим и конфигурируемым.
- Когда хочется убрать громоздкие условные операторы и заменить их на гибкую структуру объектов.

---

# Плюсы
- Позволяет уменьшить связанность между отправителем запроса и получателями.
- Упрощает добавление новых обработчиков.
- Позволяет динамически перестраивать цепочки обработки.
- Обработчики можно переиспользовать в разных цепочках.

# Минусы
- Невозможно заранее предсказать, какой объект обработает запрос (если требуется — это минус).
- Длина цепочки может влиять на производительность.
- Отладка и трассировка пути запроса по цепочке может быть сложнее.
- Неочевидные побочные эффекты, если обработчики частично изменяют состояние запроса.

---

# Пример: контекстная помощь для UI (Java)

В этом примере реализована цепочка обработки события показа помощи (например, нажатие F1). Компонент запрашивает помощь у себя; если у него нет контекстной помощи, он передаёт запрос контейнеру; контейнеры и диалог могут переопределять показ помощи.

```java
import java.util.ArrayList;
import java.util.List;

/**
 * Интерфейс обработчиков.
 */
interface ComponentWithContextualHelp {
    void showHelp();
}

/**
 * Базовый класс простых компонентов.
 */
abstract class Component implements ComponentWithContextualHelp {
    // Текст всплывающей подсказки.
    protected String tooltipText;

    // Контейнер, содержащий компонент, служит в качестве
    // следующего звена цепочки.
    protected Container container;

    public void setTooltipText(String text) {
        this.tooltipText = text;
    }

    public void setContainer(Container container) {
        this.container = container;
    }

    /**
     * Базовое поведение компонента заключается в том, чтобы
     * показать всплывающую подсказку, если для неё задан текст.
     * В обратном случае — перенаправить запрос своему
     * контейнеру, если тот существует.
     */
    @Override
    public void showHelp() {
        if (tooltipText != null) {
            // Показать подсказку.
            System.out.println("[Component] Показ подсказки: " + tooltipText);
        } else if (container != null) {
            // Передать запрос следующему звену цепочки.
            System.out.println("[Component] Нет подсказки, передаём контейнеру...");
            container.showHelp();
        } else {
            System.out.println("[Component] Нет подсказки и контейнера, помощи нет.");
        }
    }
}

/**
 * Контейнеры могут включать в себя как простые компоненты,
 * так и другие контейнеры. Здесь формируются связи цепочки.
 */
abstract class Container extends Component {
    protected List<Component> children = new ArrayList<>();

    public void add(Component child) {
        children.add(child);
        child.setContainer(this);
    }

    // По умолчанию контейнер использует базовое поведение (проверка tooltipText или передача дальше).
}

/**
 * Большинство примитивных компонентов устроит базовое поведение
 * показа помощи через подсказку, которое они унаследуют из
 * класса Component.
 */
class Button extends Component {
    private String label;

    public Button(String label) {
        this.label = label;
    }

    // Можно оставить поведение showHelp как у родителя.
}

/**
 * Но сложные компоненты могут переопределять метод показа
 * помощи по-своему. Но и в этом случае они всегда могут
 * вернуться к базовой реализации, вызвав метод родителя.
 */
class Panel extends Container {
    // Модальное окно помощи — высший приоритет для этой панели.
    protected String modalHelpText;

    public Panel() {
    }

    public void setModalHelpText(String text) {
        this.modalHelpText = text;
    }

    @Override
    public void showHelp() {
        if (modalHelpText != null) {
            // Показать модальное окно с помощью.
            System.out.println("[Panel] Показ модальной помощи: " + modalHelpText);
        } else {
            // Вернуться к базовому поведению (tooltip или container).
            super.showHelp();
        }
    }
}

/**
 * Dialog — контейнер верхнего уровня.
 */
class Dialog extends Container {
    protected String wikiPageURL;

    public Dialog(String title) {
        // title не используется в демонстрации, но в реальном UI может быть нужен.
    }

    public void setWikiPageURL(String url) {
        this.wikiPageURL = url;
    }

    @Override
    public void showHelp() {
        if (wikiPageURL != null) {
            // Открыть страницу Wiki в браузере.
            System.out.println("[Dialog] Открыть Wiki-страницу: " + wikiPageURL);
        } else {
            super.showHelp();
        }
    }
}

/**
 * Клиентский код.
 */
public class ChainOfResponsibilityExample {
    public static void main(String[] args) {
        // Каждое приложение конфигурирует цепочку по-своему.
        Dialog dialog = new Dialog("Budget Reports");
        dialog.setWikiPageURL("http://example.com/wiki/budget-reports");

        Panel panel = new Panel();
        panel.setModalHelpText("This panel does complex things...");

        Button ok = new Button("OK");
        ok.setTooltipText("This is an OK button that submits data.");

        Button cancel = new Button("Cancel");
        // cancel.tooltipText == null

        panel.add(ok);
        panel.add(cancel);
        dialog.add(panel);

        // Представьте, что здесь произойдёт: пользователь нажал F1 на кнопке Cancel
        ComponentWithContextualHelp componentUnderMouse = cancel;
        System.out.println("=== Нажатие F1 на Cancel ===");
        componentUnderMouse.showHelp();

        System.out.println();

        // Если нажали F1 на ок — подсказка показывается прямо на кнопке.
        System.out.println("=== Нажатие F1 на OK ===");
        ok.showHelp();

        System.out.println();

        // Если компонент не имеет подсказки и контейнеры не дают помощи — обратиться к диалогу.
        System.out.println("=== Нажатие F1 на панель (вручную) ===");
        panel.showHelp();
    }
}
```

---

# Что делает код (коротко)
- `ComponentWithContextualHelp` — интерфейс обработчика.
- `Component` — базовый компонент с поведением: показать tooltip или передать запрос контейнеру.
- `Container`, `Panel`, `Dialog` — контейнеры, составляющие цепочку; `Panel` и `Dialog` могут переопределять поведение помощи.
- Клиент создаёт и связывает компоненты в иерархию (цепочку) и вызывает `showHelp()` у интересующего компонента — запрос пройдет по цепочке до момента, пока кто-то не обработает его.

---

# Практические замечания
- Обработчики должны иметь единый интерфейс, чтобы цепочки могли быть гибкими.
- Можно реализовать базовый класс обработчика, который хранит ссылку на `next` и обеспечивает шаблонный код переадресации.
- Цепочку можно формировать динамически (runtime) и использовать одни и те же обработчики в разных цепочках.
- В сценариях с высокими требованиями к производительности следите за длиной цепочки и потенциальными задержками.

---



---

# Что делает код (коротко)
- `ThirdPartyYouTubeLib` — общий интерфейс для реального сервиса и прокси.
- `ThirdPartyYouTubeClass` — тяжёлая/сетевая реализация (заглушка).
- `CachedYouTubeProxy` — виртуальный + кеширующий прокси: лениво создаёт сервис и кеширует результаты для ускорения повторных вызовов.
- `ProtectionProxy` — прокси, проверяющий права доступа перед делегированием.
- `YouTubeManager` — клиент, которому без разницы, что находится за интерфейсом — прокси или реальный сервис.

---

# Пару практических замечаний
- Прокси удобно комбинировать: например, сначала оборачиваем реальный сервис в `CachedYouTubeProxy`, а потом в `ProtectionProxy` (или наоборот), в зависимости от требований.
- Следите за потокобезопасностью при ленивой инициализации и кешировании (в примере использована простая `synchronized`-методика).
- Для сетевых/удалённых прокси стоит обработать ошибки сети и предусмотреть retry/таймауты.
- Прокси не заменяет необходимость в тестах — тестируйте и поведение прокси, и поведение реального сервиса.

---





# Общая вводная
SOLID — набор пяти принципов объектно-ориентированного проектирования, предложенных Робертом Мартином (Uncle Bob). Цель SOLID — сделать код более гибким, поддерживаемым, тестируемым и понятным. Эти принципы часто применяют вместе: соблюдение одного помогает соблюдению остальных, но и чрезмерное применение (перегиб в сторону абстракций) — источник проблем. Ниже — подробный разбор.

---

# 1) Single Responsibility Principle (SRP)
**Кратко:** каждый класс/модуль должен иметь ровно одну причину для изменения — одну ответственность.

**Развёрнутое объяснение (несколько абзацев):**  
SRP говорит, что класс должен фокусироваться на одной «ответственности» — одной логической задаче или аспекте системы. Под «причиной для изменения» понимают ситуацию, когда из-за изменения в требованиях нужно править класс. Если у класса много обязанностей, то изменения в одной области сломают логику в другой, сложится сильная связанность (coupling) и класс станет сложен для тестирования.

Важная тонкость — granularity (гранулярность): что считать «одной ответственностью»? Для модуля/класса уровня высокоуровневой бизнес-логики ответственность может означать «обработка заказов», тогда внутренние детали (логирование, валидация, пересылка уведомлений) выносятся в отдельные классы. При этом не следует дробить до абсурда — слишком много мелких классов создаёт сложность в навигации (cognitive load) и усложняет поддержку.

SRP тесно связан с тестированием: классы с одной обязанностью легче мокать и тестировать единично (unit tests). В Java SRP часто реализуют через сервисы, репозитории, DTO и утилитные классы — каждый слой отвечает за свою зону (слой данных, бизнес-логика, представление).

**Где применяется в Java:** сервисы в Spring (`@Service`) — одна ответственность (бизнес-логика), репозитории (`@Repository`) — доступ к данным, контроллеры (`@Controller`) — обработка HTTP/маршрутизация. Также SRP применяется при проектировании утилит/хелперов — не смешивать форматирование и доступ к БД.

**Подводные камни и тонкости:**
- SRP не значит «1 файл = 1 метод». Нужно здравое разделение по смыслу.  
- Слишком ранняя декомпозиция (premature decomposition) увеличит число классов и усложнит навигацию.  
- Нельзя забывать о связях: иногда несколько мелких классов создают чрезмерное количество зависимостей — балансируйте.  

## Java — плохой пример (нарушение SRP)
```java
// Плохой пример: класс ReportManager нарушает SRP — делает слишком много задач одновременно:
// - формирует данные из БД
// - форматирует отчет
// - сохраняет отчет в файл
// - отправляет отчет по e-mail
public class ReportManager {
    // Метод формирует и распределяет отчёт
    public void generateAndSendReport() {
        // 1) Получаем данные — доступ к БД (логика доступа к данным)
        // В реальности это должен быть отдельный репозиторий/DAO
        List<String> data = loadDataFromDatabase(); // <-- смешаны уровни: БД внутри менеджера

        // 2) Форматируем отчет (Presentation/Formatting)
        String report = formatReport(data); // <-- форматирование в том же классе — нарушение SRP

        // 3) Сохраняем в файл (I/O)
        saveReportToFile(report, "/tmp/report.txt"); // <-- I/O и бизнес в одном месте

        // 4) Отправляем по email (интеграция с внешним сервисом)
        sendEmail("boss@example.com", "Отчет", report); // <-- сетевые операции в том же классе
    }

    private List<String> loadDataFromDatabase() {
        // заглушка — в реальном коде здесь SQL/ORM
        return Arrays.asList("A", "B", "C");
    }

    private String formatReport(List<String> data) {
        // простая строковая сборка — но логика форматирования внутри
        StringBuilder sb = new StringBuilder();
        for (String s : data) {
            sb.append(s).append("
");
        }
        return sb.toString();
    }

    private void saveReportToFile(String report, String path) {
        // простой пример записи в файл — но ответственность класса теперь I/O
        try (PrintWriter out = new PrintWriter(path)) {
            out.print(report);
        } catch (FileNotFoundException e) {
            // плохой способ управления ошибками — логика ошибки смешана с бизнесом
            e.printStackTrace();
        }
    }

    private void sendEmail(String to, String subject, String body) {
        // заглушка — в реальном проекте это интеграция с SMTP/API
        System.out.println("Отправка письма: " + to);
    }
}
```

## Java — хороший пример (соответствие SRP)
```java
// Правильный пример: разделяем ответственности на несколько классов.
// 1) Репозиторий — доступ к данным
// 2) Форматтер — отвечает за формат отчета
// 3) Хранилище (file storage) — отвечает за сохранение
// 4) MailSender — отвечает за отправку писем
// 5) Сервис — orchestrator, который использует абстракции

// Интерфейс репозитория — ответственность: доступ к данным
interface ReportRepository {
    List<String> loadData(); // метод получения данных
}

// Конкретная реализация репозитория (например, через JPA/DAO)
class DatabaseReportRepository implements ReportRepository {
    @Override
    public List<String> loadData() {
        // Здесь реальная логика доступа к БД (JPA/Hibernate/SQL)
        return Arrays.asList("A", "B", "C");
    }
}

// Форматтер — ответственность: преобразование данных в текст отчёта
class ReportFormatter {
    // Форматировать список строк в тело отчёта
    public String format(List<String> data) {
        StringBuilder sb = new StringBuilder();
        for (String s : data) {
            sb.append(s).append(System.lineSeparator());
        }
        return sb.toString();
    }
}

// Хранилище файлов — ответственность: сохранение отчёта
class FileStorage {
    // Сохранить текст в файл по указанному пути
    public void save(String path, String content) throws IOException {
        try (PrintWriter out = new PrintWriter(path)) {
            out.print(content);
        }
    }
}

// Отправка почты — ответственность: взаимодействие с почтовым сервисом
class MailSender {
    public void send(String to, String subject, String body) {
        // В реальном коде — использовать JavaMailSender или внешнее API
        System.out.println("Simulate sending mail to " + to);
    }
}

// Сервис-оркестратор — ответственность: стек операций для формирования и отправки отчета.
// Важное замечание: сервис зависит от абстракций/конкретных классов, но каждая из зависимостей
// имеет свою ясную ответственность.
class ReportService {
    private final ReportRepository repository; // зависимость: доступ к данным
    private final ReportFormatter formatter;   // зависимость: форматирование
    private final FileStorage storage;         // зависимость: сохранение в файл
    private final MailSender mailSender;       // зависимость: отправка почты

    // Конструктор — зависимости внедряются извне (удобно для тестирования)
    public ReportService(ReportRepository repository,
                         ReportFormatter formatter,
                         FileStorage storage,
                         MailSender mailSender) {
        this.repository = repository;
        this.formatter = formatter;
        this.storage = storage;
        this.mailSender = mailSender;
    }

    // Операция, описывающая один сценарий — сама по себе короткая,
    // делегирует детали специализированным классам.
    public void generateAndSendReport(String path, String recipient) throws IOException {
        // 1) Получаем данные — репозиторий отвечает за этот аспект
        List<String> data = repository.loadData();

        // 2) Форматируем — форматтер отвечает за представление
        String report = formatter.format(data);

        // 3) Сохраняем — FileStorage отвечает за I/O
        storage.save(path, report);

        // 4) Отправляем — MailSender отвечает за интеграцию с почтой
        mailSender.send(recipient, "Отчет", report);
    }
}
```

---

# 2) Open/Closed Principle (OCP)
**Кратко:** сущности должны быть открыты для расширения, но закрыты для изменения.

**Развёрнутое объяснение:**  
OCP означает, что поведение модуля/класса должно быть расширяемым без изменения существующего кода. На практике это достигают через абстракции (интерфейсы, абстрактные классы, стратегии, плагинную архитектуру). Идея — при добавлении новой функциональности не ломать проверенный код, а добавлять новые реализации абстракций.

Тонкость: «закрыт для изменения» не значит «всегда никогда не менять». Иногда рефакторинг и исправление багов требует изменения существующего кода; OCP — ориентир проектирования, а не догма. Кроме того, OCP часто реализуют с преднамеренным использованием наследования/композиции и DI. В Java добавление новых `enum`-типов или switch/case по типу обычно нарушает OCP — каждый switch может потребовать правки при появлении нового кейса.

OCP важен для поддержки в масштабе: если у вас модуль используется многими командами, изменение базового поведения может вызвать регрессии. Поэтому проектируют расширяемые точки, а остальное закрывают.

**Где применяется в Java:** паттерны Strategy, Template Method, Chain of Responsibility, использование интерфейсов и Spring-бинов с профилями/фабриками; плагинные архитектуры (ServiceLoader), обработчики событий.

**Подводные камни:**
- Излишняя абстракция и интерфейсы «на всё» — усложняет код и повышает трудозатраты.
- OCP обычно достигается через интерфейсы/абстракции — следите за тем, чтобы интерфейсы были стабильны и понятны.
- Иногда проще изменить код, чем выдумывать сложную архитектуру.

## Java — плохой пример (нарушение OCP)
```java
// Плохой пример: калькулятор скидок с switch по типу клиента.
// При добавлении нового типа нужно изменить существующий класс — нарушение OCP.
public class DiscountCalculator {
    public enum CustomerType { REGULAR, VIP }

    // Метод вычисляет скидку в зависимости от типа клиента
    public double calculateDiscount(CustomerType type, double amount) {
        // switch — каждый новый тип заставит менять этот код
        switch (type) {
            case REGULAR:
                return amount * 0.05; // 5% для обычных
            case VIP:
                return amount * 0.15; // 15% для VIP
            default:
                return 0;
        }
    }
}
```

## Java — хороший пример (соответствие OCP)
```java
// Правильный пример: используем абстракцию DiscountPolicy.
// Добавление нового типа скидки — реализация нового класса, без изменения калькулятора.

interface DiscountPolicy {
    double applyDiscount(double amount); // абстрактный контракт для скидки
}

// Конкретная стратегия: стандартная скидка
class RegularDiscountPolicy implements DiscountPolicy {
    @Override
    public double applyDiscount(double amount) {
        return amount * 0.05; // 5%
    }
}

// Конкретная стратегия: VIP скидка
class VipDiscountPolicy implements DiscountPolicy {
    @Override
    public double applyDiscount(double amount) {
        return amount * 0.15; // 15%
    }
}

// Класс-агрегатор/калькулятор — закрыт для изменения: он просто использует политику
class DiscountCalculator {
    private final DiscountPolicy policy; // зависит от абстракции

    // Внедряем политику через конструктор (DI)
    public DiscountCalculator(DiscountPolicy policy) {
        this.policy = policy;
    }

    // Вычисление скидки делегируется политике — при добавлении новых политик класс не меняется
    public double calculateDiscount(double amount) {
        return policy.applyDiscount(amount);
    }
}

// Добавление новой политики (например, SeasonalDiscountPolicy) не потребует изменения DiscountCalculator.
```

---

# 3) Liskov Substitution Principle (LSP)
**Кратко:** объекты подклассов должны быть взаимозаменяемы с объектами базового класса без нарушения корректности программы (предикат: экземпляр подкласса должен вести себя как экземпляр суперкласса).

**Развёрнутое объяснение:**  
LSP — это формализация корректного наследования: подклассы должны сохранять поведение, ожидаемое от базового типа. Это касается пред- и постусловий методов, инвариантов и побочных эффектов. Если клиент кода ожидает поведение базового класса, замена его на подкласс не должна ломать программу.

Классический пример нарушения LSP — наследование `Square` от `Rectangle`. В `Rectangle` у вас есть `setWidth` и `setHeight`. Для квадрата изменение ширины меняет высоту, что ломает ожидание клиента, который думает, что `setWidth` не затрагивает высоту. Следовательно `Square` не соответствует контракту `Rectangle`.

Тонкости: LSP — это не только сигнатуры методов (типовые сигнатуры), но и поведение: исключения, изменения состояния, побочные эффекты, производительность (в редких случаях существенная деградация производительности может считаться нарушением, если код ожидает характеристики). В Java также важно учитывать ковариантность возвращаемых типов и неизменяемость — immutable классы проще соответствовать LSP.

**Где применяется в Java:** при проектировании иерархий классов, коллекций, API библиотек; при наследовании от стандартных классов Java (например, `InputStream`) — всегда думайте о контракте суперкласса.

**Подводные камни:**
- Простая замена `extends` на `implements` или композицию часто решает проблему.  
- Нарушение LSP может быть тонким: изменение хранимого состояния, ожидание вызова `equals`/`hashCode`, сериализация — всё это может ломать поведение.  
- Документируйте контракты методов (JavaDoc): pre/post-условия, возможные исключения — чтобы унаследовавшие классы знали гарантии.

## Java — плохой пример (нарушение LSP — Rectangle/Square)
```java
// Пример классического нарушения LSP: Square наследует Rectangle,
// но поведение методов setWidth/setHeight становится неожиданным.

class Rectangle {
    protected int width;
    protected int height;

    // Установить ширину
    public void setWidth(int width) {
        this.width = width;
    }

    // Установить высоту
    public void setHeight(int height) {
        this.height = height;
    }

    // Получить площадь
    public int getArea() {
        return width * height;
    }
}

// Square наследует Rectangle — кажется логичным с точки зрения "is-a",
// но поведение нарушает ожидания: у квадрата установка ширины должна менять высоту.
class Square extends Rectangle {
    @Override
    public void setWidth(int width) {
        // чтобы оставаться "квадратом", ширину и высоту синхронизируем
        this.width = width;
        this.height = width; // побочный эффект — нарушает контракт Rectangle
    }

    @Override
    public void setHeight(int height) {
        this.width = height;
        this.height = height; // аналогично
    }
}

// Клиентский код, который ожидает Rectangle, может ломаться:
class Client {
    // Ожидается, что setWidth не повлияет на высоту — но для Square это не так
    public static void main(String[] args) {
        Rectangle r = new Square();
        r.setWidth(5);
        r.setHeight(4);
        // Ожидаемая площадь: 5*4=20, но для Square после setHeight(4) width==4 -> площадь 16
        System.out.println("Area = " + r.getArea()); // неожиданное поведение
    }
}
```

## Java — хороший пример (соответствие LSP)
```java
// Решение: не наследовать Square от Rectangle; вместо этого:
// 1) Создать интерфейс Shape (поведение: area)
// 2) Конкретные реализации Rectangle и Square не наследуют друг друга.
// Это сохраняет LSP — объекты взаимозаменяемы по интерфейсу Shape.

interface Shape {
    int getArea(); // контракт: возвращает площадь
}

class RectangleShape implements Shape {
    private final int width;
    private final int height;

    // Rectangle - неизменяемый объект (immutable) — меньше шансов нарушить контракт
    public RectangleShape(int width, int height) {
        this.width = width;
        this.height = height;
    }

    @Override
    public int getArea() {
        return width * height;
    }
}

class SquareShape implements Shape {
    private final int side;

    public SquareShape(int side) {
        this.side = side;
    }

    @Override
    public int getArea() {
        return side * side;
    }
}

// Клиентский код использует Shape и не зависит от деталей реализации.
// Замена RectangleShape на SquareShape не ломает контракт getArea().
class Client {
    public static void main(String[] args) {
        Shape rect = new RectangleShape(5, 4);
        Shape square = new SquareShape(4);

        System.out.println("Rect area = " + rect.getArea());   // 20
        System.out.println("Square area = " + square.getArea()); // 16
    }
}
```

---

# 4) Interface Segregation Principle (ISP)
**Кратко:** клиент не должен быть вынужден зависеть от интерфейсов, которые он не использует — разделяйте «толстые» интерфейсы на узконаправленные.

**Развёрнутое объяснение:**  
Когда интерфейс содержит много методов, разные клиенты могут нуждаться только в подмножестве этих методов. Если класс вынужден реализовать интерфейс целиком, он получает методы, которые ему не нужны — это ведёт к пустым реализациям, заглушкам и усложнению кода. ISP призывает проектировать множество маленьких, «тонких» интерфейсов, специализированных по задаче: каждый клиент реализует только те интерфейсы, которые ему действительно нужны.

Тонкость: разделение интерфейсов должно быть семантически мотивировано. Не стоит дробить интерфейс ради дробления. Java 8 ввёл default-методы в интерфейсах — они облегчают эволюцию интерфейсов, но злоупотребление default может скрыть плохую проектную модель (люди могут начать добавлять поведение в интерфейсы, объединяя обязанности).

**Где применяется в Java:** designing service interfaces, API, DTO, Spring Beans (не заставляйте бины реализовывать лишние методы), JDK interfaces (например, `List` vs `Collection` — JDK уже дробит интерфейсы). В микросервисной архитектуре — отдельные контракты на чтение/запись (CQRS) — тоже пример ISP.

**Подводные камни:**
- Слишком маленькие интерфейсы -> множество интерфейсных типов, что усложняет кодовую базу.  
- Default методы часто используются для обратной совместимости — но они могут нарушить явное разделение обязанностей.  

## Java — плохой пример (нарушение ISP)
```java
// Плохой пример: большой интерфейс MultiFunctionDevice содержит много методов.
// Принуждает имплементаторов реализовывать ненужные операции.
interface MultiFunctionDevice {
    void print(String doc);
    void scan(String doc);
    void fax(String doc);
    void staple(String doc);
}

// Принципиально простой принтер вынужден реализовать все методы,
// даже если он не умеет fax или staple.
class SimplePrinter implements MultiFunctionDevice {
    @Override
    public void print(String doc) {
        System.out.println("Печать: " + doc);
    }

    @Override
    public void scan(String doc) {
        // Этот принтер не умеет сканировать — приходится делать заглушку
        throw new UnsupportedOperationException("Scan not supported");
    }

    @Override
    public void fax(String doc) {
        // заглушка
        throw new UnsupportedOperationException("Fax not supported");
    }

    @Override
    public void staple(String doc) {
        // заглушка
        throw new UnsupportedOperationException("Staple not supported");
    }
}
```

## Java — хороший пример (соответствие ISP)
```java
// Правильный пример: разделяем один большой интерфейс на несколько маленьких.
// Printer, Scanner, Fax, Stapler — клиенты реализуют только нужное.

interface Printer {
    void print(String doc); // ответственность: печать
}

interface Scanner {
    void scan(String doc); // ответственность: сканирование
}

interface Fax {
    void fax(String doc); // ответственность: факс
}

interface Stapler {
    void staple(String doc); // ответственность: степлер
}

// Класс, который только печатает — реализует только Printer
class SimplePrinter2 implements Printer {
    @Override
    public void print(String doc) {
        System.out.println("Печать: " + doc);
    }
}

// Комбинированный многофункциональный девайс может реализовать несколько интерфейсов,
// но каждая реализация остаётся чистой и явной.
class MultiFunctionPrinter implements Printer, Scanner, Stapler {
    @Override
    public void print(String doc) {
        System.out.println("MFP печать: " + doc);
    }

    @Override
    public void scan(String doc) {
        System.out.println("MFP сканирование: " + doc);
    }

    @Override
    public void staple(String doc) {
        System.out.println("MFP сшивание: " + doc);
    }
}
```

---

# 5) Dependency Inversion Principle (DIP)
**Кратко:** модули верхнего уровня не должны зависеть от модулей нижнего уровня — оба должны зависеть от абстракций. Абстракции не должны зависеть от деталей; детали должны зависеть от абстракций.

**Развёрнутое объяснение:**  
DIP говорит: код высокого уровня (бизнес-правила) не должен напрямую зависеть от реализации низкоуровневых модулей (хранилищ, сетевых клиентов). Вместо этого оба уровня должны зависеть от абстракций (интерфейсов). Это облегчает замену реализаций, тестирование (mock), и уменьшает связанность.

В Java DIP реализуют через интерфейсы и внедрение зависимостей (Dependency Injection — вручную или с помощью контейнеров как Spring). Вместо `new ConcreteRepo()` в бизнес-коде используют `Repository repo` в конструкторе и предоставляют конкретную реализацию извне. Это также упрощает написание тестов: в тестах внедряется мок/фейк.

**Где применяется в Java:** везде: сервисы, DAO, репозитории в Spring, абстракции над внешними API, тестируемые компоненты. Также DIP связан с уровнем модулей/пакетов — gradle/maven модули могут зависеть друг от друга только в направлении абстракций.

**Подводные камни:**
- DIP требует больше кода (интерфейсы, фабрики), что может казаться избыточным для небольших проектов.  
- Чрезмерное применение DIP (интерфейсы для всего) — приводит к «interface pollution». Хорошая практика: создавать интерфейс, когда планируется несколько реализаций или когда требуется тестирование.  
- Не забывайте про конфигурацию DI: неправильная конфигурация контейнера приведёт к runtime-ошибкам.

## Java — плохой пример (нарушение DIP)
```java
// Плохой пример: класс OrderService напрямую зависит от конкретной реализации OrderRepositoryImpl.
// Это делает тестирование и замену реализации тяжёлыми.

class OrderRepositoryImpl {
    public void saveOrder(String order) {
        // Конкретная реализация сохранения (например, JDBC)
        System.out.println("Сохранение заказа в БД: " + order);
    }
}

class OrderServiceBad {
    private final OrderRepositoryImpl repository; // зависимость от конкретного класса

    public OrderServiceBad() {
        // явная привязка к конкретной реализации внутри конструктора
        this.repository = new OrderRepositoryImpl();
    }

    public void placeOrder(String order) {
        // бизнес-логика, но мы не можем легко подменить репозиторий (трудно тестировать)
        repository.saveOrder(order);
    }
}
```

## Java — хороший пример (соответствие DIP)
```java
// Правильный пример: зависимость от абстракции (интерфейса), реализация внедряется извне.
// Это упрощает тестирование и замену реализации.

interface OrderRepository {
    void saveOrder(String order); // контракт — абстракция для репозитория
}

class OrderRepositoryJdbc implements OrderRepository {
    @Override
    public void saveOrder(String order) {
        // Конкретная реализация через JDBC/ORM
        System.out.println("Сохранение заказа в БД (JDBC): " + order);
    }
}

// Сервис верхнего уровня зависит от абстракции OrderRepository, а не от конкретики.
// Это позволяет легко подменять реализацию (моки/фейковые репозитории) в тестах.
class OrderService {
    private final OrderRepository repository; // зависимость от интерфейса

    // Конструктор принимает интерфейс — реализация передаётся извне (DI)
    public OrderService(OrderRepository repository) {
        this.repository = repository;
    }

    public void placeOrder(String order) {
        // бизнес-логика — сервис не знает деталей хранения
        repository.saveOrder(order);
    }
}

// Пример конфигурации вручную (в простом приложении)
// В реальном проекте эту работу делает Spring/Guice
class App {
    public static void main(String[] args) {
        // В приложении создаём конкретную реализацию и передаём её в сервис
        OrderRepository repo = new OrderRepositoryJdbc();
        OrderService service = new OrderService(repo); // DI вручную
        service.placeOrder("order#1");
    }
}
```

---

# Общие тонкости при подготовке к собеседованию (senior Java developer)
1. **Баланс абстракций и простоты.** На собеседовании ожидают понимания, когда применять SOLID и когда — нет. Частая ошибка — чрезмерная абстракция (интерфейсы для всего) без явной нужды. Докажите практическим примерами: «я создаю интерфейс, когда ожидаю >1 реализации или когда нужно мокирование/тестирование».

2. **Покажите знание инструментов Java/Spring.** Для DIP и SRP можно привести примеры с `@Autowired`, конфигурацией `@Bean`, `@Profile`, Factory Beans. Объясните разницу constructor injection vs field injection (конструктор предпочтительнее для immutability и тестирования).

3. **Поведение, контракты и документация.** LSP — прежде всего про контракт. Упомяните JavaDoc: указывайте pre/post условия и исключения; обсудите неизменяемость и побочные эффекты. Упомяните про `equals/hashCode` и контракт serializable.

4. **Backward compatibility и OCP.** В Java 8 добавлены default методы — их используют для эволюции интерфейсов, но это может нарушать ISP (интерфейсы начинают содержать поведение).

5. **Performance vs design.** Иногда прямой вызов `new` быстрее и проще; в высокопроизводительных участках слишком сложный DI может добавить накладные расходы. Проведите анализ и профайлинг перед оптимизацией.

6. **Архитектурные границы.** SOLID применяется локально в модуле/сервисе. На уровне микросервисов часто применяют CQRS, event sourcing — эти паттерны отражают принципы ISP/OCP (разделение команд/запросов).

7. **Тестирование и TDD.** SOLID упрощает Unit testing и Mocking. Покажите примеры (Mockito, junit5), почему интерфейсы упрощают создание стаба.

8. **Practical examples at scale.** Можете привести примеры из реальной практики: рефакторинг монолита по SRP (вынос слоёв), введение плагинов через ServiceLoader (OCP), исправление LSP-нарушения в старом коде (перехождение от наследования к композиции).

---

# Резюме — что можно упомянуть на собеседовании (короткая шпаргалка)
- SRP — «одна причина для изменения»; примеры: разделение репозитория/сервиса/форматтера.  
- OCP — «закрыт для изменения, открыт для расширения» через интерфейсы/стратегии/плагины.  
- LSP — подклассы должны быть взаимозаменяемы по контракту (избегать неправильного наследования, использовать композицию).  
- ISP — маленькие интерфейсы; клиенты реализуют только необходимое.  
- DIP — зависеть от абстракций; внедрение зависимостей (constructor injection), использовать Spring/Guice.


# DRY и KISS — подробное объяснение, примеры, тонкости для senior Java собеседования

Отлично — разберём два фундаментальных принципа разработки: **DRY** (Don’t Repeat Yourself) и **KISS** (Keep It Simple, Stupid / Keep It Short & Simple). Для каждого принципа дам несколько больших абзацев с объяснениями и тонкостями, где и как применяется в Java, затем покажу **два Java-примера**: нарушение и соблюдение. В коде будут подробные комментарии на русском — построчно и по методам — чтобы вы могли детально объяснить их на интервью. В конце — практические советы, конфликты между принципами и типичные ловушки.

---

# 1) DRY — Don’t Repeat Yourself

**Кратко:** избегай дублирования знания — логики, конфигурации, требований, строковых констант, SQL-запросов, правил валидации и т. п. Если один и тот же смысл/правило повторяется в нескольких местах — вынеси его в одно место и используй повторно.

**Развёрнутое объяснение (несколько больших абзацев):**  
DRY — это не только про «не копировать и вставлять код». Это про отсутствие дублирования знаний в системе: бизнес-правил, формул, текста сообщений, схемы данных, конфигураций. Повторяющийся код — это источник багов: если правило меняется, нужно править все копии, легко забыть одно место и получить рассинхронизацию. DRY повышает поддерживаемость, уменьшает площадь, которую нужно тестировать, и делает поведение системы предсказуемым.

Однако DRY требует здравого смысла: есть разные виды повторения. Повторение кода, вызванное сходной, но семантически разной логикой — это false positive: агрессивное устранение такого повторения может привести к неправильной общей абстракции (например, попытка объединить методы с чуть разной семантикой). Также существует «повторение в тестах», которое иногда уместно — тесты могут дублировать вызовы, чтобы быть максимально ясными и независимыми. Главное — различать **повторение знания** (нужно устранить) и **повторение действий** (иногда допустимо для ясности).

DRY в больших Java-проектах проявляется на многих уровнях: общие утилиты, базовые классы, константы (вынесенные в `constants`), единые слои доступа к данным (репозитории), общие DTO, общие исключения, единая библиотека валидации, shared modules в многомодульном maven/gradle проекте. Инструменты для поддержки DRY: модульность (maven/gradle), общие библиотеки, internal SDK, шаблоны кода (archetype), code generation (если абстракцию сложно поддерживать вручную), а также отказ от копипаста через code reviews и линтеры.

**Подводные камни и тонкости:**
- **Premature abstraction (преждевременная абстракция):** вынесение слишком ранних абстракций для устранения копипаста может создать «чужую» абстракцию, которую сложнее понять и изменить.  
- **Wrong shared abstraction:** если вы вынесли логику, но она вынуждает разные участки кода подстраиваться под неё, может появиться высокое coupling.  
- **Over-DRY:** превращение проекта в монолитную утилиту с большим количеством configuration flags, чтобы угодить всем, часто ухудшает читаемость.  
- **Тесты и DRY:** дублирование тестовых данных иногда полезно — test duplication ≠ production duplication; тесты должны быть читаемы и независимы.

---

## DRY — Плохой пример (нарушение DRY)

```java
// Пример нарушения DRY: в двух сервисах повторяется одна и та же логика валидации.
// Копипаст делает поддержку рискованной — если правило проверки изменится, придётся править оба места.

public class UserService {
    // Метод регистрации пользователя — содержит встроенную валидацию
    public void registerUser(String username, String email) {
        // Валидация: имя не пустое и длина >= 3
        if (username == null || username.trim().isEmpty() || username.length() < 3) {
            throw new IllegalArgumentException("username must be at least 3 chars");
        }
        // Валидация: простая проверка e-mail
        if (email == null || !email.contains("@")) {
            throw new IllegalArgumentException("invalid email");
        }
        // далее логика сохранения
        // ...
    }
}

public class AdminService {
    // Почти та же самая валидация, скопированная из UserService
    public void createAdmin(String username, String email) {
        // КОПИРАЙТЕ-КОПИРАЙТЕ — дублирование
        if (username == null || username.trim().isEmpty() || username.length() < 3) {
            throw new IllegalArgumentException("username must be at least 3 chars");
        }
        if (email == null || !email.contains("@")) {
            throw new IllegalArgumentException("invalid email");
        }
        // логика создания администратора
        // ...
    }
}
```

Комментарии: здесь мы видим дублирование правил валидации в двух разных классах. Если правило изменится (например, минимальная длина станет 5 или валидация email усложнится), небрежный разработчик может обновить только один сервис — баги гарантированы.

---

## DRY — Хороший пример (соблюдение DRY)

```java
// Правильный пример: вынесли валидацию в отдельный класс-валидатор и переиспользуем.
// Благодаря этому правило централизовано и легко тестируемо.

public class UserValidator {
    // Метод валидирует username и email по единому контракту.
    public void validateUsernameAndEmail(String username, String email) {
        // Проверяем username
        if (username == null || username.trim().isEmpty() || username.length() < 3) {
            throw new IllegalArgumentException("username must be at least 3 chars");
        }
        // Проверяем email (базовая проверка)
        if (email == null || !email.contains("@")) {
            throw new IllegalArgumentException("invalid email");
        }
    }
}

// Сервис для пользователей — использует общий валидатор
public class UserService2 {
    private final UserValidator validator;

    // Внедряем валидатор (DI) — удобно для тестов
    public UserService2(UserValidator validator) {
        this.validator = validator;
    }

    public void registerUser(String username, String email) {
        // Делегируем валидацию общему компоненту
        validator.validateUsernameAndEmail(username, email);
        // Сохранение, логирование и т.д.
    }
}

// Сервис для админов — тот же валидатор переиспользуется
public class AdminService2 {
    private final UserValidator validator;

    public AdminService2(UserValidator validator) {
        this.validator = validator;
    }

    public void createAdmin(String username, String email) {
        // Делегируем ту же валидацию — одна точка правки
        validator.validateUsernameAndEmail(username, email);
        // Специфичная логика для админов
    }
}
```

Комментарии: теперь правило валидации централизовано. Тесты покрывают `UserValidator` один раз, и при изменении правила довольно безопасно обновлять одно место.

---

# 2) KISS — Keep It Simple, Stupid (или Keep It Short & Simple)

**Кратко:** проектируй простые и понятные решения. Сложность — основной источник ошибок. Предпочти понятный код «красивому» и многослойному, если сложность не обоснована.

**Развёрнутое объяснение (несколько больших абзацев):**  
KISS — призыв к простоте: ясные интерфейсы, понятные названия, маленькие методы, отсутствие ненужных уровней абстракции. Простая реализация легче читать, сопровождать и тестировать. KISS не значит «нынешний хак — хороший», он уравновешивает необходимость простоты и долгосрочной поддержки: код должен быть простым **и** правильным, а не просто кратким.

Сложность исчисляется по-разному: cyclomatic complexity (ветвления), number of moving parts (модули/флаги), глубина наследования, количество конфигурационных опций, непонятные именования, отвлечённые паттерны. KISS рекомендует разбивать проблему на простые подзадачи, избегать избыточных паттернов (например, сложная фабрика для простых объектов), избегать «умных» трюков ради краткости (магические one-liners, глубокие лямбда-цепочки без комментариев).

В Java KISS выглядит как: понятные классы с одной ответственностью, простые POJO/DTO, минимальная и понятная конфигурация Spring, использование стандартных коллекций, избегание чрезмерного обобщения (универсальные утилиты, которые пытаются покрыть всё), предпочтение композиции над сложным наследованием. KISS особенно важен для высокого уровня — API, публичных контрактов, микросервисных границ: если ваш API сложен, клиенты будут делать ошибки.

**Подводные камни и тонкости:**
- **Простота ≠ примитивность:** иногда простое выглядит как трюк. Нужно объяснить почему выбран именно такой, а не более «правильный, но сложный» вариант.  
- **KISS vs DRY:** иногда устранение дублирования (DRY) приводит к сложной абстракции, что нарушает KISS. Нужно балансировать: лучше иметь небольшое дублирование, чем запутанную универсальную реализацию.  
- **YAGNI (You Aren’t Gonna Need It):** KISS близок к YAGNI — не добавляйте фичи/абстракции «на будущее». Но будьте осторожны: иногда знание о возможных расширениях (OCP) оправдывает лёгкую абстракцию.  
- **Документация и KISS:** простой код всё-таки требует документации: почему архитектура такова, где границы, почему не применили фабрики и т. п.

---

## KISS — Плохой пример (нарушение KISS)

```java
// Пример сложности: один метод делает кучу задач, использует вложенные if/else, много побочных эффектов.
// Такой код тяжело читать, поддерживать и тестировать.

public class ComplexProcessor {

    // Метод обрабатывает заказ: валидация, расчёт, логирование, сохранение, внешние вызовы
    public void processOrder(Order order, boolean calculateTax, boolean notifyUser, int priorityLevel) {
        // Слишком много логики в одном методе — KISS нарушен.

        // Валидация (множество условий)
        if (order == null) {
            throw new IllegalArgumentException("order is null");
        }
        if (order.getItems() == null || order.getItems().isEmpty()) {
            throw new IllegalArgumentException("no items");
        }

        // Сложные вложенные правила расчёта
        double total = 0;
        for (OrderItem it : order.getItems()) {
            double price = it.getPrice();
            if (it.isDiscounted()) {
                // Неструктурированная логика расчёта скидки
                price = price * (1 - it.getDiscountRate());
            } else {
                // разные способы округления и CPA условия
                if (priorityLevel > 5) {
                    price = Math.round(price * 100.0) / 100.0;
                } else {
                    price = (double) Math.round(price);
                }
            }
            total += price * it.getQuantity();
        }

        // Несколько побочных эффектов: сохранение, логирование, внешняя отправка
        saveToDatabase(order, total);      // напрямую внутри метода
        if (notifyUser) {
            // внешний HTTP вызов прямо здесь
            callExternalNotificationService(order.getUserId(), "Your order processed");
        }

        if (calculateTax) {
            // налог вычисляем в теле — тут трудно подменить логику
            double tax = total * 0.2; // жестко прописанный налог
            updateOrderWithTax(order, tax);
        }
    }

    // Заглушки для иллюстрации
    private void saveToDatabase(Order order, double total) {}
    private void callExternalNotificationService(String userId, String message) {}
    private void updateOrderWithTax(Order order, double tax) {}
}
```

Комментарии: метод большой, делает всё подряд, содержит флаги (`calculateTax`, `notifyUser`) которые меняют поведение. Такие флаги делают тестирование комбинаторно сложным, увеличивают ветвление и вероятность ошибок.

---

## KISS — Хороший пример (соблюдение KISS)

```java
// Правильный пример: разбиваем сложную операцию на мелкие понятные методов/классы.
// Каждый класс/метод делает одну вещь — проще тестировать и понимать.
// Комментарии по-русски поясняют каждую строчку.

public class OrderProcessor { // класс-координатор: orchestrates процесс обработки

    private final OrderValidator validator;           // валидатор: отвечает только за валидацию
    private final PriceCalculator priceCalculator;    // калькулятор цен: расчёт итогов
    private final OrderRepository orderRepository;    // репозиторий: сохранение в БД
    private final NotificationService notificationService; // уведомления: внешний вызов
    private final TaxService taxService;              // налоговый сервис: вычисление и правило налога

    // Конструктор — зависимости внедряются (удобно для тестов)
    public OrderProcessor(OrderValidator validator,
                          PriceCalculator priceCalculator,
                          OrderRepository orderRepository,
                          NotificationService notificationService,
                          TaxService taxService) {
        this.validator = validator;
        this.priceCalculator = priceCalculator;
        this.orderRepository = orderRepository;
        this.notificationService = notificationService;
        this.taxService = taxService;
    }

    // Публичный метод — короткий и читаемый: описывает высокоуровневую последовательность.
    public void process(Order order, boolean notifyUser) {
        // 1) Валидация — делегируем валидатору
        validator.validate(order);

        // 2) Расчёт итоговой цены — делегируем калькулятору
        double total = priceCalculator.calculateTotal(order);

        // 3) Сохранение — делегируем репозиторию
        orderRepository.save(order, total);

        // 4) Уведомление — делегируем отдельному сервису (и только если нужно)
        if (notifyUser) {
            notificationService.notifyUser(order.getUserId(), "Ваш заказ обработан");
        }

        // 5) Налог — делегируем отдельному сервису, чтобы логику можно было менять независимо
        double tax = taxService.calculateTax(total);
        orderRepository.updateTax(order, tax);
    }
}

// Примеры зависимостей — каждая отвечает за одну область
class OrderValidator {
    public void validate(Order order) {
        if (order == null) throw new IllegalArgumentException("order is null");
        if (order.getItems() == null || order.getItems().isEmpty()) throw new IllegalArgumentException("no items");
    }
}

class PriceCalculator {
    public double calculateTotal(Order order) {
        double total = 0;
        for (OrderItem it : order.getItems()) {
            double price = it.getPrice();
            // вынесенные отдельные правила обработки скидок и округления
            if (it.isDiscounted()) {
                price = applyDiscount(price, it.getDiscountRate());
            }
            price = applyRounding(price, it);
            total += price * it.getQuantity();
        }
        return total;
    }

    private double applyDiscount(double price, double rate) {
        return price * (1 - rate);
    }

    private double applyRounding(double price, OrderItem item) {
        // простой и ясный метод, легко тестируемый
        return Math.round(price * 100.0) / 100.0;
    }
}

interface OrderRepository {
    void save(Order order, double total);
    void updateTax(Order order, double tax);
}

interface NotificationService {
    void notifyUser(String userId, String message);
}

interface TaxService {
    double calculateTax(double total);
}
```

Комментарии: публичный метод `process` — краткий и читабельный. Логика разделена на отдельные компоненты, каждый из которых прост и тестируем. Такой подход соответствует KISS и облегчает поддержку.

---

# Где применяется в Java (DRY и KISS)

- **Модули и библиотеки:** вынос общих утилит/помощников в shared-модули (DRY), при этом каждый модуль должен быть простым и иметь ясную ответственность (KISS).
- **API и публичные интерфейсы:** делайте прозрачные и простые контрактные методы (KISS). Общую логику валидации/форматирования выносите в одну библиотеку или util-класс (DRY).
- **Тесты:** DRY применим в интеграционных тестах (shared test fixtures), но не злоупотребляйте — иногда явные повторяющиеся сцены тестов повышают читаемость. KISS — держите тесты короткими и прямыми.
- **Конфигурация:** централизованная конфигурация (DRY) через `application.yml`/`properties`. KISS — не делайте конфигурации чрезмерно параметризованной без нужды.
- **Архитектура микросервисов:** если бизнес-правило используется во многих сервисах, вынесите его в библиотеку или отдельный сервис (DRY). Но API и взаимодействия между сервисами должны быть простыми (KISS).
- **Кодогенерация и шаблоны:** иногда DRY достигают генерацией кода (например, OpenAPI -> Java client), но нужно следить за простотой генерируемых слоёв (KISS).

---

# Конфликт DRY ↔ KISS — как балансировать

- Если устранение дублирования приводит к **слишком общей, тяжело понимаемой абстракции**, предпочитайте небольшой дублирующийся фрагмент кода и сохраняйте ясность (KISS). Затем, когда появится реальная необходимость (два повторения — первый сигнал, но не приговор), рефакторьте в общую абстракцию.
- Делайте **рефакторинг шагами**: сначала выделите общие части, покройте тестами, затем вынесите абстракцию. Тесты — главный инструмент безопасности.
- Используйте **внутренние библиотеки** (shared modules) для истинного общего знания, но следите, чтобы они имели маленький и простой API (KISS).
- Обсуждайте архитектурные изменения с командой: иногда абстракция нужна для будущих расширений (OCP), но не всегда — решение должно быть обосновано.

---

# Тонкости и «подводные камни», которые стоит упомянуть на собеседовании

1. **Premature abstraction** — частая ошибка: люди вынуждают систему подстраиваться под абстракцию, а не наоборот. Покажите пример, как вы проверяете необходимость абстракции (сколько мест повторяется, есть ли тесты, ожидается ли несколько реализаций).  
2. **Тестируемость как аргумент за DRY:** единая логика упрощает создание unit-тестов; но иногда тесты лучше читаются с небольшим дублированием.  
3. **KISS и производительность:** упрощение кода не должно приносить значительную деградацию производительности в горячих путях. Всегда можно профилировать и оптимизировать локально.  
4. **API-совместимость:** при выносе общей логики в библиотеку учитывайте backward compatibility — изменяя общую библиотеку, вы можете сломать много клиентов. Здесь важны semantic versioning и CI.  
5. **Документирование абстракций:** когда вы выносите общую логику — документируйте контракт, ограничения и ожидаемое поведение (JavaDoc), чтобы избежать неправильного использования.  
6. **Семантические различия:** похожие, но не одинаковые случаи не следует объединять в одну абстракцию — это приводит к «пропускам» и багам.  
7. **Code reviews & linters:** внедряйте правила (код-ревью, статические анализаторы), которые выявляют копипаст и излишнюю сложность.  

---

# Как это говорить на собеседовании (ключевые тезисы)

- DRY: «Я ищу повторяющееся знание, а не только повторение строк. Если вижу копипаст — сначала добавляю тесты, затем выношу общую логику в компонент/библиотеку. Но я избегаю преждевременных абстракций.»  
- KISS: «Я предпочитаю понятные решения. Если требуемая функциональность проста — не усложняю архитектуру. Для критичных кейсов применяю простые шаблоны: маленькие методы, явные зависимости, избегаю флагов поведения.»  
- Баланс: «DRY и KISS — оба важны. Я предпочитаю маленькую проблему решить простым дублированием, но если дублирование растёт — рефакторю в чистую абстракцию и покрываю тестами.»  
- Примеры: расскажите из опыта: «Мы вынесли общий валидатор/код доступа в shared module и избежали рассинхронизации правил.» Или: «Я видел проект, где ради DRY сделали одну супер-утилиту с 50 параметрами — это убило читаемость; мы откатились и сделали 3 простые функции.»  

---

# Итог / резюме (шпаргалка для интервью)

- DRY = не дублируй знание: вынеси правила/константы/функции в одно место; используй shared modules. Но не абстрагируй преждевременно.  
- KISS = держи всё простым и понятным: маленькие методы, явные зависимости, избегание флагов поведения и глубокой вложенности.  
- Баланс — критичен: иногда небольшое дублирование лучше, чем сложная абстракция; но если повторение растёт — рефакторь.  
- Практические техники: dependency injection, модульность (maven/gradle), code reviews, unit tests, небольшие классы и интерфейсы, документирование абстракций.

---




