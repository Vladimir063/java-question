[Вопросы для собеседования](README.md)

# Шаблоны проектирования
+ [Что такое _«шаблон проектирования»_?](#Что-такое-шаблон-проектирования)
+ [Назовите основные характеристики шаблонов.](#Назовите-основные-характеристики-шаблонов)
+ [Типы шаблонов проектирования.](#Типы-шаблонов-проектирования)
+ [Приведите примеры основных шаблонов проектирования.](#Приведите-примеры-основных-шаблонов-проектирования)
+ [Приведите примеры порождающих шаблонов проектирования.](#Приведите-примеры-порождающих-шаблонов-проектирования)
+ [Приведите примеры структурных шаблонов проектирования.](#Приведите-примеры-структурных-шаблонов-проектирования)
+ [Приведите примеры поведенческих шаблонов проектирования.](#Приведите-примеры-поведенческих-шаблонов-проектирования)
+ [Что такое _«антипаттерн»_? Какие антипаттерны вы знаете?](#Что-такое-антипаттерн-Какие-антипаттерны-вы-знаете)
+ [Что такое _Dependency Injection_?](#Что-такое-dependency-injection)

## Что такое _«шаблон проектирования»_?
__Шаблон (паттерн) проектирования (design pattern)__ — это проверенное и готовое к использованию решение. Это не класс и не библиотека, которую можно подключить к проекту, это нечто большее - он не зависит от языка программирования, не является законченным образцом, который может быть прямо преобразован в код и может быть реализован по-разному в разных языках программирования.

Плюсы использования шаблонов:
+ снижение сложности разработки за счёт готовых абстракций для решения целого класса проблем.
+ облегчение коммуникации между разработчиками, позволяя ссылаться на известные шаблоны.
+ унификация деталей решений: модулей и элементов проекта.
+ возможность отыскав удачное решение, пользоваться им снова и снова.
+ помощь в выборе выбрать наиболее подходящего варианта проектирования.

Минусы:
+ слепое следование некоторому выбранному шаблону может привести к усложнению программы.
+ желание попробовать некоторый шаблон в деле без особых на то оснований.

[к оглавлению](#Шаблоны-проектирования)

## Назовите основные характеристики шаблонов.
+ __Имя__ - все шаблоны имеют уникальное имя, служащее для их идентификации;
+ __Назначение__	назначение данного шаблона;
+ __Задача__ - задача, которую шаблон позволяет решить;
+ __Способ решения__ - способ, предлагаемый в шаблоне для решения задачи в том контексте, где этот шаблон был найден;
+ __Участники__	- сущности, принимающие участие в решении задачи;
+ __Следствия__	- последствия от использования шаблона как результат действий, выполняемых в шаблоне;
+ __Реализация__ - возможный вариант реализации шаблона.

[к оглавлению](#Шаблоны-проектирования)

## Типы шаблонов проектирования.
+ Основные (Fundamental) - основные строительные блоки других шаблонов. Большинство других шаблонов использует эти шаблоны в той или иной форме.
+ Порождающие шаблоны (Creational) — шаблоны проектирования, которые абстрагируют процесс создание экземпляра. Они позволяют сделать систему независимой от способа создания, композиции и представления объектов. Шаблон, порождающий классы, использует наследование, чтобы изменять созданный объект, а шаблон, порождающий объекты, делегирует создание объектов другому объекту.
+ Структурные шаблоны (Structural) определяют различные сложные структуры, которые изменяют интерфейс уже существующих объектов или его реализацию, позволяя облегчить разработку и оптимизировать программу.
+ Поведенческие шаблоны (Behavioral) определяют взаимодействие между объектами, увеличивая таким образом его гибкость.

[к оглавлению](#Шаблоны-проектирования)

## Приведите примеры основных шаблонов проектирования.
+ __Делегирование (Delegation pattern)__ - Сущность внешне выражает некоторое поведение, но в реальности передаёт ответственность за выполнение этого поведения связанному объекту.
+ __Функциональный дизайн (Functional design)__ - Гарантирует, что каждая сущность имеет только одну обязанность и исполняет её с минимумом побочных эффектов на другие.
+ __Неизменяемый интерфейс (Immutable interface)__ - Создание неизменяемого объекта.
+ __Интерфейс (Interface)__ - Общий метод структурирования сущностей, облегчающий их понимание. 
+ __Интерфейс-маркер (Marker interface)__ - В качестве атрибута (как пометки объектной сущности) применяется наличие или отсутствие реализации интерфейса-маркера. В современных языках программирования вместо этого применяются атрибуты или аннотации.
+ __Контейнер свойств (Property container)__ - Позволяет добавлять дополнительные свойства сущности в контейнер внутри себя, вместо расширения новыми свойствами.
+ __Канал событий (Event channel)__ - Создаёт централизованный канал для событий. Использует сущность-представитель для подписки и сущность-представитель для публикации события в канале. Представитель существует отдельно от реального издателя или подписчика. Подписчик может получать опубликованные события от более чем одной сущности, даже если он зарегистрирован только на одном канале.

[к оглавлению](#Шаблоны-проектирования)

## Приведите примеры порождающих шаблонов проектирования.
+ __Абстрактная фабрика (Abstract factory)__ - Класс, который представляет собой интерфейс для создания других классов.
+ __Строитель (Builder)__ - Класс, который представляет собой интерфейс для создания сложного объекта.
+ __Фабричный метод (Factory method)__ - Делегирует создание объектов наследникам родительского класса. Это позволяет использовать в коде программы не специфические классы, а манипулировать абстрактными объектами на более высоком уровне.
+ __Прототип (Prototype)__ - Определяет интерфейс создания объекта через клонирование другого объекта вместо создания через конструктор.
+ __Одиночка (Singleton)__ - Класс, который может иметь только один экземпляр.

[к оглавлению](#Шаблоны-проектирования)

## Приведите примеры структурных шаблонов проектирования.
+ __Адаптер (Adapter)__ - Объект, обеспечивающий взаимодействие двух других объектов, один из которых использует, а другой предоставляет несовместимый с первым интерфейс. 
+ __Мост (Bridge)__ - Структура, позволяющая изменять интерфейс обращения и интерфейс реализации класса независимо. 
+ __Компоновщик (Composite)__ - Объект, который объединяет в себе объекты, подобные ему самому. 
+ __Декоратор (Decorator)__ - Класс, расширяющий функциональность другого класса без использования наследования. 
+ __Фасад (Facade)__ - Объект, который абстрагирует работу с несколькими классами, объединяя их в единое целое. 
+ __Приспособленец (Flyweight)__ - Это объект, представляющий себя как уникальный экземпляр в разных местах программы, но по факту не являющийся таковым. 
+ __Заместитель (Proxy)__ - Объект, который является посредником между двумя другими объектами, и который реализует/ограничивает доступ к объекту, к которому обращаются через него.

[к оглавлению](#Шаблоны-проектирования)

## Приведите примеры поведенческих шаблонов проектирования.
+ __Цепочка обязанностей (Chain of responsibility)__ - Предназначен для организации в системе уровней ответственности.
+ __Команда (Command)__ - Представляет действие. Объект команды заключает в себе само действие и его параметры.
+ __Интерпретатор (Interpreter)__ - Решает часто встречающуюся, но подверженную изменениям, задачу.
+ __Итератор (Iterator)__ - Представляет собой объект, позволяющий получить последовательный доступ к элементам объекта-агрегата без использования описаний каждого + __из объектов, входящих в состав агрегации.
+ __Посредник (Mediator)__ - Обеспечивает взаимодействие множества объектов, формируя при этом слабую связанность и избавляя объекты от необходимости явно ссылаться друг на друга.
+ __Хранитель (Memento)__ - Позволяет, не нарушая инкапсуляцию зафиксировать и сохранить внутренние состояния объекта так, чтобы позднее восстановить его в этих состояниях.
+ __Наблюдатель (Observer)__ - Определяет зависимость типа «один ко многим» между объектами таким образом, что при изменении состояния одного объекта все зависящие от него оповещаются об этом событии.
+ __Состояние (State)__ - Используется в тех случаях, когда во время выполнения программы объект должен менять своё поведение в зависимости от своего состояния.
+ __Стратегия (Strategy)__ - Предназначен для определения семейства алгоритмов, инкапсуляции каждого из них и обеспечения их взаимозаменяемости.
+ __Шаблонный метод (Template method)__ - Определяет основу алгоритма и позволяет наследникам переопределять некоторые шаги алгоритма, не изменяя его структуру в целом.
+ __Посетитель (Visitor)__ - Описывает операцию, которая выполняется над объектами других классов. При изменении класса Visitor нет необходимости изменять обслуживаемые классы.

[к оглавлению](#Шаблоны-проектирования)

## Что такое _«антипаттерн»_? Какие антипаттерны вы знаете?
__Антипаттерн (anti-pattern)__ — это распространённый подход к решению класса часто встречающихся проблем, являющийся неэффективным, рискованным или непродуктивным.

__Poltergeists (полтергейсты)__ - это классы с ограниченной ответственностью и ролью в системе, чьё единственное предназначение — передавать информацию в другие классы. Их эффективный жизненный цикл непродолжителен. Полтергейсты нарушают стройность архитектуры программного обеспечения, создавая избыточные (лишние) абстракции, они чрезмерно запутанны, сложны для понимания и трудны в сопровождении. Обычно такие классы задумываются как классы-контроллеры, которые существуют только для вызова методов других классов, зачастую в предопределенной последовательности.

Признаки появления и последствия антипаттерна
+ Избыточные межклассовые связи.
+ Временные ассоциации.
+ Классы без состояния (содержащие только методы и константы).
+ Временные объекты и классы (с непродолжительным временем жизни).
+ Классы с единственным методом, который предназначен только для создания или вызова других классов посредством временной ассоциации.
+ Классы с именами методов в стиле «управления», такие как startProcess.

Типичные причины
+ Отсутствие объектно-ориентированной архитектуры (архитектор не понимает объектно-ориентированной парадигмы).
+ Неправильный выбор пути решения задачи.
+ Предположения об архитектуре приложения на этапе анализа требований (до объектно-ориентированного анализа) могут также вести к проблемам на подобии этого антипаттерна.

__Внесенная сложность (Introduced complexity)__: Необязательная сложность дизайна. Вместо одного простого класса выстраивается целая иерархия интерфейсов и классов. Типичный пример «Интерфейс - Абстрактный класс - Единственный класс реализующий интерфейс на основе абстрактного».

__Инверсия абстракции (Abstraction inversion)__: Сокрытие части функциональности от внешнего использования, в надежде на то, что никто не будет его использовать.

__Неопределённая точка зрения (Ambiguous viewpoint)__: Представление модели без спецификации её точки рассмотрения.

__Большой комок грязи (Big ball of mud)__: Система с нераспознаваемой структурой.

__Божественный объект (God object)__: Концентрация слишком большого количества функций в одной части системы (классе).

__Затычка на ввод данных (Input kludge)__: Забывчивость в спецификации и выполнении поддержки возможного неверного ввода.

__Раздувание интерфейса (Interface bloat)__: Разработка интерфейса очень мощным и очень сложным для реализации.

__Волшебная кнопка (Magic pushbutton)__: Выполнение результатов действий пользователя в виде неподходящего (недостаточно абстрактного) интерфейса. Например, написание прикладной логики в обработчиках нажатий на кнопку.

__Перестыковка (Re-Coupling)__: Процесс внедрения ненужной зависимости.

__Дымоход (Stovepipe System)__: Редко поддерживаемая сборка плохо связанных компонентов.

__Состояние гонки (Race hazard)__: непредвидение возможности наступления событий в порядке, отличном от ожидаемого.

__Членовредительство (Mutilation)__: Излишнее «затачивание» объекта под определенную очень узкую задачу таким образом, что он не способен будет работать с никакими иными, пусть и очень схожими задачами.

__Сохранение или смерть (Save or die)__: Сохранение изменений лишь при завершении приложения.

[к оглавлению](#Шаблоны-проектирования)

## Что такое _Dependency Injection_?
__Dependency Injection (внедрение зависимости)__ - это набор паттернов и принципов разработки програмного обеспечения, которые позволяют писать слабосвязный код. В полном соответствии с принципом единой обязанности объект отдаёт заботу о построении требуемых ему зависимостей внешнему, специально предназначенному для этого общему механизму.

[к оглавлению](#Шаблоны-проектирования)
# Введение — что такое **порождающие (creational)** паттерны
Порождающие паттерны проектирования решают, **как правильно создавать объекты**. Они помогают отделить логику создания от использования, делают код гибче, проще для тестирования и расширения. На собеседовании от вас ожидают не только определения, но и понимание **когда** и **почему** применять каждый паттерн, плюсы/минусы и практические примеры.

Ниже — подробные объяснения (простым языком), реальные сценарии и готовые Java-примеры с подробными комментариями на русском. После каждого блока — полностью рабочий пример в одном файле (один public класс + вспомогательные), чтобы вы могли скопировать и вставить в IDE.

---

# 1. Фабрика (Simple Factory) и Фабричный метод (Factory Method)
### Идея (простыми словами)
- **Simple Factory** — это просто класс/метод, который создаёт объекты разных типов по входным параметрам. Неофициальный паттерн (не в GOF), но часто используется.
- **Factory Method** — переопределяемый метод (обычно в абстрактном классе или интерфейсе), который делегирует создание конкретных объектов подклассам. Это официальный GOF-паттерн.

### Когда и зачем использовать
- Нужна централизованная логика создания объектов (когда создание — не тривиально).
- Когда нужно скрыть конкретные классы от клиента (инверсия зависимостей).
- Когда требуется расширяемость: добавление нового продукта не должно ломать код клиента.
- Simple Factory — подходит для небольших случаев; Factory Method — при потребности в расширяемости через наследование.

### Плюсы / минусы
+ Снижает связанность кода (client не знает конкретных классов).  
+ Упрощает замену/добавление новых типов.  
− Может привести к большому числу классов (особенно Factory Method).  
− Simple Factory может стать «God class», если он слишком большой.

### Пример: Factory Method — транспорт (road/ship/air)
```java
// FactoryMethodDemo.java
// Простой демонстрационный пример паттерна Factory Method.
// Все классы находятся в одном файле для удобства копирования в IDE.
// Public-класс соответствует имени файла.

// Добавлены аннотации Lombok для демонстрации их использования (хотя в простых классах Lombok не обязателен).
import lombok.NoArgsConstructor;
import lombok.ToString;

public class FactoryMethodDemo {
    public static void main(String[] args) {
        // Клиент работает с создателем, не зная конкретного транспорта.
        Creator roadCreator = new RoadLogistics();
        Transport t1 = roadCreator.createTransport();
        t1.deliver();

        Creator seaCreator = new SeaLogistics();
        Transport t2 = seaCreator.createTransport();
        t2.deliver();

        // Добавление нового транспорта = добавление нового класса Creator + Product,
        // клиентский код не изменяется.
    }
}

// --- Product интерфейс ---
interface Transport {
    void deliver(); // метод для доставки
}

// --- Concrete Products ---
@NoArgsConstructor
@ToString
class Truck implements Transport {
    @Override
    public void deliver() {
        // Конкретная реализация доставки для грузовика
        System.out.println("Доставка грузовиком по дороге");
    }
}

@NoArgsConstructor
@ToString
class Ship implements Transport {
    @Override
    public void deliver() {
        System.out.println("Доставка кораблем по морю");
    }
}

// --- Creator (абстрактный) ---
abstract class Creator {
    // Фабричный метод — возвращает интерфейс Transport.
    // Подклассы решают, какой конкретно транспорт создать.
    public abstract Transport createTransport();

    // Допустим у Creator есть общая логика:
    public void planDelivery() {
        Transport transport = createTransport();
        // общая логика использования продукта
        System.out.println("Планирование доставки...");
        transport.deliver();
    }
}

// --- Concrete Creators ---
@NoArgsConstructor
class RoadLogistics extends Creator {
    @Override
    public Transport createTransport() {
        // можно добавить логику выбора конфигурации Truck
        return new Truck();
    }
}

@NoArgsConstructor
class SeaLogistics extends Creator {
    @Override
    public Transport createTransport() {
        return new Ship();
    }
}
```

---

# 2. Абстрактная фабрика (Abstract Factory)
### Идея (простыми словами)
Абстрактная фабрика предоставляет интерфейс для создания **семейств связанных объектов** (например, виджеты для разных платформ), не указывая их конкретных классов. Это удобно, когда объекты должны работать вместе (совместимы по интерфейсу/стилю).

### Когда и зачем использовать
- Когда нужно создать семейства взаимосвязанных объектов (например, темы UI — кнопка + чекбокс + поле ввода).
- Когда важно, чтобы продукты одного семейства были совместимы.
- Когда нужно менять семейство продуктов во время выполнения (поддержка тем/платформ).

### Плюсы / минусы
+ Хорошо обеспечивает единообразие продуктов (семейства совместимы).  
+ Упрощает замену семейства продуктов целиком.  
− Усложняет добавление новых типов продуктов (добавая новый продукт — нужно изменить интерфейсы/все фабрики).

### Пример: семейства виджетов (Windows / Mac)
```java
// AbstractFactoryDemo.java
// Демонстрация Abstract Factory на примере UI-виджетов (Button + Checkbox).
// Все классы в одном файле для удобного копирования.

// Добавлены аннотации Lombok (@ToString) для демонстрации, где это уместно.
import lombok.ToString;

public class AbstractFactoryDemo {
    public static void main(String[] args) {
        UIFactory factory = new WindowsFactory();
        Button winButton = factory.createButton();
        Checkbox winCheckbox = factory.createCheckbox();
        winButton.paint();
        winCheckbox.paint();

        // Теперь сменим семью на Mac
        UIFactory macFactory = new MacFactory();
        macFactory.createButton().paint();
        macFactory.createCheckbox().paint();
    }
}

// --- Abstract Products ---
interface Button {
    void paint();
}

interface Checkbox {
    void paint();
}

// --- Concrete Products for Windows ---
@ToString
class WindowsButton implements Button {
    @Override
    public void paint() {
        System.out.println("Рисуем кнопку в стиле Windows");
    }
}

@ToString
class WindowsCheckbox implements Checkbox {
    @Override
    public void paint() {
        System.out.println("Рисуем чекбокс в стиле Windows");
    }
}

// --- Concrete Products for Mac ---
@ToString
class MacButton implements Button {
    @Override
    public void paint() {
        System.out.println("Рисуем кнопку в стиле Mac");
    }
}

@ToString
class MacCheckbox implements Checkbox {
    @Override
    public void paint() {
        System.out.println("Рисуем чекбокс в стиле Mac");
    }
}

// --- Abstract Factory ---
interface UIFactory {
    Button createButton();
    Checkbox createCheckbox();
}

// --- Concrete Factories ---
class WindowsFactory implements UIFactory {
    @Override
    public Button createButton() { return new WindowsButton(); }
    @Override
    public Checkbox createCheckbox() { return new WindowsCheckbox(); }
}

class MacFactory implements UIFactory {
    @Override
    public Button createButton() { return new MacButton(); }
    @Override
    public Checkbox createCheckbox() { return new MacCheckbox(); }
}
```

---

# 3. Builder (Строитель)
### Идея (простыми словами)
Builder отделяет процесс построения сложного объекта от его представления. Особенно полезен, когда конструктор класса принимает много параметров (особенно опциональных), и хочется избежать "конструкторского ада" (много конструкторов с разными комбинациями параметров).

### Когда и зачем использовать
- Объект имеет много полей (часто опциональных).
- Нужна читабельная и безопасная конструкция (иммутабельность).
- Требуется пошаговая конфигурация и валидация перед созданием.
- Полезен в DSL-подходе (цепочки вызовов).

### Плюсы / минусы
+ Улучшает читаемость кода при создании сложных объектов.  
+ Позволяет делать объект immutable.  
− Небольшой дополнительный код (класс Builder), но обычно оправдан.

### Пример: построение объекта `User` с множеством опциональных полей
```java
// BuilderDemo.java
// Пример паттерна Builder на классе User.
// Внутри статический вложенный Builder: класс User становится иммутабельным.

// Здесь заменяем ручной Builder на Lombok @Builder для сокращения кода.
// Lombok сгенерирует класс Builder автоматически, а также геттеры и toString.
import lombok.Builder;
import lombok.Getter;
import lombok.ToString;

public class BuilderDemo {
    public static void main(String[] args) {
        // Пример использования билдера.
        User user = User.builder()
                .email("ivan@example.com") // обязательное поле
                .firstName("Иван")
                .lastName("Иванов")
                .age(35)
                .phone("+7-900-123-45-67")
                .build();

        System.out.println(user);
    }
}

@Getter
@ToString
@Builder
final class User {
    // обязательное
    private final String email;
    // опциональные
    private final String firstName;
    private final String lastName;
    private final Integer age;
    private final String phone;
}
```

---

# 4. Singleton (Одиночка)
### Идея (простыми словами)
Паттерн обеспечивает наличие **только одного экземпляра** класса и глобальную точку доступа к нему.

### Когда и зачем использовать
- Нужно глобальное, совместно используемое состояние (например, конфигурация приложения, пул соединений, логгер).  
- Важно, чтобы экземпляр был один в рамках JVM.

### Важно на интервью
- Обсуждают проблемы многопоточности и сериализации.
- Покажите разные реализации (eager, lazy с double-check, Enum) и объясните плюсы/минусы.

### Плюсы / минусы
+ Удобен для глобального состояния.  
− Может стать глобальной переменной (anti-pattern) — усложняет тестирование (мокирование).  
− Ошибки при сериализации, клонировании и многопоточности — нужно быть аккуратным.

### Примеры: Eager, Lazy (Double-checked), Enum
```java
// SingletonDemo.java
// Три варианта реализации Singleton — в одном файле для демонстрации.
// В реальном проекте выберите один подход (часто рекомендуют enum-одиночку).

// Lombok можно использовать для генерации геттеров/логирования, например @Getter или @Slf4j.
// Здесь добавим @Getter в качестве примера.
import lombok.Getter;

public class SingletonDemo {
    public static void main(String[] args) {
        System.out.println("Eager: " + EagerSingleton.getInstance());
        System.out.println("LazyDCL: " + LazyDCLSingleton.getInstance());
        System.out.println("Enum: " + EnumSingleton.INSTANCE);

        // Проверка, что ссылки одинаковы
        System.out.println("Eager same? " + (EagerSingleton.getInstance() == EagerSingleton.getInstance()));
        System.out.println("LazyDCL same? " + (LazyDCLSingleton.getInstance() == LazyDCLSingleton.getInstance()));
        System.out.println("Enum same? " + (EnumSingleton.INSTANCE == EnumSingleton.INSTANCE));
    }
}

// --- Eager initialization (простая и потокобезопасная при загрузке класса) ---
@Getter
class EagerSingleton {
    // Экземпляр создаётся при загрузке класса
    private static final EagerSingleton INSTANCE = new EagerSingleton();

    // Приватный конструктор — нельзя создать извне
    private EagerSingleton() {}

    public static EagerSingleton getInstance() {
        return INSTANCE;
    }
}

// --- Lazy initialization с double-checked locking (DCL) ---
@Getter
class LazyDCLSingleton {
    // volatile важен для корректности double-checked locking
    private static volatile LazyDCLSingleton instance;

    private LazyDCLSingleton() {}

    public static LazyDCLSingleton getInstance() {
        // Сначала без синхронизации (быстрая проверка)
        if (instance == null) {
            synchronized (LazyDCLSingleton.class) {
                // Проверяем ещё раз внутри synchronized
                if (instance == null) {
                    instance = new LazyDCLSingleton();
                }
            }
        }
        return instance;
    }
}

// --- Enum singleton (лучший вариант в большинстве случаев) ---
enum EnumSingleton {
    INSTANCE; // единственный экземпляр

    // Можно хранить состояние и методы
    public void doSomething() {
        System.out.println("EnumSingleton doing something");
    }
}
```

**Рекомендация:** в большинстве случаев `enum`-singleton — самый безопасный и простой способ, потому что он автоматически защищён от проблем с сериализацией и отражением (reflection).

---

# 5. Prototype (Прототип)
### Идея (простыми словами)
Prototype — создаём новые объекты путём клонирования (копирования) существующего экземпляра-прототипа. Удобно, когда создание объекта «дорогое» (сложная инициализация), либо когда нужно быстро получить копию с небольшими изменениями.

### Когда и зачем использовать
- Стоимость создания нового объекта высокая (ресурсоёмкая инициализация).
- Нужно много схожих объектов, которые отличаются небольшими деталями.
- Желание получать копии без знания точного конкретного класса (через интерфейс clone).

### Важные нюансы в Java
- `Cloneable` и метод `clone()` — исторически спорны (поведение дефолтного `Object.clone()` делает поверхностное копирование).
- Для глубокого копирования часто нужно вручную клонировать вложенные объекты или использовать сериализацию/копирующие конструкторы.
- На интервью можно показать и `clone()` и альтернативный способ — копирующий конструктор/фабрика копий.

### Пример: shallow & deep clone
```java
// PrototypeDemo.java
// Демонстрация shallow и deep clone на объекте Document, содержащем Metadata.
// Используем Cloneable для примера, и также покажем копирующий конструктор для deep copy.

// Lombok используется для сокращения шаблонного кода (геттеры/сеттеры/toString)
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

public class PrototypeDemo {
    public static void main(String[] args) throws CloneNotSupportedException {
        Metadata meta = new Metadata("Иван", "2025-09-06");
        Document original = new Document("Отчёт", "Тело отчёта", meta);

        // shallow clone (через clone) — metadata будет общим (shared reference)
        Document shallow = original.clone();
        System.out.println("original metadata author: " + original.getMetadata().getAuthor());
        System.out.println("shallow metadata author:  " + shallow.getMetadata().getAuthor());

        // Изменим метаданные в shallow
        shallow.getMetadata().setAuthor("Пётр");
        System.out.println("После изменения shallow:");
        System.out.println("original metadata author: " + original.getMetadata().getAuthor()); // изменилось — демонстрация shallow

        // Deep clone через копирующий конструктор
        Document deep = new Document(original); // copy constructor
        deep.getMetadata().setAuthor("Мария");
        System.out.println("После изменения deep:");
        System.out.println("original metadata author: " + original.getMetadata().getAuthor()); // не изменилось
    }
}

@Data
@NoArgsConstructor
@AllArgsConstructor
class Metadata implements Cloneable {
    private String author;
    private String date;

    @Override
    protected Metadata clone() throws CloneNotSupportedException {
        // Для метаданных shallow clone достаточно (если все поля примитивы/immutable).
        return (Metadata) super.clone();
    }
}

@Data
class Document implements Cloneable {
    private String title;
    private String body;
    private Metadata metadata;

    public Document(String title, String body, Metadata metadata) {
        this.title = title;
        this.body = body;
        this.metadata = metadata;
    }

    // Копирующий конструктор для deep copy
    public Document(Document other) {
        this.title = other.title;
        this.body = other.body;
        // Для глубокого копирования создаём новый объект Metadata (который клонируем)
        try {
            this.metadata = other.metadata.clone();
        } catch (CloneNotSupportedException e) {
            // fallback — создать вручную
            this.metadata = new Metadata(other.metadata.getAuthor(), other.metadata.getDate());
        }
    }

    @Override
    protected Document clone() throws CloneNotSupportedException {
        // По умолчанию суперкласс делает поверхностное копирование
        return (Document) super.clone();
    }

    // геттер для metadata
    public Metadata getMetadata() { return metadata; }
}
```

**Практический совет:** на интервью можно сказать, что `Cloneable` в Java спорен, и предпочитаете контролируемое копирование (копирующие конструкторы / фабрики), особенно для глубокого копирования.

---

# Заключение — как выбирать паттерн
- Нужен один глобальный экземпляр → **Singleton** (с осторожностью; лучше enum).
- Нужна простая централизация создания → **Simple Factory**.
- Требуется расширяемость создания через подклассы → **Factory Method**.
- Нужна гибкая смена семейства совместимых продуктов → **Abstract Factory**.
- Объект создаётся с большим количеством опций / хотите immutable → **Builder**.
- Нужно клонирование/быстро создавать похожие объекты / избежать дорогой инициализации → **Prototype** (предпочтительно через контролируемые копии).

---

Если хочешь, могу:
- Написать JUnit-тесты для каждого примера.
- Переписать примеры под Spring/DI (например, показать как Singleton-паттерн реализуется через Spring Bean scope).
- Сделать одно обобщённое PDF-шпаргалку для собеседования (готовый файл, который можно распечатать).

Напиши, что из этого нужно — и я сделаю прямо здесь.


[Вопросы для собеседования](README.md)
