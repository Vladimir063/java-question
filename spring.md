[Вопросы для собеседования](README.md)

Про транзакции подробно: http://akorsa.ru/2016/08/kak-na-samom-dele-rabotaet-transactional-spring/

# SPRING
+ [Что такое Spring?](#Что-такое-spring)
+ [Особенности и преимущества Spring Framework?](#Особенности-и-преимущества-spring-framework)
+ [Spring контейнеры](#Spring-контейнеры)
+ [Жизненный цикл Context](#Жизненный-цикл-context)
+ [Как завершить работу контекста](#Как-завершить-работу-контекста)
+ [Bean](#Bean)
+ [Жизненный цикл бинов](#Жизненный-цикл-бинов)
+ [Как настроить класс как Spring Bean](#Как-настроить-класс-как-spring-bean)
+ [Статический Bean](#Статический-bean)
+ [Inversion of Control](#Inversion-of-control)
+ [Dependency Injection (DI)](#Dependency-injection)
+ [Как реализуется DI в Spring Framework?](#Как-реализуется-di-в-spring-framework)
+ [Связывание и @Autowired](#Связывание-и-@Autowired)
+ [MVC](#mvc)
+ [Шаблон проектирования Front Controller](#Шаблон-проектирования-Front-Controller)
+ [Связывание форм](#Связывание-форм)
+ [Исключения в Spring MVC](#Исключения-spring-mvc)
+ [Локализация в приложениях Spring MVC](#Локализация-в-приложениях-spring-mvc)
+ [Spring Interceptor](#Spring-interceptor)
+ [CommandLineRunner и ApplicationRunner](#CommandLineRunner-и-ApplicationRunner)
+ [Реактивное программирование](#Реактивное-программирование)
+ [Паттерны в Spring Framework](#Паттерны-в-spring-framework)
+ [AOP и составные части](#AOP-и-составные-части)
+ [Spring AOP vs ASPECTJ](#Spring-aop-vs-aspectj)
+ [Некоторые частые аннотации Spring](#Некоторые-частые-аннотации-spring) 
+ [Различия @Component, @Service, @Repository, @Controller](#Различия-component-service-repository-controller)
+ [Различия @Controller и @RestController](#Различия-controller-и-rRestController)
+ [@Qualifier and @Primary](#@Qualifier-and-@Primary)
+ [@Profile](#Profile)
+ [@LookUp](#LookUp)
+ [@Target и @Retention](#@Target-и-@Retention)
+ [@Resource](#@Resource)
+ [@Inject](#@Inject)
+ [@Autowired vs @Resource vs @Inject](#@Autowired-vs-resource-vs-inject)
+ [@Conditional](#@Conditional)
+ [Как управлять транзакциями в Spring](#Как-управлять-транзакциями-в-spring)
+ [Как Spring работает с DAO](#Как-spring-работает-с-dao)
+ [Model vs ModelMap vs ModelAndView](#Model-vs-modelMap-vs-modelAndView)
+ [В чем разница между model.put() и model.addAttribute()?](#В-чем-разница-между-model.put()-и-model.addAttribute())
+ [PreparedStatementCreator](#PreparedStatementCreator)
+ [SOAP vs REST](#SOAP-vs-REST)
+ [Spring Data](#Spring-data)
+ [Конфигурация Spring Data](#Конфигурация-Spring-data)
+ [Spring Security](#Spring-security)
+ [Spring Boot](#Spring-boot)
+ [Starter packs](#Starter-packs)
+ [Как внедрить java.util.Properties в Spring Bean](#Как-внедрить-java.util.Properties-в-spring-bean)
+ [Что нового в Spring 5](#Что-нового-в-spring-5)
+ [RestTemplate и JDBCTemplate](#RestTemplate-и-JDBCTemplate)
+ [Socket](#Socket)

## Что такое Spring
Spring - фреймворк с открытым исходным кодом, предназначеный для упрощения разработки enterprise-приложений. Одним из главным преимуществом Spring является его слоистая архитектура, позволяющая вам самим определять какие компоненты будут использованы в вашем приложении. Модули Spring построены на базе основного контейнера, который определяет создание, конфигурация и менеджмент бинов.

Основные фраймворки внутри Springa:
+ Основной контейнер (Beans, Core, Context, SpEL) - предоставляет основной функционал Spring, управляющий процессом создания и настройки компонентов приложения. Beans отвечает за BeanFactory которая является сложной реализацией паттерна Фабрика (GoF). Модуль __Core__ обеспечивает ключевые части фреймворка, включая свойства IoC и DI. __Context__ построен на основе Beans и Core и позволяет получить доступ к любому объекту, который определён в настройках. Ключевым элементом модуля Context является интерфейс ApplicationContext. Модуль __SpEL__ обеспечивает мощный язык выражений для манипулирования объектами во время исполнения. В нем есть тернатрные, арефметические, логические операторы. Может получить доступ к элементам коллекций.
+ Spring AOP (AOP, Aspects) - отвечает за интеграцию аспектно-ориентированного программирования во фреймворк. Spring AOP обеспечивает сервис управления транзакциями для Spring-приложения.
+ Spring Data — дополнительный удобный механизм для взаимодействия с сущностями базы данных, организации их в репозитории, извлечение данных, изменение, в каких то случаях для этого будет достаточно объявить интерфейс и метод в нем, без имплементации. Например с использованием JPA. Состоит из JDBC, ORM, OXM, JMS и модуля Transatcions. JDBC обеспечивает абстрактный слой JDBC и избавляет разработчика от необходимости вручную прописывать монотонный код, связанный с соединением с БД. ORM обеспечивает интеграцию с такими популярными ORM, как Hibernate, JDO, JPA и т.д. Модуль OXM отвечает за связь Объект/XML – XMLBeans, JAXB и т.д. Модуль JMS (Java Messaging Service) отвечает за создание, передачу и получение сообщений. Transactions поддерживает управление транзакциями для классов, которые реализуют определённые методы.
+ Spring Web module (Web, Servlet, Portlet, Struts) - Модуль Web обеспечивает такие функции, как загрузка файлов и т.д. Web-MVC содержит реализацию Spring MVC для веб-приложений. Web-Socket обеспечивает поддержку связи между клиентом и сервером, используя Web-Socket-ы в веб-приложениях. Web-Portlet обеспечивает реализацию MVC с среде портлетов.
+ Spring MVC framework - реализация паттерна MVC для построения Web-приложений.
+ Spring Integration - обеспечивает легкий обмен сообщениями в приложениях на базе Spring и поддерживает интеграцию с внешними системами через декларативные адаптеры. Эти адаптеры обеспечивают более высокий уровень абстракции по сравнению с поддержкой Spring для удаленного взаимодействия, обмена сообщениями и планирования. Основная цель Spring Integration - предоставить простую модель для построения корпоративных решений по интеграции, сохраняя при этом разделение задач, что важно для создания поддерживаемого, тестируемого кода.
+ Spring Cloud - инструменты для создания сложных топологий для потоковой и пакетной передачи данных.
+ Spring Batch - предоставляет многократно используемые функции, которые необходимы для обработки больших объемов записей, включая ведение журнала / трассировку, управление транзакциями, статистику обработки заданий, перезапуск заданий, пропуск и управление ресурсами. Он также предоставляет более продвинутые технические услуги и функции, которые позволят выполнять пакетные задания чрезвычайно большого объема и с высокой производительностью благодаря методам оптимизации и разделения. Простые и сложные пакетные задания большого объема могут использовать платформу с высокой степенью масштабируемости для обработки значительных объемов информации.
+ Spring Kafka - Проект Spring for Apache Kafka (spring-kafka) применяет основные концепции Spring для разработки решений для обмена сообщениями на основе Kafka. Он предоставляет «шаблон» в качестве высокоуровневой абстракции для отправки сообщений. Он также обеспечивает поддержку управляемых сообщениями POJO с @KafkaListener аннотациями и «контейнером слушателя». Эти библиотеки способствуют использованию инъекций зависимостей и декларативных. Во всех этих случаях вы увидите сходство с поддержкой JMS в Spring Framework и поддержкой RabbitMQ в Spring AMQP.
+ Spring Security - Фреймворк аутентификации и авторизации: конфигурируемый инструментарий процессов аутентификации и авторизации, поддерживающий много популярных и ставших индустриальными стандартами протоколов, инструментов, практик.
+ Тестирование - каркас, поддерживающий классы для написания модульных и интеграционных тестов.

[к оглавлению](#spring)

## Особенности и преимущества Spring Framework?
Spring Framework обеспечивает решения многих задач, с которыми сталкиваются Java-разработчики и организации, которые хотят создать информационную систему, основанную на платформе Java. Из-за широкой функциональности трудно определить наиболее значимые структурные элементы, из которых он состоит. Spring Framework не всецело связан с платформой Java Enterprise, несмотря на его масштабную интеграцию с ней, что является важной причиной его популярности.

Spring Framework, вероятно, наиболее известен как источник расширений (features), нужных для эффективной разработки сложных бизнес-приложений вне тяжеловесных программных моделей, которые исторически были доминирующими в промышленности. Ещё одно его достоинство в том, что он ввел ранее неиспользуемые функциональные возможности в сегодняшние господствующие методы разработки, даже вне платформы Java. Этот фреймворк предлагает последовательную модель и делает её применимой к большинству типов приложений, которые уже созданы на основе платформы Java. Считается, что Spring Framework реализует модель разработки, основанную на лучших стандартах индустрии, и делает её доступной во многих областях Java. 

Таким образом к достоинствам Spring можно отнести:
+ Относительная легкость в изучении и применении фреймворка в разработке и поддержке приложения.
+ Внедрение зависимостей (DI) и инверсия управления (IoC) позволяют писать независимые друг от друга компоненты, что дает преимущества в командной разработке, переносимости модулей и т.д..
+ Spring IoC контейнер управляет жизненным циклом Spring Bean и настраивается наподобие JNDI lookup (поиска).
+ Проект Spring содержит в себе множество подпроектов, которые затрагивают важные части создания софта, такие как вебсервисы, веб программирование, работа с базами данных, загрузка файлов, обработка ошибок и многое другое. Всё это настраивается в едином формате и упрощает поддержку приложения.

## Spring контейнеры
Container создаёт объекты, связывает их вместе, настраивает и управляет ими от создания до момента уничтожения. Spring Container получает инструкции какие объекты инстанциировать и как их конфигурировать через метаданные: __XML, Аннотации или Java код__ .

__Spring BeanFactory Container__ Это самый простой контейнер, который обеспечивает базовую поддержку DI и который основан на интерфейсе org.springframework.beans.factory.BeanFactory. Такие интерфейсы, как BeanFactoryAware и DisposableBean всё ещё присутствуют в Spring для обеспечения обратной совместимости.

Бины создаются при вызове метода getBean().

Наиболее часто используемая реализация интерфейса BeanFactory – XmlBeanFactory. XmlBeanFactory получает метаданные из конфигурационного XML файла и использует его для создания настроенного приложения или системы. BeanFactory обычно используется тогда, когда ресурсы ограничены (мобильные устройства). Поэтому, если ресурсы не сильно ограничены, то лучше использовать ApplicationContext.

__Spring ApplicationContext Container__  ApplicationContext является более сложным и более продвинутым Spring Container-ом. Наследует BeanFactory и так же загружает бины, связывает их вместе и конфигурирует их определённым образом. Но кроме этого, ApplicationContext обладает дополнительной функциональностью: общий механизм работы с ресурсами, распознание текстовых сообщений из файлов настройки и отображение событий, которые происходят в приложении различными способами. Этот контейнер определяется интерфейсом org.springframework.context.ApplicationContext.

Бины создаются при "поднятии" контекста все сразу. Если не указана стратегия инициализации.

Чаще всего используются следующие реализации AppicationContext:
+ FileSystemXmlApplicationContext - Загружает данные о бине из XML файла. При использовании этой реализации в конструкторе необходимо указать полный адрес конфигурационного файла.

+ ClassPathXmlApplicationContext - Этот контейнер также получает данные о бине из XML файла. Но в отличие от FileSystemApplicationContext, в этом случае необходимо указать относительный адрес конфигурационного файла (CLASSPATH).

+ AnnotationConfigApplicationContext — метаданные конфигурируются с помощью аннотаций прямо на классах.

+ WebApplicationContext — для веб-приложений

+ GenericGroovyApplicationContext - эта конфигурация работает по сути так же, как и Xml, только с Groovy-файлами. К тому же, GroovyApplicationContext нормально работает и с Xml-файлом. Принимает на вход строку с конфигурацией контекста. Чтением контекста в данном случае занимается класс GroovyBeanDefinitionReader.

Groovy — объектно-ориентированный язык программирования разработанный для платформы Java как альтернатива языку Java с возможностями Python, Ruby и Smalltalk. Groovy использует Java-подобный синтаксис с динамической компиляцией в JVM байт-код и напрямую работает с другим Java кодом и библиотеками. Язык может использоваться в любом Java проекте или как скриптовый язык.

При этом мы можем указать несколько файлов конфигурации Spring.

Отличия ApplicationContext и BeanFactory
1. ApplicationContext загружает все бины при запуске, а BeanFactory - по требованию.
2. ApplicationContext расширяет BeanFactory и предоставляет функции, которые подходят для корпоративных приложений:
   a. поддержка внедрения зависимостей на основе аннотаций;
   b. удобный доступ к MessageSource (для использования в интернационализации);
   c. публикация ApplicationEvent - для бинов, реализующих интерфейс ApplicationListener, с помощью интерфейса ApplicationEventPublisher;
   d. простая интеграция с функциями Spring AOP.
3. ApplicationContext поддерживает автоматическую регистрацию BeanPostProcessor и BeanFactoryPostProcessor. Поэтому всегда желательно использовать ApplicationContext, потому что Spring 2.0 (и выше) интенсивно использует BeanPostProcessor.
4. ApplicationContext поддерживает практически все типы scope для бинов, а BeanFactory поддерживает только два - Singleton и Prototype.
5. В BeanFactory не будут работать транзакции и Spring AOP. Это может привести к путанице, потому что конфигурация с виду будет корректной

## Жизненный цикл Context
+ Контейнер создается при запуске приложения
+ Контейнер считывает конфигурационные данные (парсинг XML, JavaConfig)
+ Из конфигурационных данных создается описание бинов (BeanDafinition) BeanDefenitionReader
+ BeanFactoryPostProcessors обрабатывают описание бина 
+ Контейнер создает бины используя их описание
+ Бины инициализируются — значения свойств и зависимости внедряются в бин (настраиваются)
+ BeanPostProcessor запускают методы обратного вызова(callback methods)
+ Приложение запущено и работает
+ Инициализируется закрытие приложения
+ Контейнер закрывается
+ Вызываются callback methods

https://habr.com/ru/post/222579/

## Как завершить работу контекста
Если это не веб-приложение, то есть 2 способа: 

+ Регистрация shutdown-hook с помощью вызова метода registerShutdownHook(), он также реализован в классе AbstractApplicationContext. Это предпочтительный способ.
+ Можно вызвать метод close() из класса AbstractApplicationContext.

В Spring Boot приложении: Spring Boot самостоятельно зарегистрирует shutdown-hook за вас.

## Bean
Бин (bean) — это не что иное, как самый обычный объект. Разница лишь в том, что бинами принято называть те объекты, которые управляются Spring-ом и живут внутри его DI-контейнера.

По умолчанию бин задается как синглтон в Spring. Таким образом все публичные переменные класса могут быть изменены одновременно из разных мест, а значит бин - не потокобезопасен. Однако поменяв область действия бина на request, prototype, session он станет потокобезопасным, но это скажется на производительности.

Конфигурационный файл спринг определяет все бины, которые будут инициализированы в Spring Context. При создании экземпляра Spring ApplicationContext будет прочитан конфигурационный xml файл и выполнены указанные в нем необходимые инициализации. Отдельно от базовой конфигурации, в файле могут содержаться описание перехватчиков (interceptors), view resolvers, настройки локализации и др.

Определение бина содержит метаданные конфигурации, которые необходимы управляющему контейнеру для получения следующей информации: Как создать бин; Информацию о жизненном цикле бина; Зависимости бина.

В Spring Framework существуют такие свойства, определяющие бины:
+ class - Этот атрибут является обязательным и указывает конкретный класс Java-приложения, который будет использоваться для создания бина.

+ name - Уникальный идентификатор бина. В случае конфигурации с помощью xml-файла, вы можете использовать свойство “id” и/или “name” для идентификации бина. Атрибут name также может принимать массив String, что позволяет использовать несколько имен. Первый элемент массива будет являться именем и уникальным идентификатором бина, а остальные будут его псевдонимами.

+ scope - Это свойство определяет область видимости создаваемых объектов. 
- __singleton__ - Определяет один единственный бин для каждого контейнера Spring IoC (используется по умолчанию); 
- __prototype__ - контейнер Spring IoC создаёт новый экземпляр бина на каждый полученный запрос т.е. иметь любое количество экземпляров бина; 
- __request__ - Создаётся один экземпляр бина на каждый HTTP запрос. Касается исключительно ApplicationContext; 
- __session__ - Создаётся один экземпляр бина на каждую HTTP сессию. Касается исключительно ApplicationContext; 
- __web socket__ - Создаётся один экземпляр бина для определенного сокета. 
- __application__ - Создаётся один экземпляр бина для жизненного цикла бина. Похоже на синглтон, но когда бобы ограничены областью приложения, значения, однажды установленное в applicationScopedBean, будет сохранено для всех последующих запросов, сеансов и даже для другого приложения сервлета, которое будет обращаться к этому Бобу, при условии, что оно выполняется в том же ServletContext. В то время как одноэлементные бобы ограничены только одним контекстом приложения.

+ constructor-arg - Определяет конструктор, использующийся для внедрения зависимости. Более подробно – далее.

+ properties - Определяет свойства внедрения зависимости. Более подробно рассмотрим далее.

+ initialization method - Здесь определяется метод инициализации бина

+ destruction method - Метод уничтожения бина, который будет использоваться при уничтожении контейнера, содержащего бин.

+ autowiring mode - Определяет режим автоматического связывания при внедрении зависимости. Более подробно рассмотрим далее.

+ lazy-initialization mode - Режим ленивой инициализации даёт контейнеру IoC команду создавать экземпляр бина при первом запросе, а не при запуске приложения.

Классы, аннотированные @Configuration, проксируются через CGLIB. Классы @Component или обычные классы не проксируются и не перехватывают вызовы методов с аннотациями @Bean, что означает, что вызовы не будут маршрутизироваться через контейнер и каждый раз будет возвращаться новый экземпляр бина.

CGLIB (Code Generation Library) - Это библиотека инструментария байтов, используемая во многих средах Java, таких как Hibernate или Spring. Инструментарий байт-кода позволяет манипулировать или создавать классы после фазы компиляции программы.

##  Пример, где нужен `prototype` (кратко)
Когда нужен новый экземпляр при каждом запросе/использовании, например — сборщик сообщений с внутренним состоянием:

```java
@Component
@Scope("prototype")
public class MessageBuilder {
    private final StringBuilder buf = new StringBuilder();
    public void add(String part) { buf.append(part); }
    public String build() { return buf.toString(); }
}
```

Если `MessageBuilder` был singleton и использовался одновременно разными потоками — потребуется синхронизация, а prototype даёт отдельный экземпляр.

__Жизненный цикл бинов:__ 
+ Загрузка описаний бинов, создание графа зависимостей(между бинами)
+ Создание и запуск BeanFactoryPostProcessors
+ Создание бинов
+ Spring внедряет значения и зависимости в свойства бина
+ Если бин реализует метод setBeanName() из интерфейса NameBeanAware, то ID бина передается в метод
+ Если бин реализует BeanFactoryAware, то Spring устанавливает ссылку на bean factory через setBeanFactory() из этого интерфейса.
+ Если бин реализует интерфейс ApplicationContextAware, то Spring устанавливает ссылку на ApplicationContext через setApplicationContext().
+ BeanPostProcessor это специальный интерфейс, и Spring позволяет бинам имплементировать этот интерфейс. Реализуя метод postProcessBeforeInitialization(), можно изменить экземпляр бина перед его(бина) инициализацией(установка свойств и т.п.)
+ Если определены методы обратного вызова, то Spring вызывает их. Например, это метод, аннотированный @PostConstruct или метод initMethod из аннотации @Bean.
+ Теперь бин готов к использованию. Его можно получить с помощью метода ApplicationContext#getBean().
+ После того как контекст будет закрыт(метод close() из ApplicationContext), бин уничтожается.
+ Если в бине есть метод, аннотированный @PreDestroy, то перед уничтожением вызовется этот метод. Если бин имплементирует DisposibleBean, то Spring вызовет метод destroy(), чтобы очистить ресурсы или убить процессы в приложении. Если в аннотации @Bean определен метод destroyMethod, то вызовется и он.

Интерфейс BeanPostProcessor позволяют разработчику самому имплементировать некоторые методы бинов перед инициализацией и после уничтожения экземпляров бина.
Имеется возможность настраивать несколько имлементаций BeanPostProcessor и определить порядок их выполнения. Данный интерфейс работает с экземплярами бинов, а это означает, что Spring IoC создаёт экземпляр бина, а затем BeanPostProcessor с ним работает. ApplicationContext автоматически обнаруживает любые бины, с реализацией BeanPostProcessor и помечает их как “post-processors” для того, чтобы создать их определённым способом.

Интерфейс BeanPostProcessor имеет всего два метода: postProcessBeforeInitialization и postProcessAfterInitialization



## Жизненный цикл бинов

1. __Парсирование конфигурации и создание BeanDefinition__

Цель первого этапа — это создание всех BeanDefinition. Объекты BeanDefinition — это набор метаданных будущего бина, макет, по которому нужно будет создавать бин в случае необходимости. То есть для каждого бина создается свой объект BeanDefinition, в котором хранится описание того, как создавать и управлять этим конкретным бином. Проще говоря, сколько бинов в программе - столько и объектов BeanDefinition, их описывающих.

BeanDefinition содержат (среди прочего) следующие метаданные:
- Имя класса с указанием пакета: обычно это фактический класс бина.
- Элементы поведенческой конфигурации бина, которые определяют, как бин должен вести себя в контейнере (scope, обратные вызовы жизненного цикла и т.д.).
- Ссылки на другие bean-компоненты, которые необходимы для его работы. Эти ссылки также называются зависимостями.
- Другие параметры конфигурации для установки во вновь созданном объекте - например, ограничение размера пула или количество соединений, используемых в бине, который управляет пулом соединений.
   
Эти метаданные преобразуются в набор свойств, которые составляют каждое BeanDefinition. В следующей таблице описаны эти свойства:

При конфигурации через аннотации с указанием пакета для сканирования или JavaConfig используется класс AnnotationConfigApplicationContext. Регистрируются все классы с @Configuration для дальнейшего парсирования, затем регистрируется специальный BeanFactoryPostProcessor, а именно BeanDefinitionRegistryPostProcessor, который при помощи класса ConfigurationClassParser парсирует JavaConfig, загружает описания бинов (BeanDefinition), создаёт граф зависимостей (между бинами) и создаёт:
```java
Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<>(256); 

```
в которой хранятся все описания бинов, обнаруженных в ходе парсинга конфигурации.

2. __Настройка созданных BeanDefinition__

После первого этапа у нас имеется коллекция Map, в которой хранятся BeanDefinition-ы. BeanFactoryPostProcessor-ы на этапе создания BeanDefinition-ов могут их настроить как нам необходимо. BeanFactoryPostProcessor-ы могут даже настроить саму BeanFactory ещё до того, как она начнет работу по созданию бинов. В интерфейсе BeanFactoryPostProcessor всего один метод:
```java
public interface BeanFactoryPostProcessor {
void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;
}
```

3. __Создание кастомных FactoryBean (только для XML-конфигурации)__

4. __Создание экземпляров бинов__
   
Сначала BeanFactory из коллекции Map с объектами BeanDefinition достаёт те из них, из которых создаёт все BeanPostProcessor-ы, необходимые для настройки обычных бинов. Создаются экземпляры бинов через BeanFactory на основе ранее созданных BeanDefinition

5. __Настройка созданных бинов__
   
На данном этапе бины уже созданы, мы можем лишь их донастроить. 

Интерфейс BeanPostProcessor позволяет вклиниться в процесс настройки наших бинов до того, как они попадут в контейнер. ApplicationContext автоматически обнаруживает любые бины с реализацией BeanPostProcessor и помечает их как “post-processors” для того, чтобы создать их определенным способом. Например, в Spring есть реализации BeanPostProcessor-ов, которые обрабатывают аннотации @Autowired, @Inject, @Value и @Resource.
   
Интерфейс несет в себе два метода: postProcessBeforeInitialization(Object bean, String beanName) и postProcessAfterInitialization(Object bean, String beanName). У обоих методов параметры абсолютно одинаковые. Разница только в порядке их вызова. Первый вызывается до init-метода, второй - после.
   
Как правило, BeanPostProcessor-ы, которые заполняют бины через маркерные интерфейсы или тому подобное, реализовывают метод postProcessBeforeInitialization (Object bean, String beanName), тогда как BeanPostProcessor-ы, которые оборачивают бины в прокси, обычно реализуют postProcessAfterInitialization (Object bean, String beanName). 

Прокси — это класс-декорация над бином. Например, мы хотим добавить логику нашему бину, но джава-код уже скомпилирован, поэтому нам нужно на лету сгенерировать новый класс. Этим классом мы должны заменить оригинальный класс так, чтобы никто не заметил подмены.
   
Есть два варианта создания этого класса:
- либо он должен наследоваться от оригинального класса (CGLIB) и переопределять его методы, добавляя нужную логику; 
- либо он должен имплементировать те же самые интерфейсы, что и первый класс(Dynamic Proxy).
   
По конвенции спринга, если какой-то из BeanPostProcessor-ов меняет что-то в классе, то он должен это делать на этапе postProcessAfterInitialization(). Таким образом мы уверены, что initMethod у данного бина, работает на оригинальный метод, до того, как на него накрутился прокси.
   
Хронология событий:
1. Сначала сработает метод postProcessBeforeInitialization() всех имеющихся BeanPostProcessor-ов.
2. Затем, при наличии, будет вызван метод, аннотированный @PostConstruct.
3. Если бин имплементирует InitializingBean, то Spring вызовет метод afterPropertiesSet() - не рекомендуется к использованию как устаревший.
4. При наличии, будет вызван метод, указанный в параметре initMethod аннотации @Bean.
5. В конце бины пройдут через postProcessAfterInitialization (Object bean, String beanName). Именно на данном этапе создаются прокси стандартными BeanPostProcessor-ами. Затем отработают наши кастомные BeanPostProcessor-ы и применят нашу логику к прокси-объектам. После чего все бины окажутся в контейнере, который будет обязательно обновлен методом refresh().
6. Но даже после этого мы можем донастроить наши бины ApplicationListener-ами.
7. Теперь всё

![Image alt](https://github.com/Shell26/Java-Developer/raw/master/img/Spring1.png)

6. __Бины готовы к использованию__
   
Их можно получить с помощью метода ApplicationContext#getBean().

8. __Закрытие контекста__
   
Когда контекст закрывается (метод close() из ApplicationContext), бин уничтожается.
   
Если в бине есть метод, аннотированный @PreDestroy, то перед уничтожением вызовется этот метод. 

Если бин имплементирует DisposibleBean, то Spring вызовет метод destroy() - не рекомендуется к использованию как устаревший. 

Если в аннотации @Bean определен метод destroyMethod, то будет вызван и он.

__@PostConstruct__

Spring вызывает методы, аннотированные @PostConstruct, только один раз, сразу после инициализации свойств компонента. За данную аннотацию отвечает один из BeanPostProcessor-ов. 

Метод, аннотированный @PostConstruct, может иметь любой уровень доступа, может иметь любой тип возвращаемого значения (хотя тип возвращаемого значения игнорируется Spring-ом), метод не должен принимать аргументы. Он также может быть статическим, но преимуществ такого использования метода нет, т.к. доступ у него будет только к статическим полям/методам бина, и в таком случае смысл его использования для настройки бина пропадает. 

Одним из примеров использования @PostConstruct является заполнение базы данных. Например, во время разработки нам может потребоваться создать пользователей по умолчанию.

__@PreDestroy__

Метод, аннотированный @PreDestroy, запускается только один раз, непосредственно перед тем, как Spring удаляет наш компонент из контекста приложения. 

Как и в случае с @PostConstruct, методы, аннотированные @PreDestroy, могут иметь любой уровень доступа, но не могут быть статическими. 

Целью этого метода может быть освобождение ресурсов или выполнение любых других задач очистки до уничтожения бина, например, закрытие соединения с базой данных.

Обратите внимание, что аннотации @PostConstruct и @PreDestroy являются частью Java EE, а именно пакета javax.annotation модуля java.xml.ws.annotation. И поскольку Java EE устарела в Java 9, то с этой версии пакет считается устаревшим (Deprecated). С Java 11 данный пакет вообще удален, поэтому мы должны добавить дополнительную зависимость для использования этих аннотаций:
```java
<dependency>
<groupId>javax.annotation</groupId>
<artifactId>javax.annotation-api</artifactId>
<version>1.3.2</version>
</dependency>
```



## Как настроить класс как Spring Bean
1) XML конфигурация
```java
<bean name="myBean" class="project.spring.beans.MyBean"></bean>
```
2) Java code - все настройки прописываются непосредственно в коде
```java
@configuration
@ComponentScan(value="project.spring.main")
public class MyConfiguration [

    @Bean
    public MyService getService() {
        return new MyService();
    }
}
```
Для извлечения бина:
```java
AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(MyConfiguration.class);
MyService service = ctx.getBean(MyService.class);
```
3) Annotation - внутри кода используются аннотации @Component, @Service, @Repository, @Controller для указания классов как бины. Для их поиска и управления контейнером прописывается настройка в xml файле
```java
<context:component-scan base-package="project.spring"/>
```
## Статический Bean
Если в классе будет статический метод, то при инициализации впервую очередь создастся статический метод (из-за особенностей статических полей), а потом уже Bean, который "навешивается" на статический метод.

При этом Spring не позволяет внедрять бины напрямую в статические поля, нужно создать нестатический сеттер-метод
```java
@Component
public class TestDataInit {
 @Autowired
 private static OrderItemService orderItemService; //будет null
}

@Component
public class TestDataInit {
    private static OrderItemService orderItemService;
    @Autowired
    public void setOrderItemService(OrderItemService orderItemService) {
        TestDataInit.orderItemService = orderItemService;
    }
}

```
[к оглавлению](#spring)

## Inversion of Control
Центральной частью Spring является подход Inversion of Control, который позволяет конфигурировать и управлять объектами Java с помощью рефлексии. Вместо ручного внедрения зависимостей, фреймворк забирает ответственность за это посредством контейнера. Контейнер отвечает за управление жизненным циклом объекта: создание объектов, вызов методов инициализации и конфигурирование объектов путём связывания их между собой. 

Объекты, создаваемые контейнером, также называются управляемыми объектами (beans). Обычно, конфигурирование контейнера, осуществляется путём внедрения аннотаций (начиная с 5 версии J2SE), но также, есть возможность, по старинке, загрузить XML-файлы, содержащие определение bean’ов и предоставляющие информацию, необходимую для создания bean’ов.

Плюсы такого подхода:
- отделение выполнения задачи от ее реализации;
- легкое переключение между различными реализациями;
- большая модульность программы;
- более легкое тестирование программы путем изоляции компонента или проверки его зависимостей и обеспечения взаимодействия компонентов через контракты.

Объекты могут быть получены одним из двух способов:

__Dependency Lookup Поиск зависимости__ — шаблон проектирования, в котором вызывающий объект запрашивает у объекта-контейнера экземпляр объекта с определённым именем или определённого типа.

__Dependency Injection Внедрение зависимости__ — шаблон проектирования, в котором контейнер передает экземпляры объектов по их имени другим объектам с помощью конструктора, свойства или фабричного метода.

## Dependency Injection (DI)
Под DI понимают то __Dependency Inversion__ (инверсию зависимостей, то есть попытки не делать жестких связей между вашими модулями/классами, где один класс напрямую завязан на другой), то __Dependency Injection__ (внедрение зависимостей, это когда объекты котиков создаете не вы в main-е и потом передаете их в свои методы, а за вас их создает спринг, а вы ему просто говорите что-то типа "хочу сюда получить котика" и он вам его передает в ваш метод). Мы чаще будем сталкиваться в дальнейших статьях со вторым.

Внедрение зависимости (Dependency injection, DI) — процесс, когда один объект реализует свой функционал через другой. Является специфичной формой «инверсии управления» (Inversion of control, IoC), когда она применяется к управлению зависимостями. В полном соответствии с принципом единой обязанности объект отдаёт заботу о построении требуемых ему зависимостей внешнему, специально предназначенному для этого общему механизму.

К достоинствам применения DI можно отнести:
+ Сокращение объема связующего кода. Одним из самых больших плюсов DI является возможность значительного сокращения объема кода, который должен быть написан для связывания вместе различных компонентов приложения. Зачастую этот код очень прост — при создании зависимости должен создаваться новый экземпляр соответствующего объекта.
+ Упрощенная конфигурация приложения. За счет применения DI процесс конфигурирования приложения значительно упрощается. Для конфигурирования классов, которые могут быть внедрены в другие классы, можно использовать аннотации или XML-файлы.
+ Возможность управления общими зависимостями в единственном репозитории. При традиционном подходе к управлению зависимостями в общих службах, к которым относятся, например, подключение к источнику данных, транзакция, удаленные службы и т.п., вы создаете экземпляры (или получаете их из определенных фабричных классов) зависимостей там, где они нужны — внутри зависимого класса. Это приводит к распространению зависимостей по множеству классов в приложении, что может затруднить их изменение. В случае использования DI вся информация об общих зависимостях содержится в единственном репозитории (в Spring есть возможность хранить эту информацию в XML-файлах или Java классах), что существенно упрощает управление зависимостями и снижает количество возможных ошибок.
+ Улучшенная возможность тестирования. Когда классы проектируются для DI, становится возможной простая замена зависимостей. Это особенно полезно при тестировании приложения.
+ Стимулирование качественных проектных решений для приложений. Вообще говоря, проектирование для DI означает проектирование с использованием интерфейсов. Используя Spring, вы получаете в свое распоряжение целый ряд средств DI и можете сосредоточиться на построении логики приложения, а не на поддерживающей DI платформе.

## Как реализуется DI в Spring Framework?
Реализация DI в Spring основана на двух ключевых концепциях Java — компонентах JavaBean и интерфейсах. При использовании Spring в качестве поставщика DI вы получаете гибкость определения конфигурации зависимостей внутри своих приложений разнообразными путями (т.е. внешне в XML-файлах, с помощью конфигурационных Java классов Spring или посредством аннотаций Java в коде). Компоненты JavaBean (также называемые POJO (Plain Old Java Object — простой старый объект Java)) предоставляют стандартный механизм для создания ресурсов Java, которые являются конфигурируемыми множеством способов. За счет применения DI объем кода, который необходим при проектировании приложения на основе интерфейсов, снижается почти до нуля. Кроме того, с помощью интерфейсов можно получить максимальную отдачу от DI, потому что бины могут использовать любую реализацию интерфейса для удовлетворения их зависимости.

К типам реализации внедрения зависимостей в Spring относят:

Constructor Dependency Injection — это тип внедрения зависимостей, при котором зависимости компонента предоставляются ему в его конструкторе (или конструкторах). Рекомендуется как основной способ, т.к. даже без спринга внедрение зависимостей будет работать корректно.
```java
public class ConstructorInjection {
 
private Dependency dependency;
  
  public ConstructorInjection(Dependency dependency) {
         this.dependency = dependency;
  }
}
```
Setter Dependency Injection — контейнер IoC внедряет зависимости компонента в компонент через методы установки в стиле JavaBean. В основном через сеттеры. При модификации не создает новые экземпляры, в отличии от конструктора. Он при каждой модификации создаёт новый экземпляр.
```java
public class SetterInjection {
private Dependency dependency;
   public void setDependency(Dependency dependency) {
           this.dependency = dependency;
   }
}
```

## Связывание и @Autowired
Процесс внедрения зависимостей в бины при инициализации называется Spring Bean Wiring. Считается хорошей практикой задавать явные связи между зависимостями, но в Spring предусмотрен дополнительный механизм связывания @Autowired. Аннотация может использоваться над конструктор, поле, сеттер-метод или метод конфигурации для связывания по типу. Если в контейнере не будет обнаружен необходимый для вставки бин, то будет выброшено исключение, либо можно указать @Autowired(required = false), означающее, что внедрение зависимости в данном месте не обязательно. Чтобы аннотация заработала, необходимо указать небольшие настройки в конфигурационном файле спринг с помощью элемента <context:annotation-config/>.

Типы связывания:
+ autowire byName,
+ autowire byType,
+ autowire by constructor,
+ autowiring by @Autowired and @Qualifier annotations

Начиная со Spring Framework 4.3, аннотация @Autowired для конструктора больше не требуется, если целевой компонент определяет только один конструктор. Однако, если доступно несколько конструкторов и нет основного/стандартного конструктора, по крайней мере один из конструкторов должен быть аннотирован @Autowired, чтобы указать контейнеру, какой из них использовать.

Мы также можем указать Spring предоставить все бины определенного типа из ApplicationContext, добавив аннотацию @Autowired в поле или метод с массивом или коллекцией этого типа, как показано в следующем примере:
```java
@Autowired
private MovieCatalog[] movieCatalogs;
или:
@Autowired
private Set<MovieCatalog> movieCatalogs;
или:
@Autowired
public void setMovieCatalogs(Set<MovieCatalog> movieCatalogs) {
this.movieCatalogs = movieCatalogs;
}
```

Даже коллекции типа Map могут быть подключены автоматически, если тип ключа - String. Ключами будут имена бинов, а значениями - сами бины, как показано в следующем примере:
```java
public class MovieRecommender {
private Map<String, MovieCatalog> movieCatalogs;
@Autowired
public void setMovieCatalogs(Map<String, MovieCatalog> movieCatalogs){
    this.movieCatalogs = movieCatalogs;
}
// ...
}
```

[к оглавлению](#spring)

## MVC
Spring имеет собственную MVC-платформу веб-приложений, которая не была первоначально запланирована. Spring MVC является фреймворком, ориентированным на запросы. В нем определены стратегические интерфейсы для всех функций современной запросно-ориентированной системы. Цель каждого интерфейса — быть простым и ясным, чтобы пользователям было легко его заново имплементировать, если они того пожелают. MVC прокладывает путь к более чистому front-end-коду. Все интерфейсы тесно связаны с Servlet API. Эта связь рассматривается некоторыми как неспособность разработчиков Spring предложить для веб-приложений абстракцию более высокого уровня. Однако эта связь оставляет особенности Servlet API доступными для разработчиков, облегчая все же работу с ним. Наиболее важные интерфейсы, определенные Spring MVC, перечислены ниже:

__HandlerMapping__: выбор класса и его метода, которые должны обработать данный входящий запрос на основе любого внутреннего или внешнего для этого запроса атрибута или состояния.

__HandlerAdapter__: вызов и выполнение выбранного метода обработки входящего запроса.

__Controller__: включен между Моделью (Model) и Представлением (View). Управляет процессом преобразования входящих запросов в адекватные ответы. Действует как ворота, направляющие всю поступающую информацию. Переключает поток информации из модели в представление и обратно.

Класс DispatcherServlet является главным контроллером, которые получает запросы и распределяет их между другими контроллерами. @RequestsMapping указывает, какие именно запросы будут обрабатываться в конкретном контроллере. Может быть несколько экземпляров DispatcherServlet, отвечающих за разные задачи (обработка запросов пользовательского интерфейса, REST служб и т.д.). Каждый экземпляр DispatcherServlet имеет собственную конфигурацию WebApplicationContext, которая определяет характеристики уровня сервлета, такие как контроллеры, поддерживающие сервлет, отображение обработчиков, распознавание представлений, интернационализация, оформление темами, проверка достоверности, преобразование типов и форматирование и т.п.

ContextLoaderListener - слушатель при старте и завершении корневого класса Spring WebApplicationContext. Основным назначением является связывание жизненного цикла ApplicationContext и ServletContext, а так же автоматического создания ApplicationContext. Можно использовать этот класс для доступа к бинам из различных контекстов спринг. Настраивается в web.xml

__Model__: Этот блок инкапсулирует (объединяет) данные приложения. На практике это POJO-классы.

__View__: ответственно за возвращение ответа клиенту в виде текстов и изображений. Некоторые запросы могут идти прямо во View, не заходя в Model; другие проходят через все три слоя.

__ViewResolver__: выбор, какое именно View должно быть показано клиенту. Поддерживает распознавание представлений на основе логического имени, возвращаемого контроллером. Для поддержки различных механизмов распознавания представлений предусмотрено множество классов реализации. Например, класс UrlBasedViewResolver поддерживает прямое преобразование логических имен в URL. 

Класс ContentNegotiatingViewResolver поддерживает динамическое распознавание представлений в зависимости от типа медиа, поддерживаемого клиентом (XML, PDF, JSON и т.д.). Существует также несколько реализаций для интеграции с различными технологиями представлений, такими как FreeMarker (FreeMarkerViewResolver), Velocity (VelocityViewResolver) и JasperReports (JasperReportsViewResolver).

__HandlerInterceptor__: перехват входящих запросов. Сопоставим, но не эквивалентен сервлет-фильтрам (использование не является обязательным и не контролируется DispatcherServlet-ом).

__LocaleResolver__: получение и, возможно, сохранение локальных настроек (язык, страна, часовой пояс) пользователя.

__MultipartResolver__: обеспечивает Upload — загрузку на сервер локальных файлов клиента. По умолчанию этот интерфейс не включается в приложении и необходимо указывать его в файле конфигурации. После настройки любой запрос о загрузке будет отправляться этому интерфейсу.

Spring MVC предоставляет разработчику следующие возможности:
+ Ясное и прозрачное разделение между слоями в MVC и запросах.
+ Стратегия интерфейсов — каждый интерфейс делает только свою часть работы.
+ Интерфейс всегда может быть заменен альтернативной реализацией.
+ Интерфейсы тесно связаны с Servlet API.
+ Высокий уровень абстракции для веб-приложений.
+ В веб-приложениях можно использовать различные части Spring, а не только Spring MVC.

![Image alt](https://github.com/Shell26/Java-Developer/raw/master/img/Spring2.png)

## Шаблон проектирования Front Controller

Паттерн Front Controller обеспечивает единую точку входа для всех входящих запросов. Все запросы обрабатываются одним фрагментом кода, который затем может делегировать ответственность за обработку запроса другим объектам приложения. Он также обеспечивает интерфейс для общего поведения, такого как безопасность, интернационализация и передача определенных представлений определенным пользователям.

В Spring в качестве Front Controller выступает DispatcherServlet, все действия проходят через него. Как правило в приложении задаётся только один DispatcherServlet с маппингом “/”, который перехватывает все запросы. Это и есть реализация паттерна Front Controller.

Однако иногда необходимо определить два и более DispatcherServlet-а, которые будут отвечать за свой собственный функционал. Например, чтобы один обрабатывал REST-запросы с маппингом “/api”, а другой обычные запросы с маппингом “/default”. Spring предоставляет нам такую возможность, и для начала нужно понять, что:

- Spring может иметь несколько контекстов одновременно. Одним из них будет корневой контекст, а все остальные контексты будут дочерними.
- Все дочерние контексты могут получить доступ к бинам, определенным в корневом контексте, но не наоборот. Корневой контекст не может получить доступ к бинам дочерних контекстов.
- Каждый дочерний контекст внутри себя может переопределить бины из корневого контекста.

Каждый DispatcherServlet имеет свой дочерний контекст приложения. DispatcherServlet по сути является сервлетом(он расширяет HttpServlet), основной целью которого является обработка входящих вебзапросов, соответствующих настроенному шаблону URL. Он принимает входящий URI и находит правильную комбинацию контроллера и вида. Веб-приложение может определять любое количество DispatcherServlet-ов. Каждый из них будет работать в своем собственном пространстве имен, загружая свой собственный дочерний WebApplicationContext (на рисунке - Servlet WebApplicationContext) с вьюшками, контроллерами и т.д. Например, когда нам нужно в одном Servlet WebApplicationContext определить обычные контроллеры, а в другом REST-контроллеры.

![Image alt](https://github.com/Shell26/Java-Developer/raw/master/img/Spring3.png)

WebApplicationContext расширяет ApplicationContext (создаёт и управляет бинами и т.д.), но помимо этого он имеет дополнительный метод getServletContext(), через который у него есть возможность получать доступ к ServletContext-у.

ContextLoaderListener создает корневой контекст приложения (на рисунке - Root WebApplicationContext) и будет использоваться всеми дочерними контекстами, созданными всеми DispatcherServlet. Напомню, что корневой контекст приложения будет общим и может быть только один. Root WebApplicationContext содержит компоненты, которые видны всем дочерним контекстам, такие как сервисы, репозитории, компоненты инфраструктуры и т.д. После создания корневого контекста приложения он сохраняется в ServletContext как атрибут, имя которого:
```java
WebApplicationContext.class.getName() + ".ROOT"
```
Чтобы из контроллера любого дочернего контекста обратиться к корневому контексту приложения, мы можем использовать класс WebApplicationContextUtils, содержащий статические методы:
```java
@Autowired
ServletContext context;
ApplicationContext ac =WebApplicationContextUtils.getWebApplicationContext(context);
if(ac == null){
    return "root application context is null";
}
```
__ContextLoaderListener vs DispatcherServlet__

1. ContextLoaderListener создает корневой контекст приложения.
2. Каждый DispatcherServlet создаёт себе один дочерний контекст.
3. Дочерние контексты могут обращаться к бинам, определенным в корневом контексте.
4. Бины в корневом контексте не могут получить доступ к бинам в дочерних контекстах (напрямую).
5. Все контексты добавляются в ServletContext.
6. Мы можем получить доступ к корневому контексту, используя класс WebApplicationContextUtils.

![Image alt](https://github.com/Shell26/Java-Developer/raw/master/img/Spring4.png)

## В чем разница между Filters, Listeners и Interceptors?

__Filter__

Это интерфейс из пакета javax.servlet, имплементации которого выполняют задачи фильтрации либо по пути запроса к ресурсу (сервлету, либо по статическому контенту), либо по пути ответа от ресурса, либо в обоих направлениях.

Фильтры выполняют фильтрацию в методе doFilter. Каждый фильтр имеет доступ к объекту FilterConfig, из которого он может получить параметры инициализации, и ссылку на ServletContext, который он может использовать, например, для загрузки ресурсов, необходимых для задач фильтрации. Фильтры настраиваются в дескрипторе развертывания веб-приложения.

В веб-приложении мы можем написать несколько фильтров, которые вместе называются цепочкой фильтров. Веб-сервер решает, какой фильтр вызывать первым, в соответствии с порядком регистрации фильтров.

Когда вызывается метод doFilter(ServletRequest request, ServletResponse response, FilterChain chain) первого фильтра, веб-сервер создает объект FilterChain, представляющий цепочку фильтров, и передаёт её в метод.

![Image alt](https://github.com/Shell26/Java-Developer/raw/master/img/Spring5.png)

__Interceptor__

Это интерфейс из пакета org.aopalliance.intercept, предназначенный для аспектноориентированного программирования. В Spring, когда запрос отправляется в Controller, перед тем как он в него попадёт, он может пройти через перехватчики Interceptor (0 или более). Это одна из реализаций АОП в Spring. Вы можете использовать Interceptor для выполнения таких задач, как запись в Log, добавление или обновление конфигурации перед тем, как запрос обработается Controller-ом.

Стек перехватчиков: он предназначен для связывания перехватчиков в цепочку в определенном порядке. При доступе к перехваченному методу или полю перехватчик в цепочке перехватчиков вызывается в том порядке, в котором он был определен.

![Image alt](https://github.com/Shell26/Java-Developer/raw/master/img/Spring6.png)

Мы можем использовать Interceptor-ы для выполнения логики до попадания в контроллер, после обработки в контроллере, а также после формирования представления. Также можем запретить выполнение метода контроллера. Мы можем указать любое количество перехватчиков.

Перехватчики работают с HandlerMapping и поэтому должны реализовывать интерфейс HandlerInterceptor или наследоваться от готового класса HandlerInterceptorAdapter. В случае реализации HandlerInterceptor нам нужно переопределить 3 метода, а в случае HandlerInterceptor, только необходимые нам:

- public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) - вызывается после того, как HandlerMapping определил соответствующий контроллер, но до того, как HandlerAdapter вызовет метод контроллера. С помощью этого метода каждый перехватчик может решить, прервать цепочку выполнения или направить запрос на испольнение дальше по цепочке перехватчиков до метода контроллера. Если этот метод возвращает true, то запрос отправляется следующему перехватчику или в контроллер. Если метод возвращает false, то исполнение запроса прекращается, обычно отправляя ошибку HTTP или записывая собственный ответ в response.
 
- public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) - отработает после контроллера, но перед формированием представления. Мы можем использовать этот метод для добавления дополнительных атрибутов в ModelAndView или для определения времени, затрачиваемого методом-обработчиком на обработку запроса клиента. Вы можете добавить больше объектов модели в представление, но вы не можете изменить HttpServletResponse, так как он уже зафиксирован.
 
- public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) - отработает после формирования представления. Вызывается только в том случае, если метод preHandle этого перехватчика успешно завершен и вернул true!

![Image alt](https://github.com/Shell26/Java-Developer/raw/master/img/Spring7.png)

Следует знать, что HandlerInterceptor связан с бином DefaultAnnotationHandlerMapping, который отвечает за применение перехватчиков к любому классу, помеченному аннотацией @Controller.

Чтобы добавить наши перехватчики в конфигурацию Spring, нам нужно переопределить метод addInterceptors () внутри класса, который реализует WebMvcConfigurer:
```java
@Override
public void addInterceptors(InterceptorRegistry registry) {
// LogInterceptor applies to all URLs.
registry.addInterceptor(new LogInterceptor());
// This interceptor applies to URL /admin/oldLogin.
// Using OldURLInterceptor to redirect to new URL.
registry.addInterceptor(new OldLoginInterceptor())
.addPathPatterns("/admin/oldLogin");
// This interceptor applies to URLs like /admin/*
// Exclude /admin/oldLogin
registry.addInterceptor(new AdminInterceptor())
.addPathPatterns("/admin/*")//
.excludePathPatterns("/admin/oldLogin");
}
```

__Filter vs. Interceptor__

- Перехватчик основан на механизме Reflection, а фильтр основан на обратном вызове функции.
- Фильтр зависит от контейнера сервлета, тогда как перехватчик не зависит от него.
- Перехватчики могут работать только с запросами к контроллерам, в то время как фильтры могут работать почти со всеми запросами (например, js, .css и т.д.).
- Перехватчики в отличии от фильтров могут обращаться к объектам в контейнере Spring, что даёт им более изощренный функционал.

Порядок работы:
1. Фильтры до;
2. Перехватчики до;
3. Метод контроллера;
4. Перехватчики после;
5. Фильтры после.
   
HandlerInterceptor в основном похож на Servlet Filter, но в отличие от последнего он просто позволяет настраивать предварительную обработку с возможностью запретить выполнение самого обработчика и настраивать постобработку.

Согласно документации Spring, фильтры более мощные, например, они позволяют обмениваться объектами запроса и ответа, которые передаются по цепочке. Это означает, что фильтры работают больше в области запроса/ответа, в то время как HandlerInterceptors являются бинами и могут обращаться к другим компонентам в приложении. Обратите внимание, что фильтр настраивается в web.xml, а HandlerInterceptor в контексте приложения.

__Java Listener__

Listener (Слушатель) - это класс, который реализует интерфейс javax.servlet.ServletContextListener. Он инициализируется только один раз при запуске вебприложения и уничтожается при остановке веб-приложения. Слушатель сидит и ждет, когда произойдет указанное событие, затем «перехватывает» событие и запускает собственное событие. Например, мы хотим инициализировать пул соединений с базой данных до запуска веб-приложения. ServletContextListener - это то, что нам нужно, он будет запускать наш код до запуска веб-приложения.

Все ServletContextListeners уведомляются об инициализации контекста до инициализации любых фильтров или сервлетов в веб-приложении.

Все ServletContextListeners уведомляются об уничтожении контекста после того, как все сервлеты и фильтры уничтожены.

Чтобы создать свой Listener нам достаточно создать класс, имплементирующий интерфейс ServletContextListener и поставить над ним аннотацию @WebListener:
```java
@WebListener
public class MyAppServletContextListener
implements ServletContextListener{
//Run this before web application is started
@Override
public void contextInitialized(ServletContextEvent arg0) {
    System.out.println("ServletContextListener started");
}
@Override
public void contextDestroyed(ServletContextEvent arg0) {
    System.out.println("ServletContextListener destroyed");
}
}
```



## Связывание форм
@ModelAttribute - связывает параметр метода или возвращаемое значение метода с именованным атрибутом модели, а затем возвращает его view веб-представлению.

__Когда аннатоцаия используется над методом__, она указывает, что целью этого метода является добавление одного или нескольких атрибутов в модель. При этом Spring-MVC всегда будет сначала вызывать этот метод, прежде чем вызывать какие-либо методы обработчика запросов. То есть, методы @ModelAttribute вызываются до того, как вызываются методы контроллера, аннотированные @RequestMapping. 
```java
@ModelAttribute
public void addAttributes(Model model) {
    model.addAttribute("msg", "Welcome to the Netherlands!");
}
```
Также важно, чтобы соответствующий класс был помечен как @ControllerAdvice. Таким образом, Вы можете добавить в модель значения, которые будут определены как глобальные. Это фактически означает, что для каждого запроса существует значение по умолчанию, для каждого метода в части ответа.

__Когда аннотация ставится в параметрах метода__, она указывает, что аргумент должен быть извлечен из модели. Если такой аргумент отсутствует, его следует сначала создать, а затем добавить в модель, а после того, как он появится в модели, поля аргументов должны быть заполнены из всех параметров запроса, имеющих соответствующие имена.
```java
@RequestMapping(value = "/addEmployee", method = RequestMethod.POST)
public String submit(@ModelAttribute("employee") Employee employee) {
    // Code that uses the employee object
    return "employeeView";
}
```
Атрибут модели сотрудника заполняется данными из формы, отправленной в конечную точку addEmployee. Spring MVC делает это за кулисами перед вызовом метода submit. Таким образом, он связывает данные формы с Bean. Контроллер с аннотацией @RequestMapping может иметь пользовательские аргументы класса с аннотацией @ModelAttribute. Это то, что обычно называют привязкой данных в Spring-MVC, общий механизм, который избавляет вас от необходимости анализировать каждое поле формы по отдельности.


## Исключения в Spring MVC
В Spring MVC интерфейс HandlerExceptionResolver (из пакета org.springframework.web.servlet) предназначен для работы с непредвиденными исключениями, возникающими во время выполнения обработчиков. По умолчанию DispatcherServlet регистрирует класс DefaultHandlerExceptionResolver (из пакета org.springframework.web.servlet.mvc.support). Этот распознаватель обрабатывает определенные стандартные исключения Spring MVC, устанавливая специальный код состояния ответа. Можно также реализовать собственный обработчик исключений, аннотировав метод контроллера с помощью аннотации @ExceptionHandler и передав ей в качестве атрибута тип исключения. 

В общем случае обработку исключений можно описать таким образом:
+ @ExceptionHandler - указать методы для обработки исключения в классе контроллере. Принимает в себя имя класса обрабатываемого исключения (можно несколько).
+ @ControllerAdvice - для глобальной обработки ошибок в приложении Spring MVC. Ставится над классом-контроллером, отлавливает все исключения с методов. Он также имеет полный контроль над телом ответа и кодом состояния.
+ HandlerExceptionResolver implementation – позволяет задать глобального обработчика исключений. Реализацию этого интерфейса можно использовать для создания собственных глобальных обработчиков исключений в приложении.

## Локализация в приложениях Spring MVC
Spring MVC предоставляет очень простую и удобную возможность локализации приложения. Для этого необходимо сделать следующее:
+ Создать файл resource bundle, в котором будут заданы различные варианты локализированной информации.
+ Определить messageSource в конфигурации Spring используя классы ResourceBundleMessageSource или ResourceBundleMessageSource.
+ Определить localceResolver класса CookieLocaleResolver для включения возможности переключения локали.
+ С помощью элемента spring:message DispatcherServlet будет определять в каком месте необходимо подставлять локализированное сообщение в ответе.

## Spring Interceptor
Перехватчики в Spring (Spring Interceptor) являются аналогом Servlet Filter и позволяют перехватывать запросы клиента и обрабатывать их. Перехватить запрос клиента можно в трех местах: preHandle, postHandle и afterCompletion.

+ preHandle — метод используется для обработки запросов, которые еще не были переданы в метода обработчик контроллера. Должен вернуть true для передачи следующему перехватчику или в handler method. False укажет на обработку запроса самим обработчиком и отсутствию необходимости передавать его дальше. Метод имеет возможность выкидывать исключения и пересылать ошибки к представлению.
+ postHandle — вызывается после handler method, но до обработки DispatcherServlet для передачи представлению. Может использоваться для добавления параметров в объект ModelAndView.
+ afterCompletion — вызывается после отрисовки представления.

Для создания обработчика необходимо расширить абстрактный класс HandlerInterceptorAdapter или реализовать интерфейс HandlerInterceptor. Так же нужно указать перехватчики в конфигурационном файле Spring.

[к оглавлению](#spring)

## CommandLineRunner и ApplicationRunner
Эти интрефейсы используются для запуска логики при запуске приложения, после создания экземпляра контекста приложения Spring.

ApplicationRunner.run() и CommandLineRunner.run() выполнятся сразу после создания applicationcontext и до запуска приложения. Оба они обеспечивают одинаковую функциональность, и единственное различие между CommandLineRunner и ApplicationRunner состоит в том, что CommandLineRunner.run() принимает String array[], тогда как ApplicationRunner.run() принимает ApplicationArguments в качестве аргумента.
```java
@Component
public class CommandLineAppStartupRunner implements CommandLineRunner {
    private static final Logger LOG =
      LoggerFactory.getLogger(CommandLineAppStartupRunner.class);

    public static int counter;

    @Override
    public void run(String...args) throws Exception {
        LOG.info("Increment counter");
        counter++;
    }
}
```
Можно запускать несколько CommandLineRunner одновременно, например чтобы распаралелить сложную логику. Управлять их порядком через @Order. Каждый Runner может иметь свои собственные зависимости

## Реактивное программирование
Реактивное программирование — это программирование в многопоточной среде.

Реактивный подход повышает уровень абстракции вашего кода и вы можете сконцентрироваться на взаимосвязи событий, которые определяют бизнес-логику, вместо того, чтобы постоянно поддерживать код с большим количеством деталей реализации. Код в реактивном программировании, вероятно, будет короче.

Поток — это последовательность, состоящая из постоянных событий, отсортированных по времени. В нем может быть три типа сообщений: значения (данные некоторого типа), ошибки и сигнал о завершении работы. Рассмотрим то, что сигнал о завершении имеет место для экземпляра объекта во время нажатия кнопки закрытия.

Мы получаем эти cгенерированные события асинхронно, всегда. Согласно идеологии реактивного программирования существуют три вида функций: те, которые должны выполняться, когда некоторые конкретные данные будут отправлены, функции обработки ошибок и другие функции с сигналами о завершении работы программы. Иногда последнее два пункта можно опустить и сосредоточится на определении функций для обработки значений. Слушать(listening) поток означает подписаться(subscribing) на него. То есть функции, которые мы определили это наблюдатели(observers). А поток является субъектом который наблюдают. 

Критерии реактивного приложения:
__Responsive__. Разрабатываемая система должна отвечать быстро и за определенное заранее заданное время. Кроме того система должна быть достаточно гибкой для самодиагностики и починки.

Что это значит на практикте? Традиционно при запросе некоторого сервиса мы идем в базу данных, вынимаем необходимый объем информации и отдаем ее пользователю. Здесь все хорошо, если наша система достаточно быстрая и база данных не очень большая. Но что, если время формирования ответа гораздно больше ожидаемого? Кроме того, у пользователя мог пропасть интернет на несколько миллисекунд. Тогда все усилия по выборке данных и формированию ответа пропадают. Вспомните gmail или facebook. Когда у вас плохой интернет, вы не получаете ошибку, а просто ждете результат больше обычного. Кроме того, этот пункт говорит нам о том, что ответы и запросы должны быть упорядочены и последовательны.

__Resilient__. Система остается в рабочем состоянии даже, если один из компонентов отказал. 

Другими словами, компоненты нашей системы должны быть досточно гибкими и изолированными друг от друга. Достигается это путем репликаций. Если, например, одна реплика PostgreSQL отказала, необходимо сделать так, чтобы всегда была доступна другая. Кроме того, наше приложение должно работать во множестве экземпляров.

__Elastic__. Система должна занимать оптимальное количество ресурсов в каждый промежуток времени. Если у нас высокая нагрузка, то необходимо увеличить количество экзепляров приложения. В случае малой нагрузки ресурсы свободных машин должны быть очищены. Типичный инструменты реализации данного принципа: Kubernetes.

__Message Driven__. Общение между сервисами должно происходить через асинхронные сообщения. Это значит, что каждый элемент системы запрашивает информацию из другого элемента, но не ожидает получение результата сразу же. Вместо этого он продолжает выполняеть свои задачи. Это позволяет увеличить пользу от системных ресурсов и управлять более гибко возникающими ошибками. Обычно такой результат достигается через реактивное программирование.

[к оглавлению](#spring)

## Паттерны в Spring Framework
Вот некоторые известные паттерны, используемые в Spring Framework:
+ Chain of Responsibility - это поведенческий паттерн проектирования, который позволяет передавать запросы последовательно по цепочке обработчиков. Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи. Ему Spring Security
+ Singleton (Одиночка) - Паттерн Singleton гарантирует, что в памяти будет существовать только один экземпляр объекта, который будет предоставлять сервисы. Spring область видимости бина (scope) по умолчанию равна singleton и IoC-контейнер создаёт ровно один экземпляр объекта на Spring IoC-контейнер. Spring-контейнер будет хранить этот единственный экземпляр в кэше синглтон-бинов, и все последующие запросы и ссылки для этого бина получат кэшированный объект. Рекомендуется использовать область видимости singleton для бинов без состояния. Область видимости бина можно определить как singleton или как prototype (создаётся новый экземпляр при каждом запросе бина).
+ Model View Controller (Модель-Представление-Контроллер) - Преимущество Spring MVC в том, что ваши контроллеры являются POJO, а не сервлетами. Это облегчает тестирование контроллеров. Стоит отметить, что от контроллеров требуется только вернуть логическое имя представления, а выбор представления остаётся за ViewResolver. Это облегчает повторное использование контроллеров при различных вариантах представления.
+ Front Controller (Контроллер запросов) - Spring предоставляет DispatcherServlet, чтобы гарантировать, что входящий запрос будет отправлен вашим контроллерам.Паттерн Front Controller используется для обеспечения централизованного механизма обработки запросов, так что все запросы обрабатываются одним обработчиком. Этот обработчик может выполнить аутентификацию, авторизацию, регистрацию или отслеживание запроса, а затем передать запрос соответствующему контроллеру.
View Helper отделяет статическое содержимое в представлении, такое как JSP, от обработки бизнес-логики.
+ Dependency injection и Inversion of control (IoC) (Внедрение зависимостей и инверсия управления) - IoC-контейнер в Spring, отвечает за создание объекта, связывание объектов вместе, конфигурирование объектов и обработку всего их жизненного цикла от создания до полного уничтожения. В контейнере Spring используется инъекция зависимостей (Dependency Injection, DI) для управления компонентами приложения. Эти компоненты называются "Spring-бины" (Spring Beans).
+ Service Locator (Локатор служб) - ServiceLocatorFactoryBean сохраняет информацию обо всех бинах в контексте. Когда клиентский код запрашивает сервис (бин) по имени, он просто находит этот компонент в контексте и возвращает его. Клиентскому коду не нужно писать код, связанный со Spring, чтобы найти бин. Паттерн Service Locator используется, когда мы хотим найти различные сервисы, используя JNDI. Учитывая высокую стоимость поиска сервисов в JNDI, Service Locator использует кеширование. При запросе сервиса первый раз Service Locator ищет его в JNDI и кэширует объект. Дальнейший поиск этого же сервиса через Service Locator выполняется в кэше, что значительно улучшает производительность приложения.
+ Observer-Observable (Наблюдатель) - Используется в механизме событий ApplicationContext. Определяет зависимость "один-ко-многим" между объектами, чтобы при изменении состояния одного объекта все его подписчики уведомлялись и обновлялись автоматически.
+ Context Object (Контекстный объект) - Паттерн Context Object, инкапсулирует системные данные в объекте-контексте для совместного использования другими частями приложения без привязки приложения к конкретному протоколу. ApplicationContext является центральным интерфейсом в приложении Spring для предоставления информации о конфигурации приложения.
+ Proxy (Заместитель) - позволяет подставлять вместо реальных объектов специальные объекты-заменители. Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу.
+ Factory (Фабрика) - определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.
+ Template (Шаблон) - Этот паттерн широко используется для работы с повторяющимся бойлерплейт кодом (таким как, закрытие соединений и т. п.).

[к оглавлению](#spring)

## AOP и составные части
Аспектно-ориентированное программирование (АОП) — это парадигма программирования, целью которой является повышение модульности за счет разделения междисциплинарных задач. Это достигается путем добавления дополнительного поведения к существующему коду без изменения самого кода.

ООП, AOP и Spring - взаимодополняющие технологии, которые позволяют решать сложные проблемы путем разделения функционала на отдельные модули. АОП предоставляет возможность реализации сквозной логики - т.е. логики, которая применяется к множеству частей приложения - в одном месте и обеспечения автоматического применения этой логики по всему приложению. Подход Spring к АОП заключается в создании "динамических прокси" для целевых объектов и "привязывании" объектов к конфигурированному совету для выполнения сквозной логики.

Аспект (Aspect) - Это модуль, который имеет набор программных интерфейсов, которые обеспечивают сквозные требования. К примеру, модуль логирования будет вызывать АОП аспект для логирования. В зависимости от требований, приложение может иметь любое количество аспектов.

Объединённая точка (Join point) - Это такая точка в приложении, где мы можем подключить аспект. Другими словами, это место, где начинаются определённые действия модуля АОП в Spring.

Совет (Advice) - Это фактическое действие, которое должно быть предпринято до и/или после выполнения метода. Это конкретный код, который вызывается во время выполнения программы. 
+ before - Запускает совет перед выполнением метода.
+ after - Запускает совет после выполнения метода, независимо от результата его работы (кроме случая остановки работы JVM).
+ after-returning - Запускает совет после выполнения метода, только в случае его успешного выполнения.
+ after-throwing - Запускает совет после выполнения метода, только в случае, когда этот метод “бросает”  исключение.
+ around - Запускает совет до и после выполнения метода.
При этом инпоинты видят только начало и конец метода. Например, если метод выполняет транзакцию и где-то в середине кода try/catch поймал exception, транзакция все равно будет свершена, rollback не произойдет. В этом случае нужно пробрасывать ошибку за пределы метода.

Срез точек (Pointcut) - Срезом называется несколько объединённых точек (join points), в котором должен быть выполнен совет.

Введение (Introduction) - Это сущность, которая помогает нам добавлять новые атрибуты и/или методы в уже существующие классы.

Целевой объект (Target object) - Это объект на который направлены один или несколько аспектов.

Плетение (Weaving) - Это процесс связывания аспектов с другими объектами приложения для создания совета. Может быть вызван во время компиляции, загрузки или выполнения приложения.

С помощью АОП мы можем прописать, например, что будет выполняться до или после какого-то действия. Прописываем это один раз и этот функционал будет работать везде. Например нам нужно сделать логирование во всех методах @Service, с ООП нам бы пришлось прописывать этот функционал в каждом методе для всех @Service. А с АОП мы можем в конфигах прописать для @Service что будет происходить с каждым вызовом его методов, - в нашем случае писать логи. Элементы АОП такие как аспекты также используются в транзакциях спринга.

## Spring AOP vs ASPECTJ
AspectJ де-факто является стандартом реализации АОП. Реализация АОП от Spring имеет некоторые отличия:
+ Spring AOP немного проще, т.к. нет необходимости следить за процессом связывания.
+ Spring AOP поддерживает аннотации AspectJ, таким образом мы можем работать в спринг проекте похожим образом с AspectJ проектом.Spring + AOP поддерживает только proxy-based АОП и может использовать только один тип точек соединения - Method Invocation. AspectJ поддерживает все виды точек соединения.
+ Недостатком Spring AOP является работа только со своими бинами, которые существуют в Spring Context.

[к оглавлению](#spring)

## Некоторые частые аннотации Spring
+ @Autowired - используется для автоматического связывания зависимостей в spring beans.
+ @Bean - В классах конфигурации Spring, @Bean используется для для непосредственного создания бина.
+ @Controller - класс фронт контроллера в проекте Spring MVC.
+ @ConditionalOn* - Создает бин если выполняется условие. Condition - функциональный интерфейс, который содержит метод boolean matches(ConditionContext context,  AnnotatedTypeMetadata metadata)
+ @Sheduler - Таймер. Раз в сколько-то секунд обрабатывать.
+ @Resource - Java аннотация, которой можно внедрить зависимость.
+ @Requared - применяется к методам-сеттерам и означает, что значение метода должно быть установлено в XML-файле. Если этого не будет сделано, то мы получим BeanInitializationException. 
+ @RequestMapping - используется для мапинга (связывания) с URL для всего класса или для конкретного метода обработчика.
+ @ResponseBody - позволяет отправлять Object в ответе. Обычно используется для отправки данных формата XML или JSON.
+ @ResponseEntity - используется для формирования ответа HTTP с пользовательскими параметрами (заголовки, http-код и т.д.). ResponseEntity необходим, только если мы хотим кастомизировать ответ, добавив к нему статус ответа. Во всех остальных случаях будем использовать @ResponseBody.
+ @PathVariable - задает динамический маппинг значений из URI внутри аргументов метода обработчика, т.е.  позволяет вводить в URI переменную пути в качестве параметра
+ @Qualifier - используется совместно с @Autowired для уточнения данных связывания, когда возможны коллизии (например одинаковых имен\типов).
+ @Service - указывает что класс осуществляет сервисные функции.
+ @Scope - указывает scope у spring bean.
+ @Configuration, @ComponentScan и @Bean - для java based configurations.
+ AspectJ аннотации для настройки aspects и advices, @Aspect, @Before, @After,@Around, @Pointcut и др.
+ @PageableDefault - устанавливает значение по умолчанию для параметра разбиения на страницы
## Различия @Component, @Service, @Repository, @Controller
Они все служат для обозначения класса как Бин.

+ @Component - Spring определяет этот класс как кандидата для создания bean.
+ @Service - класс содержит бизнес-логику и вызывает методы на уровне хранилища. Ничем не отличается от классов с @Component.
+ @Repository - указывает, что класс выполняет роль хранилища (объект доступа к DAO). При этом отлавливает определенные исключения персистентности и пробрасывает их как одно непроверенное исключение Spring Framework. Для этого Spring оборачивает эти классы в прокси, и в контекст должен быть добавлен класс PersistenceExceptionTranslationPostProcessor 
+ @Controller - указывает, что класс выполняет роль контроллера MVC. Диспетчер сервлетов просматривает такие классы для поиска @RequestMapping.

## Различия @Controller и @RestController
@Controller помечает класс как контроллер HTTP запросов.

В Spring 4.0 была представлена аннотация @RestController. Применив ее к контроллеру автоматически добавляются аннотации @Controller, а так же @ResponseBody применяется ко всем методам.

## @Qualifier and @Primary
Если есть два одинаковых бина (по типу и имени) спринг не знает какой именно использовать и выдаёт exeption. Если над одним из этих бинов установленна @Primary, то его использовать предпочтительнее. Но если нам нужно использовать в работе оба этих бина, можно над каждым поставить @Qualifier и задать имя, для идентификации этих бинов.

## @Profile
Используя аннотацию @Profile - мы сопоставляем bean-компонент с этим конкретным профилем; аннотация просто берет имена одного (или нескольких) профилей. Отвечает за то - какие бины буду создаваться, в зависимости от профайла. Фактически реализована с помощью гораздо более гибкой аннотации @Conditional.

Рассмотрим базовый сценарий - у нас есть компонент, который должен быть активным только во время разработки, но не должен использоваться в производстве. Мы аннотируем этот компонент с профилем «dev», и он будет присутствовать в контейнере только во время разработки - в производственном процессе dev просто не будет активен.

Или можно задать @Profile("postgres") и @Profile("mysql"), а в application.properties указать, бин с каким профилем использовать = spring.profiles.active = mysql

По умолчанию, если профиль бина не определен, то он относится к профилю “default”. Spring также предоставляет способ установить профиль по умолчанию, когда другой профиль не активен, используя свойство «spring.profiles.default».
[к оглавлению](#spring)

## @LookUp
Используется для внедрения prototype bean в singleton bean.

__ПРИМЕР__ - Обычно бины в приложении Spring являтся синглтонами, и для внедрения зависимостей мы используем конструктор или сеттер.
Но бывает и другая ситуация: имеется бин Car – синглтон (singleton bean), и ему требуется каждый раз новый экземпляр бина Passenger. То есть Car – синглтон, а Passenger – так называемый прототипный бин (prototype bean). Жизненные циклы бинов разные. Бин Car создается контейнером только раз, а бин Passenger создается каждый раз новый – допустим, это происходит каждый раз при вызове какого-то метода бина Car.Вот здесь то и пригодится внедрение бина с помощью Lookup метода. Оно происходит не при инициализации контейнера, а позднее: каждый раз, когда вызывается метод.
```java
@Component
public class Car {
 @Lookup
 public Passenger createPassenger() {
    return null;
 }
 public String drive(String name) {
    Passenger passenger = createPassenger();
    passenger.setName(name);
    return "car with " + passenger.getName();
 }
}
```
Суть в том, что вы создаете метод-заглушку в бине Car и помечаете его специальным образом – аннотацией @Lookup. Этот метод должен возвращать бин Passenger, каждый раз новый. Контейнер Spring под капотом создаст подкласс и переопределит этот метод и будет вам выдавать новый экземпляр бина Passenger при каждом вызове аннотированного метода. Даже если в вашей заглушке он возвращает null (а так и надо делать, все равно этот метод будет переопределен).
```java
@Component
@Scope("prototype")
public class Passenger {
 private String name;
 public String getName() {
    return name;
 }
 public void setName(String name) {
    this.name = name;
 }
}
```
Теперь при вызове метода drive() мы можем везти каждый раз нового пассажира. Имя его передаётся в аргументе метода drive(), и затем задается сеттером во вновь созданном экземпляре пассажира.

[к оглавлению](#spring)

## @Target и @Retention
@Retention - указаываем, в какой момент жизни программного кода будет доступна аннотация
+ SOURCE - аннотация доступна только в исходном коде и сбрасывается во время создания .class файла;
+ CLASS - аннотация хранится в .class файле, но недоступна во время выполнения программы;
+ RUNTIME - аннотация хранится в .class файле и доступна во время выполнения программы.

@Target - указывается, какой элемент программы будет использоваться аннотацией
+ PACKAGE - назначением является целый пакет (package);
+ TYPE - класс, интерфейс, enum или другая аннотация:
+ METHOD - метод класса, но не конструктор (для конструкторов есть отдельный тип CONSTRUCTOR);
+ PARAMETER - параметр метода;
+ CONSTRUCTOR - конструктор;
+ FIELD - поля-свойства класса;
+ LOCAL_VARIABLE - локальная переменная (обратите внимание, что аннотация не может быть прочитана во время выполнения программы, то есть, данный тип аннотации может использоваться только на уровне компиляции как, например, аннотация @SuppressWarnings);
+ ANNOTATION_TYPE - другая аннотация.

[к оглавлению](#spring)

## @Resource
Java-аннотация @Resource может применяться к классам, полям и методам. Она пытается получить зависимость: сначала по имени, затем по типу, затем по описанию (Qualifier). Имя извлекается из имени аннотируемого сеттера или поля, либо берется из параметра name. При аннотировании классов имя не извлекается из имени класса по умолчанию, поэтому оно должно быть указано явно. 

Указав данную аннотацию у полей или методов с аргументом name, в контейнере будет произведен поиск компонентов с данным именем, и в контейнере должен быть бин с таким именем:
```java
@Resource(name="namedFile")
private File defaultFile;
```

Если указать её без аргументов, то Spring Framework поможет найти бин по типу. Если в контейнере несколько бинов-кандидатов на внедрение, то нужно использовать аннотацию @Qualifier:
```java
@Resource
@Qualifier("defaultFile")
private File dependency1;
@Resource
@Qualifier("namedFile")
private File dependency2;
```

__Разница с @Autowired:__
- ищет бин сначала по имени, а потом по типу;
- не нужна дополнительная аннотация для указания имени конкретного бина;
- @Autowired позволяет отметить место вставки бина как необязательное @Autowired(required = false);
- при замене Spring Framework на другой фреймворк, менять аннотацию @Resource не нужно

[к оглавлению](#spring)

## @Inject
Размещается над полями, методами, и конструкторами с аргументами. @Inject как и @Autowired в первую очередь пытается подключить зависимость по типу, затем по описанию и только потом по имени. Это означает, что даже если имя переменной ссылки на класс отличается от имени компонента, но они одинакового типа, зависимость все равно будет разрешена:
```java
@Inject
private ArbitraryDependency fieldInjectDependency;
//fieldInjectDependency - отличается от имени компонента, настроенного в контексте приложения:

@Bean
public ArbitraryDependency injectDependency() {
ArbitraryDependency injectDependency = new ArbitraryDependency();
return injectDependency;
}
```

Разность имён injectDependency и fieldInjectDependency не имеет значения, зависимость будет подобрана по типу ArbitraryDependency. Если в контейнере несколько бинов-кандидатов на внедрение, то нужно использовать аннотацию @Qualifier:
```java
@Inject
@Qualifier("defaultFile")
private ArbitraryDependency defaultDependency;

@Inject
@Qualifier("namedFile")
private ArbitraryDependency namedDependency;

//При использовании конкретного имени (Id) бина используем @Named:
@Inject
@Named("yetAnotherFieldInjectDependency")
private ArbitraryDependency yetAnotherFieldInjectDependency
```


## @Autowired vs @Resource vs @Inject
Аннотации для внедрения зависимостей.

@Resource (java) пытается получить зависимость: по имени, по типу, затем по описанию. Имя извлекается из имени аннотируемого сеттера или поля, либо берется из параметра name.

@Inject (java) или @Autowired (spring) в первую очередь пытается подключить зависимость по типу, затем по описанию и только потом по имени.

## @Conditional
Часто бывает полезно включить или отключить весь класс @Configuration, @Component или отдельные методы @Bean в зависимости от каких-либо условий.

Аннотация @Conditional указывает, что компонент имеет право на регистрацию в контексте только тогда, когда все условия соответствуют. Может применяться:
- над классами прямо или косвенно аннотированными @Component, включая классы @Configuration;
- над методами @Bean;
- как мета-аннотация при создании наших собственных аннотаций-условий.

Условия проверяются непосредственно перед тем, как должно быть зарегистрировано BeanDefinition компонента, и они могут помешать регистрации данного BeanDefinition. Поэтому нельзя допускать, чтобы при проверке условий мы взаимодействовали с бинами (которых еще не существует), с их BeanDefinition-ами можно.

Условия мы определяем в специально создаваемых нами классах, которые должны имплементировать функциональный интерфейс Condition с одним единственным методом, возвращающим true или false:
```java
boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata)
```
Создав свой класс и переопределив в нем метод matches() с нашей логикой, мы должны передать этот класс в аннотацию @Conditional в качестве параметра:
```java
@Configuration
@Conditional(OurConditionClass.class)
class MySQLAutoconfiguration {
//...
}
//Для того, чтобы проверить несколько условий, можно передать в @Conditional несколько классов с условиями:
@Bean
@Conditional(HibernateCondition.class, OurConditionClass.class)
Properties additionalProperties() {
//...
}
```


Если класс @Configuration помечен как @Conditional, то на все методы @Bean, аннотации @Import и аннотации @ComponentScan, связанные с этим классом, также будут распространяться указанные условия.

Для более детальной настройки классов, аннотированных @Configuration, предлагается использовать интерфейс ConfigurationCondition.

В одном классе - одно условие. Для создания более сложных условий можно использовать классы AnyNestedCondition, AllNestedConditions и NoneNestedConditions.

В Spring Framework имеется множество готовых аннотаций (и связанных с ними склассами-условиями, имплементирующими интерфейс Condition), которые можно применять совместно над одним определением бина:

__ConditionalOnBean__ Условие выполняется, в случае если присутствует нужный бин в BeanFactory.
__ConditionalOnClass__ Условие выполняется, если нужный класс есть в classpath.
__ConditionalOnCloudPlatform__ Условие выполняется, когда активна определенная платформа.
__ConditionalOnExpression__ Условие выполняется, когда SpEL выражение вернуло положительное значение.
__ConditionalOnJava__ Условие выполняется, когда приложение запущено с определенной версией JVM.
__ConditionalOnJndi__ Условие выполняется, только если через JNDI доступен определенный ресурс.
__ConditionalOnMissingBean__ Условие выполняется, в случае если нужный бин отсутствует в контейнере.
__ConditionalOnMissingClass__ Условие выполняется, если нужный класс отсутствует в classpath.
__ConditionalOnNotWebApplication__ Условие выполняется, если контекст приложения не является веб контекстом.
__ConditionalOnProperty__ Условие выполняется, если в файле настроек заданы нужные параметры.
__ConditionalOnResource__ Условие выполняется, если присутствует нужный ресурс в classpath.
__ConditionalOnSingleCandidate__ Условие выполняется, если bean-компонент указанного класса уже содержится в контейнере и он единственный.
__ConditionalOnWebApplication__ Условие выполняется, если контекст приложения является веб контекстом.



## Транзакции в Spring и Hibernate

**Транзакция** – это _единица работы с базой данных_, которая должна быть выполнена целиком или не выполнена вовсе (**атомарность**). **Spring** предоставляет мощную инфраструктуру для управления транзакциями поверх JDBC/ORM, позволяя разработчику лишь обозначить границы транзакции, а остальное Spring выполнит за него. При использовании **Hibernate** (или **JPA**) **Spring** «связывает» свою декларативную транзакцию с транзакцией Hibernate, обеспечивая согласованность. Основным инструментом декларативных транзакций в Spring является аннотация **@Transactional** на методах или классах, но под капотом это всегда **AOP-прокси** и **PlatformTransactionManager**. Spring создает динамический прокси для бина с **@Transactional**, и именно этот прокси перехватывает вызов метода: он открывает соединение с БД, `setAutoCommit(false)`, выполняет метод и, в конце либо делает `commit`, либо `rollback` в зависимости от результата (обычно откатывает при непроверяемых исключениях`).` Проще говоря: вызывая аннотированный метод, вы получаете «логическую транзакцию» Spring, которая материализуется в одну или несколько физических транзакций JDBC (соединений с `auto-commit=false`). Суть работы: Spring-инфраструктура через **TransactionInterceptor** (AOP-перехватчик) делегирует **Manager**-у транзакций (**PlatformTransactionManager**) выполнение операций `getTransaction()`, `commit()` и `rollback()`. В итоге при входе в **@Transactional**-метод Spring вызывает `transactionManager.getTransaction(...)`, а при выходе – `commit()` или `rollback()`.

**Декларативный vs программный подход**

Spring поддерживает декларативные транзакции (аннотация **@Transactional**) и программные (с помощью **TransactionTemplate** и явного вызова **PlatformTransactionManager**). Для интервью обычно достаточно знать декларативный – он более удобен и чаще используется. При **@Transactional** вы не пишете код управления транзакцией – Spring делает это за вас через прокси. Например, в простейшем случае:

```java
@Service
public class AccountService {
    @Autowired
    private AccountRepository repo;

    @Transactional
    public void transfer(Long fromId, Long toId, BigDecimal amount) {
        Account from = repo.findById(fromId).get();
        Account to = repo.findById(toId).get();
        from.debit(amount);
        to.credit(amount);
        repo.save(from);
        repo.save(to);
        // Если в любом месте произойдет unchecked-исключение, Spring откатит транзакцию 
    }
}
```

Здесь **Spring** создаст **AOP-прокси** `AccountService`. При вызове `transfer(...)` прокси сначала вызовет `transactionManager.getTransaction(...)`, затем выполнит метод и в конце закоммитит или откатит изменения. Программный подход с **TransactionTemplate** выглядит примерно так (но встречается реже):

```java
@Service
public class PaymentService {
    private final TransactionTemplate tx;

    public PaymentService(PlatformTransactionManager tm) {
        this.tx = new TransactionTemplate(tm);
    }

    public void processPayment(Payment payment) {
        tx.execute(status -> {
            // код внутри execute выполняется в транзакции
            paymentRepository.save(payment);
            return null;
        });
    }
}
```

При `execute` внутри создается транзакция, а после возвращения из лямбды Spring сам совершит `commit` или `rollback` в зависимости от того, было ли исключение.

**Spring Boot** автоматически настраивает нужный **PlatformTransactionManager**. При использовании **JPA/Hibernate** в classpath Spring Boot подключит **JpaTransactionManager**. Поэтому в типичном Spring Boot-приложении с `spring-boot-starter-data-jpa` дополнительных конфигураций не требуется – транзакционный менеджер создается по умолчанию. Если же нужно настроить руками (например, при нескольких БД), можно объявить бин **PlatformTransactionManager** и пометить конфигурацию **@EnableTransactionManagement**. Главное – помните, что аннотация **@Transactional** будет работать только при включенном **@EnableTransactionManagement** или если вы пользуетесь Spring Boot (где она уже включена по умолчанию).

**Прокси и аспекты: как работает @Transactional**

Spring Declarative Transactions строятся на **AOP-прокси**. Когда Spring контейнер видит **@Transactional** на бине (классе или методе), он оборачивает этот бин прокси-объектом. По умолчанию используются **JDK Dynamic Proxy** (если бин реализует интерфейс) или **CGLIB** (подкласс). Этот прокси перехватывает вызовы к методам и перед выполнением делегирует управление **TransactionInterceptor**. Проще говоря: при вызове метода вы на самом деле работаете с прокси, который начал транзакцию перед реальным вызовом и завершает её после него.

**TransactionInterceptor** – это AOP-адаптер, расширяющий класс **TransactionAspectSupport**, который и содержит логику работы с **PlatformTransactionManager**. Интерцептор делает примерно следующее (упрощенно):

```
if (метод помечен @Transactional) {
    txStatus = txManager.getTransaction(definition);
    try {
        результат = invokeTargetMethod(...);
        txManager.commit(txStatus);
    } catch (Throwable e) {
        txManager.rollback(txStatus);
        throw e;
    }
} else {
    результат = invokeTargetMethod(...);
}
```

То есть весь «магический» функционал сводится к вызовам `connection.setAutoCommit(false)` и `commit`/`rollback` вокруг вашего кода. При этом сами методы и исключения в вашем коде никак не меняются – Spring лишь ловит их для решения о фиксации транзакции.

Важно: прокси действует только при внешнем вызове через Spring-контейнер. Если внутри одного бина один метод вызывает другой метод того же класса, прокси не задействуется, и **@Transactional** для внутреннего вызова не работает. Это классическая ловушка:

```java
@Service
public class UserService {
    @Transactional
    public void invoice() {
        // открыта транзакция
        createPdf();  // вызов внутри класса – идет напрямую, proxy не участвует
        // остальной код...
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void createPdf() {
        // предполагается новая транзакция, но из-за прямого вызова
        // фактически сессия уже в транзакции invoice(), прокси не применился
    }
}
```

Несмотря на то что `createPdf()` помечен **REQUIRES_NEW**, при внутреннем вызове транзакция не прервется, и новой транзакции не будет. Фактически при вызове `invoice()` откроется одна физическая транзакция, а `createPdf()` выполнится внутри нее. Spring сам об этом предупреждает: «прокси больше не задействован – новой транзакции не будет». То же самое относится и к методам без **@Transactional**: если вызывающий метод не в транзакции, а внутренний метод помечен, то транзакции вообще не будет, потому что прокси не перехватывает прямой вызов.

**Другие нюансы прокси:**

- Прокси работают только на публичных методах. Если вы поставите **@Transactional** на `private` метод, он не будет работать – Spring не сможет его проксировать.

- Если класс помечен **@Transactional** (на уровне класса), то все его `public` методы унаследуют настройки транзакции. Не забывайте, что по умолчанию прокси также вызывают только `public`-методы`.

**Propagation и Isolation**

Аннотация **@Transactional** позволяет задавать параметры распространения (*propagation*) и изоляции транзакции.

**Propagation** определяет, что делать, если транзакционный метод вызывает другой транзакционный метод. По умолчанию **REQUIRED** – метод либо входит в существующую транзакцию, либо создает новую, если её нет. Spring поддерживает все стандартные режимы: **REQUIRED, REQUIRES_NEW, SUPPORTS, NOT_SUPPORTED, MANDATORY, NEVER, NESTED** и др. В простейшем разрезе:

- **REQUIRED** (по умолчанию): если есть активная транзакция – присоединиться к ней; иначе открыть новую (т.е. `setAutoCommit(false)`, выполнить, `commit`).

- **REQUIRES_NEW**: всегда открыть новую транзакцию (существующая при этом приостанавливается, а после возобновляется).

- **SUPPORTS**: выполнять метод в транзакции, если она есть; если нет – выполнить без транзакции (не делает ничего с JDBC).

- **MANDATORY**: требовать существующей транзакции – если её нет, бросает исключение.

- **NOT_SUPPORTED**: выполнять метод вне транзакции – если есть активная, приостановить её.

- **NEVER**: запрещать наличие транзакции – если есть, бросить исключение.

- **NESTED**: (для БД, поддерживающих savepoint) открыть вложенную транзакцию через `Savepoint`; фактически аналог **REQUIRED** в большинстве случаев, но при откате можно откатиться только до точки сохранения.

Практически: **REQUIRED** и **REQUIRES_NEW** открывают свои JDBC-транзакции (`setAutoCommit(false)`), а другие режимы в основном управляют только логикой (просто присоединяются, приостанавливают или требуют существующего контекста). Например, в выводах статьи: “REQUIRED (по умолчанию): либо использовать существующую транзакцию, либо открыть новую → `setAutocommit(false)`… “; “SUPPORTS: мне всё равно, транзакция есть или нет → (никаких действий JDBC)”; “REQUIRES_NEW: всегда своя транзакция → `setAutocommit(false)` ... `commit()`” и т.д. При этом запомним: если в одном бине один метод с **REQUIRED** вызывает метод с **REQUIRES_NEW** (и оба вызываются через прокси), то для каждого будет своя физическая транзакция. Но, как мы выяснили, внутренний вызов внутри того же класса это сломает, и будет одна транзакция.

**Уровень изоляции (isolation)** отвечает за проблемы конкурентного доступа (грязные чтения, неповторяющееся чтение, фантомные чтения и т.д.). По умолчанию Spring не меняет уровень изоляции (обычно это **READ_COMMITTED**). Можно указать, например, `@Transactional(isolation = Isolation.SERIALIZABLE)`, и Spring на уровне JDBC выполнит `connection.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE)`. В PostgreSQL стандартные уровни: `Read Uncommitted` (по факту ведет себя как `Read Committed`), `Read Committed` (по умолчанию) и т.д. Учтите, что слишком строгие уровни (**SERIALIZABLE**) могут замедлить систему, но иногда требуются для критически важных операций. Уровни изоляции – тема отдельная, но знать о них стоит.

**Hibernate и JPA: интеграция транзакций**

Когда мы используем **Hibernate** (или **JPA**), важно, чтобы транзакция **Spring** синхронизировалась с сессией Hibernate. Если бы мы просто вручную открывали `session.beginTransaction()` и в одном месте использовали Spring-транзакцию, а в другом Hibernate-транзакцию, они бы “не знали” друг о друге. Чтобы этого не происходило, в Spring используют специальные **PlatformTransactionManager**: `HibernateTransactionManager` (для чистого Hibernate) или `JpaTransactionManager` (для JPA/Hibernate). Spring Boot при `spring-boot-starter-data-jpa` по умолчанию регистрирует `JpaTransactionManager`. Эти менеджеры настроены так, чтобы транзакции Spring и Hibernate шли рука об руку.

По сути это значит: вместо обычного `DataSourceTransactionManager` мы используем `HibernateTransactionManager`/`JpaTransactionManager`, который при старте транзакции через сессию Hibernate под капотом делает `session.beginTransaction()`, а при `commit` вызывает `session.getTransaction().commit()`. При этом он позволяет Spring и Hibernate использовать одну и ту же транзакцию. Это означает: когда вы в **@Transactional**-методе (например, с `EntityManager` из JPA) вызываете `save()` или `flush()`, Hibernate знает, что это часть текущей транзакции, и корректно выполнит SQL. Без `JpaTransactionManager` каждая сторона (Spring и Hibernate) могла бы «открывать» собственную транзакцию независимо, что привело бы к проблемам (Hibernate мог бы делать autocommit и не ждать Spring, и наоборот).

Таким образом, при обычной конфигурации **Spring Boot + Hibernate** вам нужно лишь отмечать методы **@Transactional** (или интерфейс репозитория), а все менеджеры транзакций и интеграция настроятся сами. Для случаев нескольких источников можно указать нужный менеджер в `@Transactional("transactionManagerName")`.

**Особенности и подводные камни**

- **Приватные методы.** Если поставить **@Transactional** на `private` или `protected` метод, он **НЕ** будет работать, потому что прокси не перехватывает непубличные вызовы.

- **Внутренний вызов.** Уже упоминалось: вызов метода из того же класса (например, `this.doSomething()`) не пойдет через прокси, и аннотация внутри него игнорируется.

- **Исключения и откаты.** По умолчанию Spring откатывает транзакцию при непроверяемом (`Runtime`) исключении. Если выбрасывается checked (`Exception`), транзакция не будет откатана, если вы явно не указали `rollbackFor` или не выкинули unchecked-исключение. Это частый вопрос: если метод ловит исключение и не пробрасывает дальше, то транзакция завершится коммитом – пойманная ошибка считается успешно обработанной. Чтобы гарантированно откатить и по checked, можно писать `@Transactional(rollbackFor = Exception.class)` или вручную `status.setRollbackOnly()`.

- **readOnly.** Флаг `@Transactional(readOnly = true)` указывает Spring, что метод только читает данные. В идеале это позволяет оптимизировать (Hibernate, например, не будет делать лишний `flush()`). Однако это лишь подсказка; если попробовать изменить данные, они всё равно запишутся (но с большой вероятностью получите `OptimisticLockException` или поведение может быть неопределено).

- **Уровень изоляции Postgres.** PostgreSQL по умолчанию использует `READ_COMMITTED`. Если важен другой режим (скажем, `REPEATABLE_READ` или `SERIALIZABLE`), укажите это в `@Transactional(isolation = Isolation.REPEATABLE_READ)` и Spring выполнит `connection.setTransactionIsolation(...)`. Помните: в Postgres `READ_UNCOMMITTED` эквивалентен `READ_COMMITTED`, а `REPEATABLE_READ` в новейших версиях фактически предоставляет уровень, близкий к «сериализуемому» (она не допускает фантомных чтений в Postgres).

- **Классовая аннотация.** Если пометить `@Transactional` на уровне класса, все его публичные методы станут транзакционными. Это удобно, но помните, что private/защищенные всё равно работают как обычно, и внутренние вызовы между методами класса опять же не проходят через прокси – если `createOrder()` внутри вызовет `helper()`, это будет уже внутри той же транзакции (или без неё, если транзакций не было).

- **Физические vs логические транзакции.** Стоит различать: физическая транзакция – это реальное соединение с БД с `autoCommit=false`, которое делает `commit`/`rollback`. Логическая транзакция – это ваша область `@Transactional`, которая может включать одну или несколько физических транзакций. Например, при вложенных вызовах с разным `propagation` Spring может создавать несколько физических транзакций, но логически они «вложены». Большинство `propagation`-режимов (`SUPPORTS, MANDATORY, NOT_SUPPORTED` и др.) на самом деле не открывают новые транзакции на уровне JDBC, а лишь управляют присутствием или отсутствием логического контекста.

**Примеры кода с комментариями**

Ниже приведены примеры кода, которые часто встречаются на собеседованиях. В каждом случае объясняется, будет ли открыта транзакция и когда она фиксируется или откатывается. Предполагаем использование Spring Boot + PostgreSQL.

**Внутренний вызов методов того же класса:**

```java
@Service
public class MyService {
    @Transactional
    public void methodA() {
        // Транзакция открыта здесь (setAutoCommit(false))
        methodB(); // вызов другого метода того же класса
        // Транзакция завершится (commit) после выхода из methodA
    }

    @Transactional
    public void methodB() {
        // Этот метод помечен @Transactional, 
        // но вызов идет напрямую (без прокси), 
        // поэтому новая транзакция НЕ будет создана. 
        // Код выполнится внутри той же транзакции, что и methodA.
    }
}
```

**Вопрос: когда откроется и закоммитится транзакция?**

**Ответ:** При входе в `methodA()` Spring откроет транзакцию (примерно `getConnection().setAutoCommit(false)`). Вызов `methodB()` – внутренний – не проходит через прокси, поэтому служит просто обычным методом внутри `methodA`. Таким образом, `methodB()` выполняется внутри той же транзакции. Физическая транзакция закоммитится только после выхода из `methodA()`. Если в `methodB()` или после него возникнет unchecked-исключение, то все будет откатано. Если бы вызов `methodB()` шёл через прокси (например, из другого бина), тогда **@Transactional** у `methodB()` мог бы начать новую транзакцию или присоединиться к существующей, в зависимости от `propagation`.

**Взаимодействие двух бинов:**

```java
@Service
public class ServiceA {
    @Autowired
    private ServiceB serviceB;

    @Transactional
    public void methodA() {
        // Открыта транзакция ServiceA
        // Выполняем что-то в БД...
        serviceB.methodB(); // вызов метода из другого бина
        // Транзакция ServiceA коммитится здесь
    }
}

@Service
public class ServiceB {
    @Transactional(propagation = Propagation.REQUIRED)
    public void methodB() {
        // Если methodA уже открыл транзакцию, то methodB присоединится к ней.
        // Иначе откроет новую (но в данном случае methodA уже транзакционный).
        // Задать изменения...
    }
}
```

**Вопрос: сколько транзакций создастся?**

**Ответ:** В данном примере `ServiceA.methodA()` открывает транзакцию (REQUIRED). При вызове `serviceB.methodB()` (через прокси другого бина) `methodB` видит, что транзакция уже активна, и присоединяется к ней (так как REQUIRED по умолчанию). Физически будет одна транзакция, коммит которой произойдет после завершения `methodA()`. Если бы у `methodB()` был `REQUIRES_NEW`, то при каждом вызове создавалась бы новая вложенная физическая транзакция (с сохранением предыдущей), но и та откатилась бы независимо.

**REQUIRES_NEW внутри транзакции:**

```java
@Service
public class ServiceC {
    @Autowired
    private ServiceD serviceD;

    @Transactional
    public void outer() {
        // Открылась транзакция (Tx1)
        serviceD.inner(); // вызов другого бина
        // Сейчас Tx1 приостановлена, а Tx2 создана и закрыта внутри inner()
        // Возобновляется Tx1
        // ...
    }
}

@Service
public class ServiceD {
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void inner() {
        // Всегда создается новая транзакция (Tx2),
        // которая не зависит от внешней (Tx1).
        // После выполнения здесь выполняется commit Tx2.
    }
}
```

**Вопрос: что происходит с транзакциями?**

**Ответ:** При `outer()` открывается транзакция Tx1. Вызов `inner()` из другого бина через прокси приостановит Tx1 и откроет новую транзакцию Tx2 (REQUIRES_NEW). Внутри `inner()` изменения фиксируются (`commit`) для Tx2 при выходе из метода (если не было ошибки). После завершения `inner()`, Tx2 закрывается, возобновляется Tx1 и его выполнение продолжается. В конце `outer()` коммитит свои изменения. Таким образом, две разные транзакции, изолированные друг от друга. Если в `inner()` произошла ошибка и транзакция откатилась, это не отменит Tx1 (если ошибка обработана внутри `inner()`).

**MANDATORY без существующей транзакции:**

```java
@Service
public class ServiceE {
    @Autowired
    private ServiceF serviceF;

    public void someMethod() {
        serviceF.doSomething(); // вызываем метод с MANDATORY
    }
}

@Service
public class ServiceF {
    @Transactional(propagation = Propagation.MANDATORY)
    public void doSomething() {
        // ...
    }
}
```

**Вопрос: что случится при вызове someMethod()?**

**Ответ:** `ServiceE.someMethod()` не помечен `@Transactional`, то есть никакая транзакция не открыта. Затем вызывается `serviceF.doSomething()`, у которого `propagation = MANDATORY` – это означает «требую существующей транзакции». Поскольку транзакции нет, Spring бросит исключение `IllegalTransactionStateException`. Новая транзакция не создается автоматически – такова суть MANDATORY: если бы транзакция уже была открыта, метод присоединился бы к ней; иначе ошибка.

**Исключение перехвачено в транзакции:**

```java
@Service
public class ServiceG {
    @Autowired
    private Repository repo;

    @Transactional
    public void risky() {
        try {
            // операция, которая может бросить RuntimeException
            repo.save(new Entity(...));
            // например, // throw new RuntimeException("Ошибка");
        } catch (RuntimeException e) {
            // исключение поймано и обработано
            // Транзакция здесь НЕ откатится автоматически, т.к. исключение не вышло наружу
        }
        // после выхода из метода – транзакция будет коммичена
    }
}
```

**Вопрос: будет ли откат транзакции при возникновении RuntimeException внутри try?**

**Ответ:** Здесь код бросает `RuntimeException`, но ловит его внутри `catch`. Spring увидит только «успешное» завершение метода (так как исключение не вышло наружу). Поскольку нет необработанного исключения, по умолчанию транзакция завершится коммитом, и изменения сохранятся. Если нужна явная отмена даже при обработанном исключении, нужно либо выкинуть исключение дальше, либо вызвать `TransactionAspectSupport.currentTransactionStatus().setRollbackOnly()`, либо в `@Transactional(rollbackFor=RuntimeException.class)` указать `rollbackFor`, но даже это не поможет при явном `catch`. Важно: Spring откатывает транзакцию только при исключениях, которые не были перехвачены.

**Private метод с @Transactional:**

```java
@Service
public class ServiceH {
    @Transactional
    public void publicMethod() {
        privateMethod(); // вызов собственного метода
    }

    @Transactional
    private void privateMethod() {
        // Этот метод аннотирован, но private,
        // поэтому прокси его не обернет транзакцией.
        // Код выполнится БЕЗ транзакции!
    }
}
```

**Вопрос: пойдет ли privateMethod() в транзакцию?**

**Ответ:** Нет. `privateMethod()` не будет транзакционным, несмотря на аннотацию, потому что Spring-прокси не оборачивают приватные методы. При вызове `publicMethod()` транзакция открывается (так как он public и помечен), а `privateMethod()` выполнится внутри этой же транзакции (или без нее, если `publicMethod` был без транзакции). Аннотация на `privateMethod()` просто игнорируется, она не повлияет на поведение.

**Уровень изоляции и PostgreSQL:**

```java
@Service
public class OrderService {
    @Autowired
    private OrderRepository repo;

    @Transactional(isolation = Isolation.SERIALIZABLE)
    public void processOrder(Long orderId) {
        // важная транзакция с самым высоким уровнем изоляции
        Order order = repo.findById(orderId).get();
        // ... обработка заказа ...
        repo.save(order);
    }
}
```

**Вопрос: что делает isolation = Isolation.SERIALIZABLE и как это связано с Postgres?**

**Ответ:** Аннотация указывает Spring выставить уровень изоляции `TRANSACTION_SERIALIZABLE` на JDBC-соединении (`connection.setTransactionIsolation(...)`). PostgreSQL по умолчанию работает на `READ_COMMITTED`. Установка `SERIALIZABLE` гарантирует максимальную изоляцию (никаких незафиксированных изменений не будет видно, предотвращает фантомы), но может привести к ошибкам повторной попытки при высокой конкуренции. В примере это означает, что вся `processOrder` будет выполняться в отдельной транзакции с уровнем `SERIALIZABLE`. Spring просто вызовет JDBC-команду установки уровня изоляции перед выполнением метода.

**Аннотация на уровне класса:**

```java
@Service
@Transactional
public class OrderService {
    public void createOrder(Order order) {
        // эта операция – в транзакции
    }
    public void updateOrder(Order order) {
        // и эта – в транзакции
    }
    protected void helper() {
        // protected-метод – транзакция НЕ применяется (не проксируется)
    }
}
```

**Вопрос: какие методы класса OrderService будут выполняться в транзакции?**

**Ответ:** Все public методы класса (createOrder, updateOrder) будут выполняться в транзакции, т.к. на уровне класса стоит `@Transactional`. Метод `helper()` protected – транзакция на него не распространяется. Кроме того, внутренние вызовы между методами класса опять же не проходят через прокси – если `createOrder()` внутри вызовет `helper()`, это будет уже внутри той же транзакции (или без неё, если транзакций не было).

**Несколько источников данных:**

```java
@Service
public class MultiDbService {
    @Transactional("txManager1")
    public void methodForDB1() { /* работа с первой БД */ }

    @Transactional("txManager2")
    public void methodForDB2() { /* работа со второй БД */ }
}
```

**Вопрос: как обозначить, какой менеджер транзакций использовать?**

**Ответ:** Если в приложении настроено несколько источников (каждый со своим **PlatformTransactionManager**, например, `txManager1` и `txManager2`), в аннотации `@Transactional` указывают имя бина нужного менеджера: `@Transactional("txManager1")` или `("txManager2")`. Тогда при вызове Spring будет использовать именно тот менеджер, привязанный к конкретной БД. Без указания имени будет использован бин по умолчанию.

Каждый из этих примеров иллюстрирует тонкости работы транзакций в Spring с Hibernate/JPA. При изучении транзакций важно понимать механизм прокси, роли **PlatformTransactionManager**, разницу уровней распространения и изоляции. На собеседовании могут спрашивать, например, почему при вложенных вызовах получается только одна транзакция, или как заставить транзакцию откатиться при checked-исключении. Ответы на такие вопросы основаны на законах Spring: прокси перехватывают только внешние вызовы, откат по умолчанию по `RuntimeException`, различные `propagation` контролируют наличие транзакции, а физическая реализация всегда сводится к `setAutoCommit(false)` / `commit()` / `rollback()`


[к оглавлению](#spring)

## Как Spring работает с DAO
Spring DAO предоставляет возможность работы с доступом к данным с помощью технологий вроде JDBC, Hibernate в удобном виде. Существуют специальные классы: JdbcDaoSupport, HibernateDaoSupport, JdoDaoSupport, JpaDaoSupport.

Класс HibernateDaoSupport является подходящим суперклассом для Hibernate DAO. Он содержит методы для получения сессии или фабрики сессий. Самый популярный метод - getHibernateTemplate(), который возвращает HibernateTemplate. Этот темплейт оборачивает checked-исключения Hibernate в runtime-исключения, позволяя вашим DAO оставаться независимыми от исключений Hibernate.

[к оглавлению](#spring)

## Model vs ModelMap vs ModelAndView
Интерфейс Model инкапсулирует (объединяет) данные приложения. ModelMap реализует этот интерфейс, с возможностью передавать коллекцию значений. Затем он обрабатывает эти значения, как если бы они были внутри Map. Следует отметить, что в Model и ModelMap мы можем хранить только данные. Мы помещаем данные и возвращаем имя представления.

С другой стороны, с помощью ModelAndView мы возвращаем сам объект. Мы устанавливаем всю необходимую информацию, такую как данные и имя представления, в объекте, который мы возвращаем.

[к оглавлению](#spring)

## В чем разница между model.put() и model.addAttribute()?
Метод addAttribute отделяет нас от работы с базовой структурой hashmap. По сути addAttribute это обертка над put, где делается дополнительная проверка на null. Метод addAttribute в отличии от put возвращает modelmap.

[к оглавлению](#spring)

## PreparedStatementCreator
PreparedStatement - нужен для защиты от SQL-инъекций в запросах, а PreparedStatementCreator - для создания возврата PreparedStatement из connection. При этом он автоматически обрабатывает все исключения (кроме SQLExeption).

[к оглавлению](#spring)

## SOAP vs REST
SOAP – это целое семейство протоколов и стандартов, для обмена структурированными сообщениями. Это более тяжеловесный и сложный вариант с точки зрения машинной обработки. Поэтому REST работает быстрее.

REST - это не протокол и не стандарт, а архитектурный стиль. У этого стиля есть свои принципы: 

__Give every “thing” an ID__; 

__Link things together__ - Например, в страницу (представление) о Mercedes C218 хорошо бы добавить ссылку на страницу конкретно о двигателе данной модели, чтобы желающие могли сразу туда перейти, а не тратить время на поиск этой самой страницы; 

__Use standard methods__ - Имеется в виду, экономьте свои силы и деньги заказчика, используйте стандартные методы HTTP, например GET
http://www.example.com/cars/00345 для получения данных вместо определения собственных методов вроде getCar?id=00345; 

__Resources can have multiple representations__ - Одни и те же данные можно вернуть в XML или JSON для программной обработки или обернутыми в красивый дизайн для просмотра человеком; 

__Communicate statelessly__ - Да, RESTful сервис должен быть как идеальный суд – его не должно интересовать ни прошлое подсудимого (клиента), ни будущее – он просто выносит приговор (отвечает на запрос).

Термин RESTful (веб-)сервис всего лишь означает сервис, реализованный с использованием принципов REST.

При этом SOAP и REST – не конкуренты. Они представляют разные весовые категории и вряд ли найдется задача, для которой будет сложно сказать, какой подход рациональнее использовать – SOAP или REST.

[к оглавлению](#spring)

## Spring Data
Spring Data — дополнительный удобный механизм для взаимодействия с сущностями базы данных, организации их в репозитории, извлечение данных, изменение, в каких то случаях для этого будет достаточно объявить интерфейс и метод в нем, без имплементации.

+ CrudRepository - обеспечивает функции CRUD
+ PagingAndSortingRepository - предоставляет методы для разбивки на страницы и сортировки записей
+ JpaRepository - предоставляет связанные с JPA методы. При этом JpaRepository содержит полный API CrudRepository и PagingAndSortingRepository

Основное понятие в Spring Data — это репозиторий. Это несколько интерфейсов которые используют JPA Entity для взаимодействия с ней. Так например интерфейс ( public interface CrudRepository<T, ID extends Serializable> extends Repository<T, ID> ) обеспечивает основные операции по поиску, сохранения, удалению данных (CRUD операции).

Т.е. если того перечня что предоставляет интерфейс достаточно для взаимодействия с сущностью, то можно прямо расширить базовый интерфейс для своей сущности, дополнить его своими методами запросов и выполнять операции.

Понятно что этого перечня, скорее всего не хватит для взаимодействия с сущностью, и тут можно расширить свой интерфейс дополнительными методами запросов. Запросы к сущности можно строить прямо из имени метода. Для этого используется механизм префиксов find…By, read…By, query…By, count…By, и get…By, далее от префикса метода начинает разбор остальной части. Вводное предложение может содержать дополнительные выражения, например, Distinct. Далее первый By действует как разделитель, чтобы указать начало фактических критериев. Можно определить условия для свойств сущностей и объединить их с помощью And и Or.

Если нужен специфичный метод или его реализация, которую нельзя описать через имя метода, то это можно сделать через некоторый Customized интерфейс ( CustomizedEmployees) и сделать реализацию вычисления. А можно пойти другим путем, через указание запроса (HQL или SQL), как вычислить данную функцию. Отметив запрос аннотацией @Query.

Нативный запрос можно написать так:
```java
public interface RoleRepository extends JpaRepository<Role, Long>{
    Optional<Role> findRoleByRoleName(String name);
    
    @Modifying
    @Transactional
    @Query(value = "INSERT INTO user_roles (user_id, role_id) VALUE (:user_id, :role_id)", nativeQuery = true)
    void insertRoles(@Param("user_id) Long user_id, @Param("role_id") Long role_id);

    //можно использовать с EntityGraph, обычным, не NamedEntityGraph
    @EntityGraph(value = "customer.products")
    List<Customer> findAll(@Nullable Specification<Customer> specification)
```

## Конфигурация Spring Data
Поскольку мы используем JPA, нам нужно определить свойства для подключения к базе данных в файле persistence.xml, а не в hibernate.cfg.xml. Создайте новый каталог с именем META-INF в исходной папке проекта, чтобы поместить в него файл persistence.xml.

Затем прописать в вайле свойства для подключения к базе, например:
```java
<persistence-unit name="DataBaseName">
        <properties>
            <property name="javax.persistence.jdbc.url" value="jdbc:mysql://localhost:3306/sales" />
            <property name="javax.persistence.jdbc.user" value="root" />
            <property name="javax.persistence.jdbc.password" value="root" />
            <property name="javax.persistence.jdbc.driver" value="com.mysql.jdbc.Driver" />
            <property name="hibernate.show_sql" value="true" />
            <property name="hibernate.format_sql" value="true" />
        </properties>
    </persistence-unit>
```
Для работы с Spring Data JPA нам надо создать два beans-компонента: EntityManagerFactory и JpaTransactionManager. Поэтому создадим другой конфигурационный класс JpaConfig:
```java
@Configuration
@EnableJpaRepositories(basePackages = {"net.codejava.customer"})
@EnableTransactionManagement
public class JpaConfig {
    @Bean
    public LocalEntityManagerFactoryBean entityManagerFactory() {
        LocalEntityManagerFactoryBean factoryBean = new LocalEntityManagerFactoryBean();
        factoryBean.setPersistenceUnitName("SalesDB");
          
        return factoryBean;
    }
      
    @Bean
    public JpaTransactionManager transactionManager(EntityManagerFactory entityManagerFactory) {
        JpaTransactionManager transactionManager = new JpaTransactionManager();
        transactionManager.setEntityManagerFactory(entityManagerFactory);
          
        return transactionManager;
    } 
}
```
@EnableJpaRepositories: сообщает Spring Data JPA, что нужно искать классы репозитория в указанном пакете (net.codejava) для внедрения соответсвующего кода во время выполнения.

@EnableTransactionManagement: сообщает Spring Data JPA, чтобы тот генерировал код для управления транзакциями во время выполнения.

В этом классе первый метод создаёт экземпляр EntityManagerFactory для управления Persistence Unit нашей SalesDB (это имя указано выше в persistence.xml).

Последний метод создаёт экземпляр JpaTransactionManager для EntityManagerFactory, созданный методом ранее.

Это минимальная необходимая конфигурация для использования Spring Data JPA.

## Spring Security
Spring Security предоставляет широкие возможности для защиты приложения. Кроме стандартных настроек для аутентификации, авторизации и распределения ролей и маппинга доступных страниц, ссылок и т.п., предоставляет защиту от различных вариантов атак

Spring Security - это список фильтров в виде класса FilterChainProxy, интегрированного в контейнер сервлетов, и в котором есть поле List<SecurityFilterChain>. Каждый фильтр реализует какой-то механизм безопасности. Важна последовательность фильтров в цепочке.

![Image alt](https://github.com/Shell26/Java-Developer/raw/master/img/Spring8.png)

Когда мы добавляем аннотацию @EnableWebSecurity добавляется DelegatingFilterProxy, его задача заключается в том, чтобы вызвать цепочку фильтров (FilterChainProxy) из Spring Security. 

В Java-based конфигурации цепочка фильтров создается неявно.

Если мы хотим настроить свою цепочку фильтров, мы можем сделать это, создав класс, конфигурирующий наше Spring Security приложение, и имплементировав интерфейс WebSecurityConfigurerAdapter. В данном классе, мы можем переопределить метод:
```java
@Override
protected void configure(HttpSecurity http) throws Exception {
   http
   .csrf().disable()
   .authorizeRequests();
}
```

Именно этот метод конфигурирует цепочку фильтров Spring Security и логика, указанная в этом методе, настроит цепочку фильтров.

__Основные классы и интерфейсы__

__SecurityContext__ - интерфейс, отражающий контекст безопасности для текущего потока. Является контейнером для объекта типа Authentication. (Аналог - ApplicationContext, в котором лежат бины).

По умолчанию на каждый поток создается один SecurityContext. SecurityContext-ы хранятся в SecurityContextHolder.

Имеет только два метода: getAuthentication() и setAuthentication(Authentication authentication).
__SecurityContextHolder__ - это место, где Spring Security хранит информацию о том, кто аутентифицирован. Класс, хранящий в ThreadLocal SecurityContext-ы для каждого потока, и содержащий статические методы для работы с SecurityContext-ами, а через них с текущим объектом Authentication, привязанным к нашему веб-запросу.
![Image alt](https://github.com/Shell26/Java-Developer/raw/master/img/Spring9.png)

__Authentication__ - объект, отражающий информацию о текущем пользователе и его привилегиях. Вся работа Spring Security будет заключаться в том, что различные фильтры и обработчики будут брать и класть объект Authentication для каждого посетителя. Кстати объект Authentication можно достать в Spring MVC контроллере командой SecurityContextHolder.getContext().getAuthentication(). Authentication имеет реализацию по умолчанию - класс UsernamePasswordAuthenticationToken, предназначенный для хранения логина, пароля и коллекции Authorities.
__Principal__ - интерфейс из пакета java.security, отражающий учетную запись пользователя. В терминах логин-пароль это логин. В интерфейсе Authentication есть метод getPrincipal(), возвращающий Object. При аутентификации с использованием имени пользователя/пароля Principal реализуется объектом типа UserDetails.
__Credentials__ - любой Object; то, что подтверждает учетную запись пользователя, как правило пароль (отпечатки пальцев, пин - всё это Credentials, а владелец отпечатков и пина - Principal).
__GrantedAuthority__ - полномочия, предоставленные пользователю, например, роли или уровни доступа.
__UserDetails__ - интерфейс, представляющий учетную запись пользователя. Как правило модель нашего пользователя должна имплементировать его. Она просто хранит пользовательскую информацию в виде логина, пароля и флагов isAccountNonExpired, isAccountNonLocked, isCredentialsNonExpired, isEnabled, а также коллекции прав (ролей)пользователя. Данная информация позже инкапсулируется в объекты Authentication.
__UserDetailsService__ - интерфейс объекта, реализующего загрузку пользовательских данных из хранилища. Созданный нами объект с этим интерфейсом должен обращаться к БД и получать оттуда юзеров. используется чтобы создать UserDetails объект путем реализации единственного метода этого интерфейса
```java
UserDetails loadUserByUsername(String username) throws UsernameNotFoundException; 
```
__AuthenticationManager__ - основной стратегический интерфейс для аутентификации. Имеет только один метод, который срабатывает, когда пользователь пытается аутентифицироваться в системе:
```java
public interface AuthenticationManager {
Authentication authenticate(Authentication authentication)
throws AuthenticationException;
}
```

AuthenticationManager может сделать одну из 3 вещей в своем методе authenticate():

1. вернуть Authentication (с authenticated=true), если предполагается, что вход осуществляет корректный пользователь.
2. бросить AuthenticationException, если предполагается, что вход осуществляет некорректный пользователь.
3. вернуть null, если принять решение не представляется возможным.
   
Наиболее часто используемая реализация AuthenticationManager - родной класс ProviderManager, который содержит поле private List<AuthenticationProvider>providers со списком AuthenticationProvider-ов и итерирует запрос аутентификации по этому списку AuthenticationProvider-ов. Идея такого разделения - поддержка различных механизмов аутентификации на сайтах.
   
AuthenticationProvider - интерфейс объекта, выполняющего аутентификацию. Имеет массу готовых реализаций. Также можем задать свой тип аутентификации. Как правило в небольших проектах одна логика аутентификации - по логину и паролю. В проектах побольше логик может быть несколько: Google-аутентификация и т.д., и для каждой из них создается свой объект AuthenticationProvider.
   
AuthenticationProvider немного похож на AuthenticationManager, но у него есть дополнительный метод, позволяющий вызывающей стороне спрашивать, поддерживает ли он переданный ему объект Authentication, возможно этот AuthenticationProvider может поддерживать только аутентификацию по логину и паролю, но не поддерживать Googleаутентификацию:
```java
boolean supports(java.lang.Class<?> authentication)
```   
PasswordEncoder - интерфейс для шифрования/расшифровывания паролей. Одна из популярных реализаций - BCryptPasswordEncoder.
   
В случае, если нам необходимо добавить логику при успешной/неудачной аутентификации, мы можем создать класс и имплементировать интерфейсы AuthenticationSuccessHandler и AuthenticationFailureHandler соответственно, переопределив их методы.
   
Как это работает с формой логина и UserDetailsService:
   - Пользователь вводит в форму и отправляет логин и пароль.
   - UsernamePasswordAuthenticationFilter создает объект Authentication - UsernamePasswordAuthenticationToken, где в качестве Principal - логин, а в качестве Credentials - пароль.
   - Затем UsernamePasswordAuthenticationToken передаёт объект Authentication с логином и паролем AuthenticationManager-у.
   - AuthenticationManager в виде конкретного класса ProviderManager внутри своего списка объектов AuthenticationProvider, имеющих разные логики аутентификации, пытается аутентифицировать посетителя, вызывая его метод authenticate(). У каждого AuthenticationProvider-а:
      1 Метод authenticate() принимает в качестве аргумента незаполненный объект Authentication, например только с логином и паролем, полученными в форме логина на сайте. Затем с помощью UserDetailsService метод идёт в БД и ищет такого пользователя.
      2 Если такой пользователь есть в БД, AuthenticationProvider получает его из базы в виде объекта UserDetails. Объект Authentication заполняется данными из UserDetails - в него включаются Authorities, а в Principal записывается сам объект UserDetails, содержащий пользователя.
      3 Затем этот метод возвращает заполненный объект Authentication (прошли аутентификацию). Вызывается AuthenticationSuccessHandler.
      4 Если логин либо пароль неверные, то выбрасывается исключение. Вызывается AuthenticationFailureHandler.
   - Затем этот объект Authentication передается в AccessDecisionManager и получаем решение на получение доступа к запрашиваемой странице (проходим авторизацию).
   
Аннотации:
+ @EnableGlobalMethodSecurity - включает глобальный метод безопасности.
+ @EnableWebMvcSecurity - "включает" Spring Security. Не будет работать, если наш класс не наследует WebSecurityConfigurerAdapter
+ @Secured используется для указания списка ролей в методе
+ @PreAuthorize и @PostAuthorize обеспечивают контроль доступа на основе выражений. @PreAuthorize проверяет данное выражение перед входом в метод, тогда как аннотация @PostAuthorize проверяет его после выполнения метода и может изменить результат.
+ @PreFilter для фильтрации аргумента коллекции перед выполнением метода

[к оглавлению](#spring)

## Spring Boot
По сути, Spring Boot это просто набор классов конфигурации, которые создают нужные бины в контексте. Точно так же их можно создать руками, просто Boot это автоматизирует. При этом помогая решить проблему конфликтов разных версий компонентов.

Чтобы ускорить процесс управления зависимостями, Spring Boot неявно упаковывает необходимые сторонние зависимости для каждого типа приложения на основе Spring и предоставляет их разработчику посредством так называемых starter-пакетов (spring-boot-starter-web, spring-boot-starter-data-jpa и т.д.)

Starter-пакеты представляют собой набор удобных дескрипторов зависимостей, которые можно включить в свое приложение. Это позволит получить универсальное решение для всех, связанных со Spring технологий, избавляя программиста от лишнего поиска примеров кода и загрузки из них требуемых дескрипторов зависимостей. Например, если вы хотите начать использовать Spring Data JPA для доступа к базе данных, просто включите в свой проект зависимость spring-boot-starter-data-jpa и все будет готово (вам не придется искать совместимые драйверы баз данных и библиотеки Hibernate)

Например, если вы добавите Spring-boot-starter-web, Spring Boot автоматически сконфигурирует такие зарегистрированные бины, как DispatcherServlet, ResourceHandlers, MessageSource. Если вы используете spring-boot-starter-jdbc, Spring Boot автоматически регистрирует бины DataSource, EntityManagerFactory, TransactionManager и считывает информацию для подключения к базе данных из файла application.properties

В основе "магии" Spring Boot нет ничего магического, он использует совершенно базовые понятия из Spring Framework. В кратком виде процесс можно описать так:
+ Аннотация @SpringBootApplication включает сканирование компонентов и авто-конфигурацию через аннотацию @EnableAutoConfiguration
+ @EnableAutoConfiguration импортирует класс EnableAutoConfigurationImportSelector
+ EnableAutoConfigurationImportSelector загружает список конфигураций из файла META-INF/spring.factories
+ Каждая конфигурация пытается сконфигурить различные аспекты приложения (web, JPA, AMQP etc), регистрируя нужные бины и используя различные условия (наличие / отсутствие бина, настройки, класса и т.п.)
+ Созданный в итоге AnnotationConfigEmbeddedWebApplicationContext ищет в том же DI контейнере фабрику для запуска embedded servlet container
+ Servlet container запускается, приложение готово к работе!

Важное понятие Spring Boot это автоконфигурация. По сути, это просто набор конфигурационных классов, которые создают и регистрируют определенные бины в приложении. По большому счету, даже сам Embedded Servlet Container — это просто еще один бин, который можно сконфигурировать! Пара важных моментов, которые важно знать об автоконфигурации:

+ Включается аннотацией @EnableAutoConfiguration
+ Работает в последнюю очередь, после регистрации пользовательских бинов
+ Принимает решения о конфигурации на основании доступных в classpath классов, свойств в application.properties и т.п.
+ Можно включать и выключать разные аспекты автоконфигурации, и применять ее частично (например, только MySQL + JPA, но не веб)
+ Всегда отдает приоритет пользовательским бинам. Если ваш код уже зарегистрировал бин DataSource — автоконфигурация не будет его перекрывать

Логика при регистрации бинов управляется набором @ConditionalOn* аннотаций. Можно указать, чтобы бин создавался при наличии класса в classpath (@ConditionalOnClass), наличии существующего бина (@ConditionalOnBean), отсуствии бина (@ConditionalOnMissingBean) и т.п.

Отключить ненужные автоконфигурации можно при помощи свойств exclude и excludeName аннотаций @EnableAutoConfiguration, @ImportAutoConfiguration и @SpringBootApplication. Или в property задать SpringAutoconfiguration exclude и передать имена классов.

Можно отказаться от использования механизма автоконфигурации, вместо этого указывая необходимые автоконфигурации вручную. Для этого надо избавиться от аннотаций @SpringBootApplication и @EnableAutoConfiguration в коде вашего проекта, а для указания нужных конфигурационных классов использовать аннотации @SpringBootConfiguration и @ImportAutoConfiguration. Однако стоит помнить, что используемые автоконфигурации всё ещё могут содержать неиспользуемые компоненты.

__Как происходит автоконфигурация в Spring Boot:__

1. Отмечаем main класс аннотацией @SpringBootApplication (аннотация инкапсулирует в себе:@SpringBootConfiguration, @ComponentScan, @EnableAutoConfiguration), таким образом наличие @SpringBootApplication включает сканирование компонентов, автоконфигурацию и показывает разным компонентам Spring (например, интеграционным тестам), что это Spring Boot приложение.
```java
@SpringBootApplication
   public class DemoApplication {
   public static void main(String[] args) {
     SpringApplication.run(DemoApplication.class, args);
   }
   }
```
2. @EnableAutoConfiguration импортирует класс EnableAutoConfigurationImportSelector. Этот класс не объявляет бины сам, а использует так называемые фабрики.
3. Класс EnableAutoConfigurationImportSelector смотрит в файл META-INF/spring.factories и загружает оттуда список значений, которые являются именами классов (авто)конфигураций, которые Spring Boot импортирует. Т.е. аннотация @EnableAutoConfiguration просто импортирует ВСЕ (более 150) перечисленные в spring.factories конфигурации, чтобы предоставить нужные бины в контекст приложения.
4. Каждая из этих конфигураций пытается сконфигурировать различные аспекты приложения(web, JPA, AMQP и т.д.), регистрируя нужные бины. Логика при регистрации бинов управляется набором @ConditionalOn* аннотаций. Можно указать, чтобы бин создавался при наличии класса в classpath (@ConditionalOnClass), наличии существующего бина (@ConditionalOnBean), отсуствии бина (@ConditionalOnMissingBean) и т.п. Таким образом наличие конфигурации не значит, что бин будет создан, и в большинстве случаев конфигурация ничего делать и создавать не будет.
5. Созданный в итоге AnnotationConfigEmbeddedWebApplicationContext ищет в том же DI контейнере фабрику для запуска embedded servlet container.
6. Servlet container запускается, приложение готово к работе!

[к оглавлению](#spring)

## Starter packs
Чтобы ускорить процесс управления зависимостями, Spring Boot неявно упаковывает необходимые сторонние зависимости для каждого типа приложения на основе Spring и предоставляет их разработчику посредством так называемых starter-пакетов. Starter-пакеты представляют собой набор удобных дескрипторов зависимостей, которые можно включить в свое приложение. 

Делаем свой Starter-пакет:
+ Создаем AutoConfiguration-класс, который Spring Boot находит при запуске приложения и использует для автоматического создания и конфигурирования бинов.
```java
@Configuration   //указываем, что наш класс является конфигурацией (@Configuration)
@ConditionalOnClass({SocialConfigurerAdapter.class, VKontakteConnectionFactory.class})   //означает, что бины будут создаваться при наличии в classpath SocialConfigurerAdapter и VKontakteConnectionFactory. Таким образом, без нужных для нашего стартера зависимостей бины создаваться не будут.

@ConditionalOnProperty(prefix= "ru.shadam.social-vkontakte", name = { "client-id", "client-secret"})     //означает, что бины будут создаваться только при наличии property ru.shadam.social-vkontakte.client-id и ru.shadam.social-vkontakte.client-secret.
@AutoConfigureBefore(SocialWebAutoConfiguration.class)
@AutoConfigureAfter(WebMvcAutoConfiguration.class)          //означает, что наш бин будет инициализироваться после WebMvc и до SocialWeb. Это нужно, чтобы к моменту инициализации SocialWeb наши бины уже были зарегистрированы.
public class VKontakteAutoConfiguration {
}
```
+ Расширяем SocialConfigurationAdapter, который нужен для того чтобы зарегистрировать нашу ConnectionFactory. Для этого переопределяем метод addConnectionFactories(ConnectionFactoryConfigurer, Environment)
+ Создание файла, позволяющего SpringBoot найти наш AutoConfiguration класс. Для этого существует специальный файл spring.factories, который нужно поместить в META-INF папку получающегося jar-файла. В этом файле нам надо указать наш AutoConfiguration-класс.
+ Подключить получившийся jar-файл к Spring Boot проекту и задать в конфигурации пути на класс, который создали до этого.

https://www.youtube.com/watch?v=nGfeSo52_8A&t=1735s (с 30мин)

[к оглавлению](#spring)

## Как внедрить java.util.Properties в Spring Bean
Используя SpEL
```java
@Value("${maxReadResults}") 
private int maxReadResults;
```
Или определить propertyConfigure bean в XML.

[к оглавлению](#spring)

## Что нового в Spring 5
+ Используется JDK 8+ (Optional, CompletableFuture, Time API, java.util.function, default methods)
+ Поддержка Java 9 (Automatic-Module-Name in 5.0, module-info in 6.0+, ASM 6)
+ Поддержка HTTP/2 (TLS, Push), NIO/NIO.2, Kotlin
+ Поддержка Kotlin
+ Реактивность (Web on Reactive Stack)
+ Null-safety аннотации(@Nullable), новая документация
+ Совместимость с Java EE 8 (Servlet 4.0, Bean Validation 2.0, JPA 2.2, JSON Binding API 1.0)
+ Поддержка JUnit 5 + Testing Improvements (conditional and concurrent)
+ Удалена поддержка: Portlet, Velocity, JasperReports, XMLBeans, JDO, Guava

[к оглавлению](#spring)

## RestTemplate и JDBCTemplate
Класс RestTemplate является центральным инструментом для выполнения клиентских HTTP-операций в Spring. Он предоставляет несколько утилитных методов для создания HTTP-запросов и обработки ответов.

JdbcTemplate - базовый класс, который управляет обработкой всех событий и связями с БД посредством sql запросов. При этом все пишется программистом, не автоматизированно.

[к оглавлению](#spring)

## Socket 
Класс для двунаправленное соединением между клиентом и сервером. Например пользователь чатится с другим пользователем, сокет обрабатывает эти сообщения. Отвечает за создание соединения и пересылку данных.

# Подробно про Spring Cloud — что входит и для чего (полное руководство)

> Документ даёт обзор ключевых проектов Spring Cloud, их назначение, когда и почему использовать, а также краткие примеры конфигурации и кода.

---
## Краткая вводная
**Spring Cloud** — набор библиотек и проектов, облегчающих реализацию распространённых паттернов распределённых систем и микросервисной архитектуры: централизованная конфигурация, обнаружение сервисов, балансировка нагрузки, маршрутизация (API Gateway), отказоустойчивость (circuit breakers), распределённая трассировка, интеграция с брокерами сообщений и оркестрация потоков данных. Spring Cloud предоставляет интеграцию с экосистемой Spring (Spring Boot) и с внешними системами (Consul, Eureka, Kafka, RabbitMQ, Kubernetes и др.).

---
## Основные компоненты и проекты (обзор)
Ниже перечислены самые важные модули/проекты Spring Cloud с подробным описанием их цели и типичным сценарием применения.

### 1) Spring Cloud Config — централизованная конфигурация
**Назначение:** хранить свойства (application.yml/properties) для множества приложений в одном месте, поддерживать версии, профили окружений и безопасное хранение секретов. Часто конфиг-сервер использует хранилище Git/Filesystem/HashiCorp Vault/Consul. Клиенты (Spring Boot apps) автоматически читают конфигурацию при старте и (опционально) при обновлении через Spring Cloud Bus/refresh.  
**Когда использовать:** когда вам нужна единая точка управления настройками для множества микросервисов и возможность менять конфигурацию централизованно. citeturn0search5

**Пример (server application.yml):**
```yaml
spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/your-org/config-repo
```
**Пример (клиент):**
```yaml
spring:
  application:
    name: orders-service
spring:
  cloud:
    config:
      uri: http://config-server:8888
```
(в коде подключаете dependency `spring-cloud-config-server` для сервера и `spring-cloud-starter-config` для клиента). citeturn0search1turn0search13

---
### 2) Service Discovery (Eureka, Consul, Zookeeper)
**Назначение:** позволить сервисам регистрироваться в реестре и находить друг друга по имени (service registry + discovery). Это упрощает динамическое масштабирование и устойчивая маршрутизация. Варианты: **Eureka** (Netflix, простая интеграция в Spring Cloud), **Consul** (HashiCorp, поддерживает KV и health checks), **Zookeeper**. citeturn0search4

**Когда:** если у вас динамически меняющиеся инстансы (autoscaling, контейнеры) и нужно разрешать имена сервисов без статических адресов. Если инфраструктура — Kubernetes, часто используют встроенный DNS/Service Discovery и/или Service Mesh (см. пункт про Kubernetes/Service Mesh).

**Пример регистрации клиента (Eureka):**
```yaml
eureka:
  client:
    serviceUrl:
      defaultZone: http://eureka-server:8761/eureka/
spring:
  application:
    name: inventory-service
```
(зависимость `spring-cloud-starter-netflix-eureka-client`)

---
### 3) Балансировка нагрузки (Client-side vs Server-side)
- **Client-side (e.g. Ribbon)** — клиент получает список инстансов из реестра и сам выбирает ближайший по алгоритму. Ribbon — раньше популярный клиентский загрузчик, сейчас в большинстве случаев **не рекомендуется** (deprecated in Spring Cloud releases) — вместо него используют **Spring Cloud LoadBalancer**. citeturn1search18turn1search1  
- **Server-side** — внешний балансировщик (NGINX, AWS ELB, Kubernetes Service) распределяет трафик без участия клиента.

**Рекомендация:** при современных Kubernetes/Cloud сценариях — полагаться на инфраструктурные LB и/или Spring Cloud LoadBalancer для простых случаев; избегать старых Ribbon. citeturn1search1

---
### 4) API Gateway (Spring Cloud Gateway, Zuul — legacy)
**Назначение:** единая точка входа для клиентов (routing), централизация cross-cutting concerns: аутентификация, авторизация, rate-limiting, logging, CORS, circuit-breaker integration, мониторинг.  
**Популярный выбор:** **Spring Cloud Gateway** — современная, реактивная реализация на Project Reactor; поддерживает фильтры, маршруты, predicate/route configuration, интеграцию с Spring Security и Micrometer. **Zuul 1/2** и другие прокси использовались ранее, но Gateway — предпочтительный выбор для новых проектов. citeturn0search2turn0search6

**Пример простого маршрута (application.yml):**
```yaml
spring:
  cloud:
    gateway:
      routes:
      - id: orders
        uri: lb://orders-service
        predicates:
        - Path=/orders/**
        filters:
        - RewritePath=/orders/(?<segment>.*), /$\{segment}
```

---
### 5) Декларативные REST-клиенты — OpenFeign
**Назначение:** упрощённая декларативная клиентская интеграция: вы описываете интерфейс `@FeignClient("service-name")` и Spring создаёт прокси, использующий HTTP (и интеграцию с load-balancer, encoder/decoder). Очень удобно для чистых HTTP-клиентов. Feign в Spring Cloud обычно сочетают с `spring-cloud-starter-openfeign`. citeturn0search4

**Пример:**
```java
@FeignClient("inventory-service")
public interface InventoryClient {
  @GetMapping("/inventory/{id}")
  InventoryDto getById(@PathVariable("id") Long id);
}
```

---
### 6) Отказоустойчивость: Circuit Breaker (Hystrix → Resilience4j)
**Назначение:** защищать систему от каскадных сбоев, внедрять retry, bulkhead, rate limiter, timeout, circuit breaker. Ранее активно использовался **Netflix Hystrix**, но он в состоянии устаревания/maintenance и для новых проектов рекомендуется **Resilience4j** или Spring Cloud CircuitBreaker (адаптеры для разных реализаций). citeturn1search6

**Паттерны:** retry, timeout, circuit-breaker, bulkhead.
**Пример (Resilience4j аннотация):**
```java
@CircuitBreaker(name = "inventory")
public InventoryDto getById(Long id) { ... }
```

---
### 7) Распределённая трассировка и логирование (Sleuth, Zipkin, OpenTelemetry)
**Назначение:** собирать trace/span id по цепочке вызовов, коррелировать логи, визуализировать задержки и зависимости (Zipkin, Jaeger, OTEL backends). **Spring Cloud Sleuth** интегрируется с Brave/Zipkin и в новых версиях переходит к OpenTelemetry/ Micrometer Tracing. Это важно для диагностики медленных запросов и проблем в распределённой системе. citeturn1search5turn1search11

**Как работает:** добавляет trace id в MDC, собирает спаны на входе/выходе HTTP и сообщений, экспортирует в backend (Zipkin/Jaeger/OTel collector).

---
### 8) Messaging / Event-driven: Spring Cloud Stream & Stream Apps
**Назначение:** абстрагировать работу с брокерами сообщений (Kafka, RabbitMQ, Kinesis и др.) через модель Binder — producer/consumer, consumer groups, partitions. **Spring Cloud Stream** позволяет писать обработчики сообщений как обычные Spring beans и конфигурировать binder (Kafka/Rabbit). Быстро масштабируется и интегрируется в микросервисный поток данных. citeturn0search3turn0search11

**Простой пример (functional programming model):**
```yaml
spring:
  cloud:
    stream:
      bindings:
        process-in-0:
          destination: orders
```
```java
@Bean
public Consumer<Order> process() {
  return order -> { /* handle order */ };
}
```

---
### 9) Event Bus / Spring Cloud Bus
**Назначение:** транслировать события конфигурации/идей в кластер микросервисов (через broker: Kafka/Rabbit) — полезно для broadcast `refresh` после изменения конфигурации или сигналов управления. citeturn0search8

---
### 10) Контрактное тестирование — Spring Cloud Contract
**Назначение:** писать контрактные тесты для HTTP и messaging интеграций; генерировать stubs, проверять контракт между провайдером и потребителем. Полезно, когда сервисы разрабатываются независимо. citeturn0search8

---
### 11) Spring Cloud Function, Task, Data Flow
- **Spring Cloud Function** — писать функции, которые можно запускать локально, в Cloud, как FaaS (AWS Lambda, Azure Functions) или в потоках (stream handlers).  
- **Spring Cloud Task** — короткоживущие задачи/ jobs.  
- **Spring Cloud Data Flow** — оркестрация потоков данных и задач (композиция микросервисов в pipeline'ы) — удобная платформа для ETL/stream processing. citeturn0search0turn0search15

---
### 12) Интеграция с Kubernetes / Service Mesh
**Spring Cloud Kubernetes** — адаптеры и интеграция для использования ConfigMaps/Secrets, Service Discovery через Kubernetes API и пр. В Kubernetes часто применяют Service Mesh (Istio/Linkerd) и встроенный kube-dns вместо классического Eureka/Consul для discovery. Spring Cloud может дополнять эти возможности или интегрироваться с ними. citeturn0search8

---
### 13) Observability и метрики (Micrometer, Metrics)
Spring Cloud интегрируется с **Micrometer** для метрик (Prometheus, Graphite, Datadog) — key для мониторинга микросервисов. API Gateway, Circuit Breakers, Stream, и другие компоненты эмитят метрики, которые удобно собирать в централизованную систему мониторинга.

---
## Практические примеры и шаблоны конфигурации (сценарии)

### Сценарий A — простая система с Config Server + Eureka + Gateway + Feign
- Config Server (Git) хранит application.yml для всех сервисов. (Config Server)
- Eureka — реестр сервисов; сервисы регистрируются автоматически. (Discovery)  
- Gateway — единственная точка выхода, маршрутизирует на сервисы `lb://orders-service`. (Routing)  
- Сервисы используют `@FeignClient` для вызовов других микросервисов и CircuitBreaker (Resilience4j) для защиты.

### Сценарий B — event-driven через Spring Cloud Stream (Kafka binder)
- Producer: публикует события `orders.created` в Kafka topic.  
- Consumer(s): масштабируются по числу partitions; обрабатывают события и обновляют состояния или триггерят дальнейшие процессы. (Stream processing)

### Сценарий C — Kubernetes-native
- Используем ConfigMaps/Secrets + Spring Cloud Kubernetes для конфигурации.  
- Service Discovery через Kubernetes Services + Ingress / Gateway (NGINX / Istio).  
- Observability: Prometheus + Grafana + Jaeger/OTel.

---
## Что нужно знать про устаревшие/deprecated части
Некоторые Netflix OSS проекты (Hystrix, Ribbon, Zuul 1) находятся в режиме устаревания/maintenance и **не рекомендуются** для новых разработок. Spring Cloud активно переводит пользователей на современные аналоги: **Resilience4j / Spring Cloud CircuitBreaker**, **Spring Cloud LoadBalancer**, **Spring Cloud Gateway**. Это важный момент при выборе зависимостей и планировании миграции. citeturn1search6turn1search1

---
## Рекомендации по выбору
- Если у вас **новый проект** и вы используете Spring Boot 3+: выбирайте **Spring Cloud Gateway**, **Spring Cloud LoadBalancer**, **Resilience4j** (или Spring Cloud CircuitBreaker + адаптер), **Spring Cloud Stream** (для событий), **Spring Cloud Config** или менеджер секретов (Vault) для конфигурации.  
- Для **Kubernetes** ориентируйтесь на kube-native сервисы (ConfigMap, Service discovery, Ingress) и добавляйте Spring Cloud Kubernetes по необходимости.  
- Избегайте устаревших библиотек (Ribbon/Hystrix/Zuul1) в новых проектах.

---
## Полезные ссылки (официальные)
- Spring Cloud — проектный обзор. citeturn0search4  
- Spring Cloud Config docs. citeturn0search13  
- Spring Cloud Gateway project. citeturn0search2  
- Spring Cloud Stream docs. citeturn0search11  
- Про депрекейшн Hystrix/замену на Resilience4j. citeturn1search6

---
## Заключение
Spring Cloud — это коллекция инструментов, покрывающих большинство задач, с которыми сталкиваются команды, строящие микросервисы: конфигурация, обнаружение сервисов, маршрутизация, безопасность, наблюдаемость и интеграция с брокерами сообщений. Подход «выбирать нужные модули» помогает не перегружать приложение лишним функционалом: возьмите Config, Gateway, Stream и CircuitBreaker — и у вас уже будет мощный набор возможностей. Для новых проектов ориентируйтесь на современные, поддерживаемые решения (LoadBalancer, Resilience4j, Spring Cloud Gateway) и интеграцию с облачными/контейнерными платформами.

---
*Конец документа.*


[к оглавлению](#spring)
