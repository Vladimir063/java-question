[Вопросы для собеседования](README.md)

# Java Core
+ [Чем различаются JRE, JVM и JDK?](#Чем-различаются-jre-jvm-и-jdk)
+ [Какие существуют модификаторы доступа?](#Какие-существуют-модификаторы-доступа)
+ [О чем говорит ключевое слово `final`?](#О-чем-говорит-ключевое-слово-final)
+ [Какими значениями инициализируются переменные по умолчанию?](#Какими-значениями-инициализируются-переменные-по-умолчанию)
+ [Что вы знаете о функции `main()`?](#Что-вы-знаете-о-функции-main)
+ [Какие логические операции и операторы вы знаете?](#Какие-логические-операции-и-операторы-вы-знаете)
+ [Что такое тернарный оператор выбора?](#Что-такое-тернарный-оператор-выбора)
+ [Какие побитовые операции вы знаете?](#Какие-побитовые-операции-вы-знаете)
+ [Где и для чего используется модификатор `abstract`?](#Где-и-для-чего-используется-модификатор-abstract)
+ [Дайте определение понятию _«интерфейс»_. Какие модификаторы по умолчанию имеют поля и методы интерфейсов?](#Дайте-определение-понятию-интерфейс-Какие-модификаторы-по-умолчанию-имеют-поля-и-методы-интерфейсов)
+ [Чем абстрактный класс отличается от интерфейса? В каких случаях следует использовать абстрактный класс, а в каких интерфейс?](#Чем-абстрактный-класс-отличается-от-интерфейса-В-каких-случаях-следует-использовать-абстрактный-класс-а-в-каких-интерфейс)
+ [Почему в некоторых интерфейсах вообще не определяют методов?](#Почему-в-некоторых-интерфейсах-вообще-не-определяют-методов)
+ [Почему нельзя объявить метод интерфейса с модификатором `final`?](#Почему-нельзя-объявить-метод-интерфейса-с-модификатором-final)
+ [Что имеет более высокий уровень абстракции - _класс_, _абстрактный класс_ или _интерфейс_?](#Что-имеет-более-высокий-уровень-абстракции---класс-абстрактный-класс-или-интерфейс)
+ [Может ли объект получить доступ к члену класса, объявленному как `private`? Если да, то каким образом?](#Может-ли-объект-получить-доступ-к-члену-класса-объявленному-как-private-Если-да-то-каким-образом)
+ [Каков порядок вызова конструкторов и блоков инициализации с учётом иерархии классов?](#Каков-порядок-вызова-конструкторов-и-блоков-инициализации-с-учётом-иерархии-классов)
+ [Зачем нужны и какие бывают блоки инициализации?](#Зачем-нужны-и-какие-бывают-блоки-инициализации)
+ [К каким конструкциям Java применим модификатор `static`?](#К-каким-конструкциям-java-применим-модификатор-static)
+ [Для чего в Java используются статические блоки инициализации?](#Для-чего-в-java-используются-статические-блоки-инициализации)
+ [Что произойдёт, если в блоке инициализации возникнет исключительная ситуация?](#Что-произойдёт-если-в-блоке-инициализации-возникнет-исключительная-ситуация)
+ [Какое исключение выбрасывается при возникновении ошибки в блоке инициализации класса?](#Какое-исключение-выбрасывается-при-возникновении-ошибки-в-блоке-инициализации-класса)
+ [Может ли статический метод быть переопределён или перегружен?](#Может-ли-статический-метод-быть-переопределён-или-перегружен)
+ [Могут ли нестатические методы перегрузить статические?](#Могут-ли-нестатические-методы-перегрузить-статические)
+ [Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?](#Можно-ли-сузить-уровень-доступатип-возвращаемого-значения-при-переопределении-метода)
+ [Возможно ли при переопределении метода изменить: модификатор доступа, возвращаемый тип, тип аргумента или их количество, имена аргументов или их порядок; убирать, добавлять, изменять порядок следования элементов секции `throws`?](#Возможно-ли-при-переопределении-метода-изменить-модификатор-доступа-возвращаемый-тип-тип-аргумента-или-их-количество-имена-аргументов-или-их-порядок-убирать-добавлять-изменять-порядок-следования-элементов-секции-throws)
+ [Как получить доступ к переопределенным методам родительского класса?](#Как-получить-доступ-к-переопределенным-методам-родительского-класса)
+ [Можно ли объявить метод абстрактным и статическим одновременно?](#Можно-ли-объявить-метод-абстрактным-и-статическим-одновременно)
+ [В чем разница между членом экземпляра класса и статическим членом класса?](#В-чем-разница-между-членом-экземпляра-класса-и-статическим-членом-класса)
+ [Где разрешена инициализация статических/нестатических полей?](#Где-разрешена-инициализация-статическихнестатических-полей)
+ [Какие типы классов бывают в java?](#Какие-типы-классов-бывают-в-java)
+ [Расскажите про вложенные классы. В каких случаях они применяются?](#Расскажите-про-вложенные-классы-В-каких-случаях-они-применяются)
+ [Что такое _«статический класс»_?](#Что-такое-статический-класс)
+ [Какие существуют особенности использования вложенных классов: статических и внутренних? В чем заключается разница между ними?](#Какие-существуют-особенности-использования-вложенных-классов-статических-и-внутренних-В-чем-заключается-разница-между-ними)
+ [Что такое _«локальный класс»_? Каковы его особенности?](#Что-такое-локальный-класс-Каковы-его-особенности)
+ [Что такое _«анонимные классы»_? Где они применяются?](#Что-такое-анонимные-классы-Где-они-применяются)
+ [Каким образом из вложенного класса получить доступ к полю внешнего класса?](#Каким-образом-из-вложенного-класса-получить-доступ-к-полю-внешнего-класса)
+ [Для чего используется оператор `assert`?](#Для-чего-используется-оператор-assert)
+ [Что такое _Heap_ и _Stack_ память в Java? Какая разница между ними?](#Что-такое-heap-и-stack-память-в-java-Какая-разница-между-ними)
+ [Верно ли утверждение, что примитивные типы данных всегда хранятся в стеке, а экземпляры ссылочных типов данных в куче?](#Верно-ли-утверждение-что-примитивные-типы-данных-всегда-хранятся-в-стеке-а-экземпляры-ссылочных-типов-данных-в-куче)
+ [Каким образом передаются переменные в методы, по значению или по ссылке?](#Каким-образом-передаются-переменные-в-методы-по-значению-или-по-ссылке)
+ [Для чего нужен сборщик мусора?](#Для-чего-нужен-сборщик-мусора)
+ [Как работает сборщик мусора?](#Как-работает-сборщик-мусора)
+ [Какие разновидности сборщиков мусора реализованы в виртуальной машине HotSpot?](#Какие-разновидности-сборщиков-мусора-реализованы-в-виртуальной-машине-hotspot)
+ [Опишите алгоритм работы какого-нибудь сборщика мусора, реализованного в виртуальной машине HotSpot.](#Опишите-алгоритм-работы-какого-нибудь-сборщика-мусора-реализованного-в-виртуальной-машине-hotspot)
+ [Что такое «пул строк»?](#Что-такое-пул-строк)
+ [Что такое `finalize()`? Зачем он нужен?](#Что-такое-finalize-Зачем-он-нужен)
+ [Что произойдет со сборщиком мусора, если выполнение метода `finalize()` требует ощутимо много времени, или в процессе выполнения будет выброшено исключение?](#Что-произойдет-со-сборщиком-мусора-если-выполнение-метода-finalize-требует-ощутимо-много-времени-или-в-процессе-выполнения-будет-выброшено-исключение)
+ [Чем отличаются `final`, `finally` и `finalize()`?](#Чем-отличаются-final-finally-и-finalize)
+ [Расскажите про приведение типов. Что такое понижение и повышение типа?](#Расскажите-про-приведение-типов-Что-такое-понижение-и-повышение-типа)
+ [Когда в приложении может быть выброшено исключение `ClassCastException`?](#Когда-в-приложении-может-быть-выброшено-исключение-classcastexception)
+ [Что такое литералы?](#Что-такое-литералы)
+ [Что такое _autoboxing («автоупаковка»)_ в Java и каковы правила упаковки примитивных типов в классы-обертки?](#Что-такое-autoboxing-автоупаковка-в-java-и-каковы-правила-упаковки-примитивных-типов-в-классы-обертки)
+ [Какие есть особенности класса `String`?](#Какие-есть-особенности-класса-string)
+ [Почему `String` неизменяемый и финализированный класс?](#Почему-string-неизменяемый-и-финализированный-класс)
+ [Почему `char[]` предпочтительнее `String` для хранения пароля?](#Почему-char-предпочтительнее-string-для-хранения-пароля)
+ [Почему строка является популярным ключом в `HashMap` в Java?](#Почему-строка-является-популярным-ключом-в-hashmap-в-java)
+ [Что делает метод `intern()` в классе `String`?.](#Что-делает-метод-intern-в-классе-string)
+ [Можно ли использовать строки в конструкции `switch`?](#Можно-ли-использовать-строки-в-конструкции-switch)
+ [Какая основная разница между `String`, `StringBuffer`, `StringBuilder`?](#Какая-основная-разница-между-string-stringbuffer-stringbuilder)
+ [Что такое класс `Object`? Какие в нем есть методы?](#Что-такое-класс-object-Какие-в-нем-есть-методы)
+ [Дайте определение понятию «конструктор».](#Дайте-определение-понятию-конструктор)
+ [Что такое _«конструктор по умолчанию»_?](#Что-такое-конструктор-по-умолчанию)
+ [Чем отличаются конструктор по-умолчанию, конструктор копирования и конструктор с параметрами?](#Чем-отличаются-конструктор-по-умолчанию-конструктор-копирования-и-конструктор-с-параметрами)
+ [Где и как вы можете использовать приватный конструктор?](#Где-и-как-вы-можете-использовать-приватный-конструктор)
+ [Расскажите про классы-загрузчики и про динамическую загрузку классов.](#Расскажите-про-классы-загрузчики-и-про-динамическую-загрузку-классов)
+ [Что такое _Reflection_?](#Что-такое-reflection)
+ [Зачем нужен `equals()`. Чем он отличается от операции `==`?](#Зачем-нужен-equals-Чем-он-отличается-от-операции-)
+ [Если вы хотите переопределить `equals()`, какие условия должны выполняться?](#Если-вы-хотите-переопределить-equals-какие-условия-должны-выполняться)
+ [Какими свойствами обладает порождаемое `equals()` отношение эквивалентности?](#Какими-свойствами-обладает-порождаемое-equals-отношение-эквивалентности)
+ [Правила переопределения метода `Object.equals()`.](#Правила-переопределения-метода-objectequals)
+ [Какая связь между `hashCode()` и `equals()`?](#Какая-связь-между-hashcode-и-equals)
+ [Если `equals()` переопределен, есть ли какие-либо другие методы, которые следует переопределить?](#Если-equals-переопределен-есть-ли-какие-либо-другие-методы-которые-следует-переопределить)
+ [Что будет, если переопределить `equals()` не переопределяя `hashCode()`? Какие могут возникнуть проблемы?](#Что-будет-если-переопределить-equals-не-переопределяя-hashcode-Какие-могут-возникнуть-проблемы)
+ [Каким образом реализованы методы `hashCode()` и `equals()` в классе `Object`?](#Каким-образом-реализованы-методы-hashcode-и-equals-в-классе-object)
+ [Для чего нужен метод `hashCode()`?](#Для-чего-нужен-метод-hashcode)
+ [Каковы правила переопределения метода `Object.hashCode()`?](#Каковы-правила-переопределения-метода-objecthashcode)
+ [Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете `hashCode()`?](#Есть-ли-какие-либо-рекомендации-о-том-какие-поля-следует-использовать-при-подсчете-hashcode)
+ [Могут ли у разных объектов быть одинаковые `hashCode()`?](#Могут-ли-у-разных-объектов-быть-одинаковые-hashcode)
+ [Если у класса `Point{int x, y;}` реализовать метод `equals(Object that) {(return this.x == that.x && this.y == that.y)}`, но сделать хэш код в виде `int hashCode() {return x;}`, то будут ли корректно такие точки помещаться и извлекаться из `HashSet`?](#Если-у-класса-pointint-x-y-реализовать-метод-equalsobject-that-return-thisx--thatx--thisy--thaty-но-сделать-хэш-код-в-виде-int-hashcode-return-x-то-будут-ли-корректно-такие-точки-помещаться-и-извлекаться-из-hashset)
+ [Могут ли у разных объектов `(ref0 != ref1)` быть `ref0.equals(ref1) == true`?](#Могут-ли-у-разных-объектов-ref0--ref1-быть-ref0equalsref1--true)
+ [Могут ли у разных ссылок на один объект `(ref0 == ref1)` быть `ref0.equals(ref1) == false`?](#Могут-ли-у-разных-ссылок-на-один-объект-ref0--ref1-быть-ref0equalsref1--false)
+ [Можно ли так реализовать метод `equals(Object that) {return this.hashCode() == that.hashCode()}`?](#Можно-ли-так-реализовать-метод-equalsobject-that-return-thishashcode--thathashcode)
+ [В `equals()` требуется проверять, что аргумент `equals(Object that)` такого же типа что и сам объект. В чем разница между `this.getClass() == that.getClass()` и `that instanceof MyClass`?](#В-equals-требуется-проверять-что-аргумент-equalsobject-that-такого-же-типа-что-и-сам-объект-В-чем-разница-между-thisgetclass--thatgetclass-и-that-instanceof-myclass)
+ [Можно ли реализовать метод `equals()` класса `MyClass` вот так: `class MyClass {public boolean equals(MyClass that) {return this == that;}}`?](#Можно-ли-реализовать-метод-equals-класса-myclass-вот-так-class-myclass-public-boolean-equalsmyclass-that-return-this--that)
+ [Есть класс `Point{int x, y;}`. Почему хэш код в виде `31 * x + y` предпочтительнее чем `x + y`?](#Есть-класс-pointint-x-y-Почему-хэш-код-в-виде-31--x--y-предпочтительнее-чем-x--y)
+ [Расскажите про клонирование объектов.](#Расскажите-про-клонирование-объектов)
+ [В чем отличие между _поверхностным_ и _глубоким_ клонированием?](#В-чем-отличие-между-поверхностным-и-глубоким-клонированием)
+ [Какой способ клонирования предпочтительней?](#Какой-способ-клонирования-предпочтительней)
+ [Почему метод `clone()` объявлен в классе `Object`, а не в интерфейсе `Cloneable`?](#Почему-метод-clone-объявлен-в-классе-object-а-не-в-интерфейсе-cloneable)
+ [Опишите иерархию исключений.](#Опишите-иерархию-исключений)
+ [Какие виды исключений в Java вы знаете, чем они отличаются?](#Какие-виды-исключений-в-java-вы-знаете-чем-они-отличаются)
+ [Что такое _checked_ и _unchecked exception_?](#Что-такое-checked-и-unchecked-exception)
+ [Какой оператор позволяет принудительно выбросить исключение?](#Какой-оператор-позволяет-принудительно-выбросить-исключение)
+ [О чем говорит ключевое слово `throws`?](#О-чем-говорит-ключевое-слово-throws)
+ [Как написать собственное («пользовательское») исключение?](#Как-написать-собственное-пользовательское-исключение)
+ [Какие существуют _unchecked exception_?](#Какие-существуют-unchecked-exception)
+ [Что представляет из себя ошибки класса `Error`?](#Что-представляет-из-себя-ошибки-класса-error)
+ [Что вы знаете о `OutOfMemoryError`?](#Что-вы-знаете-о-outofmemoryerror)
+ [Опишите работу блока _try-catch-finally_.](#Опишите-работу-блока-try-catch-finally)
+ [Что такое механизм _try-with-resources_?](#Что-такое-механизм-try-with-resources)
+ [Возможно ли использование блока _try-finally_ (без `catch`)?](#Возможно-ли-использование-блока-try-finally-без-catch)
+ [Может ли один блок `catch` отлавливать сразу несколько исключений?](#Может-ли-один-блок-catch-отлавливать-сразу-несколько-исключений)
+ [Всегда ли исполняется блок `finally`?](#Всегда-ли-исполняется-блок-finally)
+ [Существуют ли ситуации, когда блок `finally` не будет выполнен?](#Существуют-ли-ситуации-когда-блок-finally-не-будет-выполнен)
+ [Может ли метод _main()_ выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?](#Может-ли-метод-main-выбросить-исключение-во-вне-и-если-да-то-где-будет-происходить-обработка-данного-исключения)
+ [Предположим, есть метод, который может выбросить `IOException` и `FileNotFoundException` в какой последовательности должны идти блоки `catch`? Сколько блоков `catch` будет выполнено?](#Предположим-есть-метод-который-может-выбросить-ioexception-и-filenotfoundexception-в-какой-последовательности-должны-идти-блоки-catch-Сколько-блоков-catch-будет-выполнено)
+ [Что такое _generics_?](#Что-такое-generics)
+ [Что такое _«интернационализация»_, _«локализация»_?](#Что-такое-интернационализация-локализация)

## Чем различаются JRE, JVM и JDK?
__JVM__, Java Virtual Machine (Виртуальная машина Java) — основная часть среды времени исполнения Java (JRE). Виртуальная машина Java исполняет байт-код Java, предварительно созданный из исходного текста Java-программы компилятором Java. JVM может также использоваться для выполнения программ, написанных на других языках программирования.

__JRE__, Java Runtime Environment (Среда времени выполнения Java) - минимально-необходимая реализация виртуальной машины для исполнения Java-приложений. Состоит из JVM и стандартного набора библиотек классов Java.

__JDK__, Java Development Kit (Комплект разработки на Java) - JRE и набор инструментов разработчика приложений на языке Java, включающий в себя компилятор Java, стандартные библиотеки классов Java, примеры, документацию, различные утилиты.

Коротко: __JDK__ - среда для разработки программ на Java, включающая в себя __JRE__ - среду для обеспечения запуска Java программ, которая в свою очередь содержит __JVM__ - интерпретатор кода Java программ.

[к оглавлению](#java-core)

## Какие существуют модификаторы доступа?
__private__ (приватный): члены класса доступны только внутри класса. Для обозначения используется служебное слово `private`.

__default__, package-private, package level (доступ на уровне пакета): видимость класса/членов класса только внутри пакета. Является модификатором доступа по умолчанию - специальное 
обозначение не требуется.

__protected__ (защищённый): члены класса доступны внутри пакета и в наследниках. Для обозначения используется служебное слово `protected`.

__public__ (публичный): класс/члены класса доступны всем. Для обозначения используется служебное слово `public`.

Последовательность модификаторов по возрастанию уровня закрытости: public, protected, default, private.

Во время наследования возможно изменения модификаторов доступа в сторону большей видимости (для поддержания соответствия _принципу подстановки Барбары Лисков_).

[к оглавлению](#java-core)

## О чем говорит ключевое слово `final`?
Модификатор `final` может применяться к переменным, параметрам методов, полям и методам класса или самим классам.

+ Класс не может иметь наследников;
+ Метод не может быть переопределен в классах наследниках;
+ Поле не может изменить свое значение после инициализации;
+ Параметры методов не могут изменять своё значение внутри метода;
+ Локальные переменные не могут быть изменены после присвоения им значения.

[к оглавлению](#java-core)

## Какими значениями инициализируются переменные по умолчанию?
+ `byte` — `(byte)0`;
+ `short` — `(short)0`;
+ `int` — `0`;
+ `long` — `0L`;
+ `floatg` — `0f`;
+ `double` — `0d`;
+ `char` — `\u0000`;
+ `boolean` — `false`;
+ Объекты (в том числе `String`) — `null`.

[к оглавлению](#java-core)

## Что вы знаете о функции `main()`?

Метод `main()` — точка входа в программу. В приложении может быть несколько таких методов. Если метод отсутствует, то компиляция возможна, но при запуске будет получена ошибка _\`Error: Main method not found\`_.

```java 
public static void main(String[] args) {}
```

[к оглавлению](#java-core)

## Какие логические операции и операторы вы знаете?
+ `&`: Логическое _AND_ (И);
+ `&&`: Сокращённое _AND_;
+ `|`: Логическое _OR_ (ИЛИ);
+ `||`: Сокращённое _OR_;
+ `^`: Логическое _XOR_ (исключающее _OR_ (ИЛИ));
+ `!`: Логическое унарное _NOT_ (НЕ);
+ `&=`: _AND_ с присваиванием;
+ `|=`: _OR_ с присваиванием;
+ `^=`: _XOR_ с присваиванием;
+ `==`: Равно;
+ `!=`: Не равно;
+ `?:`: Тернарный (троичный) условный оператор.

[к оглавлению](#java-core)

## Что такое тернарный оператор выбора?
Тернарный условный оператор `?:` - оператор, которым можно заменить некоторые конструкции операторов `if-then-else`.

Выражение записывается в следующей форме:
>условие ? выражение1 : выражение2

Если `условие` выполняется, то вычисляется `выражение1` и его результат становится результатом выполнения всего оператора. Если же `условие` равно `false`, то вычисляется `выражение2` и его значение становится результатом работы оператора. Оба операнда `выражение1` и `выражение2` должны возвращать значение одинакового (или совместимого) типа.

[к оглавлению](#java-core)

## Какие побитовые операции вы знаете?
+ `~`: Побитовый унарный оператор NOT;
+ `&`: Побитовый AND;
+ `&=`: Побитовый AND с присваиванием;
+ `|`: Побитовый OR;
+ `|=`: Побитовый OR с присваиванием;
+ `^`: Побитовый исключающее XOR;
+ `^=`: Побитовый исключающее XOR с присваиванием;
+ `>>`: Сдвиг вправо (деление на 2 в степени сдвига);
+ `>>=`: Сдвиг вправо с присваиванием;
+ `>>>`: Сдвиг вправо без учёта знака;
+ `>>>=`: Сдвиг вправо без учёта знака с присваиванием;
+ `<<`: Сдвиг влево (умножение на 2 в степени сдвига);
+ `<<=`: Сдвиг влево с присваиванием.

[к оглавлению](#java-core)

## Где и для чего используется модификатор `abstract`?
Класс, помеченный модификатором `abstract`, называется абстрактным классом. Такие классы могут выступать только предками для других классов. Создавать экземпляры самого абстрактного класса не разрешается. При этом наследниками абстрактного класса могут быть как другие абстрактные классы, так и классы, допускающие создание объектов.

Метод, помеченный ключевым словом `abstract` - абстрактный метод, т.е. метод, который не имеет реализации. Если в классе присутствует хотя бы один абстрактный метод, то весь класс должен быть объявлен абстрактным.

Использование абстрактных классов и методов позволяет описать некий шаблон объекта, который должен быть реализован в других классах. В них же самих описывается лишь некое общее для всех потомков поведение.

[к оглавлению](#java-core)

## Дайте определение понятию _«интерфейс»_. Какие модификаторы по умолчанию имеют поля и методы интерфейсов?
Ключевое слово `interface` используется для создания полностью абстрактных классов. Основное предназначение интерфейса - определять каким образом мы можем использовать класс, который его реализует. Создатель интерфейса определяет имена методов, списки аргументов и типы возвращаемых значений, но не реализует их поведение. Все методы неявно объявляются как `public`.

Начиная с Java 8 в интерфейсах разрешается размещать реализацию методов по умолчанию `default` и статических `static` методов.

Интерфейс также может содержать и поля. В этом случае они автоматически являются публичными `public`, статическими `static` и неизменяемыми `final`.

[к оглавлению](#java-core)

## Чем абстрактный класс отличается от интерфейса? В каких случаях следует использовать абстрактный класс, а в каких интерфейс?
+ В Java класс может одновременно реализовать несколько интерфейсов, но наследоваться только от одного класса.
+ Абстрактные классы используются только тогда, когда присутствует тип отношений «is a» (является). Интерфейсы могут реализоваться классами, которые не связаны друг с другом.
+ Абстрактный класс - средство, позволяющее избежать написания повторяющегося кода, инструмент для частичной реализации поведения. Интерфейс - это средство выражения семантики класса, контракт, описывающий возможности. Все методы интерфейса неявно объявляются как `public abstract` или (начиная с Java 8) `default` - методами с реализацией по-умолчанию, а поля - `public static final`.
+ Интерфейсы позволяют создавать структуры типов без иерархии.
+ Наследуясь от абстрактного, класс «растворяет» собственную индивидуальность. Реализуя интерфейс, он расширяет собственную функциональность.

Абстрактные классы содержат частичную реализацию, которая дополняется или расширяется в подклассах. При этом все подклассы схожи между собой в части реализации, унаследованной от абстрактного класса, и отличаются лишь в части собственной реализации абстрактных методов родителя. Поэтому абстрактные классы применяются в случае построения иерархии однотипных, очень похожих друг на друга классов. В этом случае наследование от абстрактного класса, реализующего поведение объекта по умолчанию может быть полезно, так как позволяет избежать написания повторяющегося кода. Во всех остальных случаях лучше использовать интерфейсы.

[к оглавлению](#java-core)

## Почему в некоторых интерфейсах вообще не определяют методов?
Это так называемые _маркерные интерфейсы_. Они просто указывают что класс относится к определенному типу. Примером может послужить интерфейс `Clonable`, который указывает на то, что класс поддерживает механизм клонирования.

[к оглавлению](#java-core)

## Почему нельзя объявить метод интерфейса с модификатором `final`?
В случае интерфейсов указание модификатора `final` бессмысленно, т.к. все методы интерфейсов неявно объявляются как абстрактные, т.е. их невозможно выполнить, не реализовав где-то еще, а этого нельзя будет сделать, если у метода идентификатор `final`.

[к оглавлению](#java-core)

## Что имеет более высокий уровень абстракции - _класс_, _абстрактный класс_ или _интерфейс_?
Интерфейс.

[к оглавлению](#java-core)

## Может ли объект получить доступ к члену класса, объявленному как `private`? Если да, то каким образом?
+ Внутри класса доступ к приватной переменной открыт без ограничений;
+ Вложенный класс имеет полный доступ ко всем (в том числе и приватным) членам содержащего его класса;
+ Доступ к приватным переменным извне может быть организован через отличные от приватных методов, которые предоставлены разработчиком класса. Например: `getX()` и `setX()`.
+ Через механизм рефлексии (Reflection API):

```java
class Victim { 
    private int field = 42;
}
//...
Victim victim = new Victim(); 
Field field = Victim.class.getDeclaredField("field"); 
field.setAccessible(true); 
int fieldValue = (int) field.get(victim);
//...
```

[к оглавлению](#java-core)

## Каков порядок вызова конструкторов и блоков инициализации с учётом иерархии классов?
Сначала вызываются все статические блоки в очередности от первого статического блока корневого предка и выше по цепочке иерархии до статических блоков самого класса. 

Затем вызываются нестатические блоки инициализации корневого предка, конструктор корневого предка и так далее вплоть до нестатических блоков и конструктора самого класса.

>Parent static block(s) → Child static block(s) → Grandchild static block(s)
>
> → Parent non-static block(s) → Parent constructor →
>
> → Child non-static block(s) → Child constructor →
>
> → Grandchild non-static block(s) → Grandchild constructor

Пример 1:

```java
public class MainClass {

    public static void main(String args[]) {
        System.out.println(TestClass.v);
        new TestClass().a();
    }

}
```

```java
public class TestClass {

    public static String v = "Some val";

    {
        System.out.println("!!! Non-static initializer");
    }

    static {
        System.out.println("!!! Static initializer");
    }

    public void a() {
        System.out.println("!!! a() called");
    }

}
```

Результат выполнения:

```
!!! Static initializer
Some val
!!! Non-static initializer
!!! a() called
```

Пример 2:

```java
public class MainClass {

    public static void main(String args[]) {        
        new TestClass().a();
    }

}
```

```java
public class TestClass {

    public static String v = "Some val";

    {
        System.out.println("!!! Non-static initializer");
    }

    static {
        System.out.println("!!! Static initializer");
    }

    public void a() {
        System.out.println("!!! a() called");
    }

}
```

Результат выполнения:

```
!!! Static initializer
!!! Non-static initializer
!!! a() called
```

[к оглавлению](#java-core)

## Зачем нужны и какие бывают блоки инициализации?
Блоки инициализации представляют собой код, заключенный в фигурные скобки и размещаемый внутри класса вне объявления методов или конструкторов. 

+ Существуют статические и нестатические блоки инициализации.
+ Блок инициализации выполняется перед инициализацией класса загрузчиком классов или созданием объекта класса с помощью конструктора. 
+ Несколько блоков инициализации выполняются в порядке следования в коде класса. 
+ Блок инициализации способен генерировать исключения, если их объявления перечислены в `throws` всех конструкторов класса.
+ Блок инициализации возможно создать и в анонимном классе.

[к оглавлению](#java-core)

## К каким конструкциям Java применим модификатор `static`?
+ полям;
+ методам;
+ вложенным классам;
+ блокам инициализации;
+ членам секции `import`.

[к оглавлению](#java-core)

## Для чего в Java используются статические блоки инициализации?
Статические блоки инициализация используются для выполнения кода, который должен выполняться один раз при инициализации класса загрузчиком классов, в момент, предшествующий созданию объектов этого класса при помощи конструктора. Такой блок (в отличие от нестатических, принадлежащих конкретном объекту класса) принадлежит только самому классу (объекту метакласса `Class`).

[к оглавлению](#java-core)

## Что произойдёт, если в блоке инициализации возникнет исключительная ситуация?
Для нестатических блоков инициализации, если выбрасывание исключения прописано явным образом требуется, чтобы объявления этих исключений были перечислены в `throws` всех конструкторов класса. Иначе будет ошибка компиляции. Для статического блока выбрасывание исключения в явном виде, приводит к ошибке компиляции.

В остальных случаях, взаимодействие с исключениями будет проходить так же, как и в любом другом месте. Класс не будет инициализирован, если ошибка происходит в статическом блоке и объект класса не будет создан, если ошибка возникает в нестатическом блоке.

[к оглавлению](#java-core)

## Какое исключение выбрасывается при возникновении ошибки в блоке инициализации класса?
Если возникшее исключение - наследник `RuntimeException`:

+ для статических блоков инициализации будет выброшено `java.lang.ExceptionInInitializerError`;
+ для нестатических будет проброшено исключение-источник.

Если возникшее исключение - наследник `Error`, то в обоих случаях будет выброшено `java.lang.Error`. Исключение: `java.lang.ThreadDeath` - смерть потока. В этом случае никакое исключение выброшено не будет.

[к оглавлению](#java-core)

## Может ли статический метод быть переопределён или перегружен?
Перегружен - да. Всё работает точно так же, как и с обычными методами - 2 статических метода могут иметь одинаковое имя, если количество их параметров или типов различается. 

Переопределён - нет. Выбор вызываемого статического метода происходит при раннем связывании (на этапе компиляции, а не выполнения) и выполняться всегда будет родительский метод, хотя синтаксически переопределение статического метода - это вполне корректная языковая конструкция.

В целом, к статическим полям и методам рекомендуется обращаться через имя класса, а не объект.

[к оглавлению](#java-core)

## Могут ли нестатические методы перегрузить статические?
Да. В итоге получится два разных метода. Статический будет принадлежать классу и будет доступен через его имя, а нестатический будет принадлежать конкретному объекту и доступен через вызов метода этого объекта.

[к оглавлению](#java-core)

## Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?

+ При переопределении метода нельзя сузить модификатор доступа к методу (например с public в MainClass до private в Class extends MainClass). 
+ Изменить тип возвращаемого значения при переопределении метода нельзя, будет ошибка attempting to use incompatible return type. 
+ Можно сузить возвращаемое значение, если они совместимы. 

Например:

```java
public class Animal {

    public Animal eat() {
        System.out.println("animal eat");
        return null;
    }
    
    public Long calc() {
        return null;
    }

}
public class Dog extends Animal {

    public Dog eat() {
        return new Dog();
    }
/*attempting to use incompatible return type
    public Integer calc() {
        return null;
    }
*/
}
```

## Возможно ли при переопределении метода изменить: модификатор доступа, возвращаемый тип, тип аргумента или их количество, имена аргументов или их порядок; убирать, добавлять, изменять порядок следования элементов секции `throws`?
При переопределении метода сужать модификатор доступа не разрешается, т.к. это приведёт к нарушению принципа подстановки Барбары Лисков. Расширение уровня доступа возможно.

Можно изменять все, что не мешает компилятору понять какой метод родительского класса имеется в виду:

+ Изменять тип возвращаемого значения при переопределении метода разрешено только в сторону сужения типа (вместо родительского класса - наследника).
+ При изменении типа, количества, порядка следования аргументов вместо переопределения будет происходить _overloading_ (перегрузка) метода.
+ Секцию `throws` метода можно не указывать, но стоит помнить, что она остаётся действительной, если уже определена у метода родительского класса. Так же, возможно добавлять новые исключения, являющиеся наследниками от уже объявленных или исключения `RuntimeException`. Порядок следования таких элементов при переопределении значения не имеет.

[к оглавлению](#java-core)

## Как получить доступ к переопределенным методам родительского класса?
С помощью ключевого слова `super` мы можем обратиться к любому члену родительского класса - методу или полю, если они не определены с модификатором `private`.

```java
super.method();
```

[к оглавлению](#java-core)

## Можно ли объявить метод абстрактным и статическим одновременно?
Нет. В таком случае компилятор выдаст ошибку: _"Illegal combination of modifiers: ‘abstract’ and ‘static’"_. Модификатор `abstract` говорит, что метод будет реализован в другом классе, а `static` наоборот указывает, что этот метод будет доступен по имени класса.

[к оглавлению](#java-core)

## В чем разница между членом экземпляра класса и статическим членом класса?
Модификатор `static` говорит о том, что данный метод или поле принадлежат самому классу и доступ к ним возможен даже без создания экземпляра класса. Поля, помеченные `static` инициализируются при инициализации класса. На методы, объявленные как `static`, накладывается ряд ограничений:

+ Они могут вызывать только другие статические методы.
+ Они должны осуществлять доступ только к статическим переменным.
+ Они не могут ссылаться на члены типа `this` или `super`.

В отличии от статических, поля экземпляра класса принадлежат конкретному объекту и могут иметь разные значения для каждого. Вызов метода экземпляра возможен только после предварительного создания объекта класса.

Пример:
```java
public class MainClass {

	public static void main(String args[]) {
		System.out.println(TestClass.v);
		new TestClass().a();
		System.out.println(TestClass.v);
	}

}
```

```java
public class TestClass {

	public static String v = "Initial val";

	{
		System.out.println("!!! Non-static initializer");
		v = "Val from non-static";
	}

	static {
		System.out.println("!!! Static initializer");
		v = "Some val";
	}

	public void a() {
		System.out.println("!!! a() called");
	}

}
```

Результат:

```
!!! Static initializer
Some val
!!! Non-static initializer
!!! a() called
Val from non-static

```

[к оглавлению](#java-core)

## Где разрешена инициализация статических/нестатических полей?
+ Статические поля можно инициализировать при объявлении, в статическом или нестатическом блоке инициализации. 
+ Нестатические поля можно инициализировать при объявлении, в нестатическом блоке инициализации или в конструкторе.

[к оглавлению](#java-core)

## Какие типы классов бывают в java?
+ _Top level class_ (Обычный класс):
    + _Abstract class_ (Абстрактный класс);
    + _Final class_ (Финализированный класс).
+ _Interfaces_ (Интерфейс).
+ _Enum_ (Перечисление).
+ _Nested class_ (Вложенный класс):
    + _Static nested class_ (Статический вложенный класс);
    + _Member inner class_ (Простой внутренний класс);
    + _Local inner class_ (Локальный класс);
    + _Anonymous inner class_ (Анонимный класс).

[к оглавлению](#java-core)

## Расскажите про вложенные классы. В каких случаях они применяются?
Класс называется вложенным (_Nested class_), если он определен внутри другого класса. Вложенный класс должен создаваться только для того, чтобы обслуживать обрамляющий его класс. Если вложенный класс оказывается полезен в каком-либо ином контексте, он должен стать классом верхнего уровня. Вложенные классы имеют доступ ко всем (в том числе приватным) полям и методам внешнего класса, но не наоборот. Из-за этого разрешения использование вложенных классов приводит к некоторому нарушению инкапсуляции.

Существуют четыре категории вложенных классов: 
+ _Static nested class_ (Статический вложенный класс);
+ _Member inner class_ (Простой внутренний класс);
+ _Local inner class_ (Локальный класс);
+ _Anonymous inner class_ (Анонимный класс).

Такие категории классов, за исключением первого, также называют внутренними (_Inner class_). Внутренние классы ассоциируются не с внешним классом, а с экземпляром внешнего.

Каждая из категорий имеет рекомендации по своему применению. Если вложенный класс должен быть виден за пределами одного метода или он слишком длинный для того, чтобы его можно было удобно разместить в границах одного метода и если каждому экземпляру такого класса необходима ссылка на включающий его экземпляр, то используется нестатический внутренний класс. В случае, если ссылка на обрамляющий класс не требуется - лучше сделать такой класс статическим. Если класс необходим только внутри какого-то метода и требуется создавать экземпляры этого класса только в этом методе, то используется локальный класс. А, если к тому же применение класса сводится к использованию лишь в одном месте и уже существует тип, характеризующий этот класс, то рекомендуется делать его анонимным классом.

[к оглавлению](#java-core)

## Что такое _«статический класс»_?
Это вложенный класс, объявленный с использованием ключевого слова `static`. К классам верхнего уровня модификатор `static` неприменим.

[к оглавлению](#java-core)

## Какие существуют особенности использования вложенных классов: статических и внутренних? В чем заключается разница между ними?

+ Вложенные классы могут обращаться ко всем членам обрамляющего класса, в том числе и приватным. 
+ Для создания объекта статического вложенного класса объект внешнего класса не требуется.
+ Из объекта статического вложенного класса нельзя обращаться к не статическим членам обрамляющего класса напрямую, а только через ссылку на экземпляр внешнего класса.
+ Обычные вложенные классы не могут содержать статических методов, блоков инициализации и классов. Статические вложенные классы - могут.
+ В объекте обычного вложенного класса хранится ссылка на объект внешнего класса. Внутри статической такой ссылки нет. Доступ к экземпляру обрамляющего класса осуществляется через указание `.this` после его имени. Например: `Outer.this`.

[к оглавлению](#java-core)

## Что такое _«локальный класс»_? Каковы его особенности?
__Local inner class__ (Локальный класс) - это вложенный класс, который может быть декларирован в любом блоке, в котором разрешается декларировать переменные. Как и простые внутренние классы (_Member inner class_) локальные классы имеют имена и могут использоваться многократно. Как и анонимные классы, они имеют окружающий их экземпляр только тогда, когда применяются в нестатическом контексте.

Локальные классы имеют следующие особенности:

+ Видны только в пределах блока, в котором объявлены;
+ Не могут быть объявлены как `private`/`public`/`protected` или `static`;
+ Не могут иметь внутри себя статических объявлений методов и классов, но могут иметь финальные статические поля, проинициализированные константой;
+ Имеют доступ к полям и методам обрамляющего класса;
+ Могут обращаться к локальным переменным и параметрам метода, если они объявлены с модификатором `final`.

[к оглавлению](#java-core)

## Что такое _«анонимные классы»_? Где они применяются?
Это вложенный локальный класс без имени, который разрешено декларировать в любом месте обрамляющего класса, разрешающем размещение выражений. Создание экземпляра анонимного класса происходит одновременно с его объявлением. В зависимости от местоположения анонимный класс ведет себя как статический либо как нестатический вложенный класс - в нестатическом контексте появляется окружающий его экземпляр.

Анонимные классы имеют несколько ограничений:

+ Их использование разрешено только в одном месте программы - месте его создания;
+ Применение возможно только в том случае, если после порождения экземпляра нет необходимости на него ссылаться;
+ Реализует лишь методы своего интерфейса или суперкласса, т.е. не может объявлять каких-либо новых методов, так как для доступа к ним нет поименованного типа.

Анонимные классы обычно применяются для: 

+ создания объекта функции (_function object_), например, реализация интерфейса `Comparator`;
+ создания объекта процесса (_process object_), такого как экземпляры классов `Thread`, `Runnable` и подобных;
+ в статическом методе генерации;
+ инициализации открытого статического поля `final`, которое соответствует сложному перечислению типов, когда для каждого экземпляра в перечислении требуется отдельный подкласс.

[к оглавлению](#java-core)

## Каким образом из вложенного класса получить доступ к полю внешнего класса?
Статический вложенный класс имеет прямой доступ только к статическим полям обрамляющего класса. 

Простой внутренний класс, может обратиться к любому полю внешнего класса напрямую. В случае, если у вложенного класса уже существует поле с таким же литералом, то обращаться к такому полю следует через ссылку на его экземпляр. Например: `Outer.this.field`.

[к оглавлению](#java-core)

## Для чего используется оператор `assert`?
__Assert__ (Утверждение) — это специальная конструкция, позволяющая проверять предположения о значениях произвольных данных в произвольном месте программы. Утверждение может автоматически сигнализировать об обнаружении некорректных данных, что обычно приводит к аварийному завершению программы с указанием места обнаружения некорректных данных.

Утверждения существенно упрощают локализацию ошибок в коде. Даже проверка результатов выполнения очевидного кода может оказаться полезной при последующем рефакторинге, после которого код может стать не настолько очевидным и в него может закрасться ошибка. 

Обычно утверждения оставляют включенными во время разработки и тестирования программ, но отключают в релиз-версиях программ.

Т.к. утверждения могут быть удалены на этапе компиляции либо во время исполнения программы, они не должны менять поведение программы. Если в результате удаления утверждения поведение программы может измениться, то это явный признак неправильного использования _assert_. Таким образом, внутри _assert_ нельзя вызывать методы, изменяющие состояние программы, либо внешнего окружения программы. 

В Java проверка утверждений реализована с помощью оператора `assert`, который имеет форму:

`assert [Выражение типа boolean];` или `assert [Выражение типа boolean] : [Выражение любого типа, кроме void];`

Во время выполнения программы в том случае, если поверка утверждений включена, вычисляется значение булевского выражения, и если его результат `false`, то генерируется исключение `java.lang.AssertionError`. В случае использования второй формы оператора `assert` выражение после двоеточия задаёт детальное сообщение о произошедшей ошибке (вычисленное выражение будет преобразовано в строку и передано конструктору `AssertionError`).

[к оглавлению](#java-core)

## Что такое _Heap_ и _Stack_ память в Java? Какая разница между ними?
__Heap (куча)__ используется Java Runtime для выделения памяти под объекты и классы. Создание нового объекта также происходит в куче. Это же является областью работы сборщика мусора. Любой объект, созданный в куче, имеет глобальный доступ и на него могут ссылаться из любой части приложения.

__Stack (стек)__ это область хранения данных также находящееся в общей оперативной памяти (_RAM_). Всякий раз, когда вызывается метод, в памяти стека создается новый блок, который содержит примитивы и ссылки на другие объекты в методе. Как только метод заканчивает работу, блок также перестает использоваться, тем самым предоставляя доступ для следующего метода.
Размер стековой памяти намного меньше объема памяти в куче. Стек в Java работает по схеме _LIFO_ (Последний-зашел-Первый-вышел)

Различия между _Heap_ и _Stack_ памятью:
+ Куча используется всеми частями приложения, в то время как стек используется только одним потоком исполнения программы.
+ Всякий раз, когда создается объект, он всегда хранится в куче, а в памяти стека содержится лишь ссылка на него. Память стека содержит только локальные переменные примитивных типов и ссылки на объекты в куче.
+ Объекты в куче доступны с любой точки программы, в то время как стековая память не может быть доступна для других потоков.
+ Стековая память существует лишь какое-то время работы программы, а память в куче живет с самого начала до конца работы программы.
+ Если память стека полностью занята, то Java Runtime бросает исключение `java.lang.StackOverflowError`. Если заполнена память кучи, то бросается исключение `java.lang.OutOfMemoryError: Java Heap Space`.
+ Размер памяти стека намного меньше памяти в куче. 
+ Из-за простоты распределения памяти, стековая память работает намного быстрее кучи.

Для определения начального и максимального размера памяти в куче используются `-Xms` и `-Xmx` опции JVM. Для стека определить размер памяти можно с помощью опции `-Xss`.

[к оглавлению](#java-core)

# Размеры примитивов и ссылок в Java

Коротко и по делу.

## Примитивы (зафиксировано спецификацией Java)
- `byte` — 8 бит = **1 байт**  
- `short` — 16 бит = **2 байта**  
- `int` — 32 бита = **4 байта**  
- `long` — 64 бита = **8 байт**  
- `char` — 16 бит (UTF-16 кодовый юнит) = **2 байта**  
- `float` — 32 бита = **4 байта**  
- `double` — 64 бита = **8 байт**  
- `boolean` — **размер не задан строго спецификацией**. На практике JVM обычно хранит `boolean` как 1 байт в массивах; в полях объекта — реализация-зависимо (часто 1 байт, но возможны выравнивания/пэдинг).

> Примечание: JLS (Java Language Specification) фиксирует точный размер для всех числовых/символьных примитивов, но не для `boolean`.

## Ссылки (object references) — зависит от JVM/платформы
Спецификация языка не задаёт размер ссылки — это реализация JVM. Типичные значения в HotSpot:

- 32-бит JVM: **4 байта** (32 бита)  
- 64-бит JVM с включёнными *compressed ordinary object pointers* (compressed OOPs, часто по умолчанию при небольших кучах): **4 байта**  
- 64-бит JVM без сжатых указателей: **8 байт**

Также учитывайте выравнивание и заголовки объектов — реальный «вес» объекта = заголовок + поля (с учётом выравнивания), поэтому объект-обёртка занимает гораздо больше, чем сам примитив.

## Заголовок объекта (примерно, HotSpot)
(тоже JVM-зависимо; для ориентировки)
- 32-bit HotSpot: заголовок ~ **8 байт**  
- 64-bit HotSpot с compressed OOPs: заголовок ~ **12 байт** (марковое слово 8 + указатель класса 4)  
- 64-bit HotSpot без compressed OOPs: заголовок ~ **16 байт**

После заголовка идут поля, а общая длина объекта выравнивается (обычно до 8 байт), поэтому минимум для пустого объекта обычно 16 байт на 64-bit с компрессией и т.п. (зависит от JVM).

---

# Зачем нужны примитивы, если есть обёртки? (коротко)
1. **Память** — примитив занимает фиксированно мало байт; обёртка (`Integer`, `Long` и т.д.) — объект с заголовком + поле, занимает заметно больше памяти.  
2. **Производительность** — операции на примитивах быстрее (нет выделения/GC и нет накладных расходов на разыменование/autoboxing).  
3. **Гарантированное поведение** — размеры и представление чисел строго заданы спецификацией (важно для алгоритмов/сериализации).  
4. **Отсутствие null** — примитив не может быть `null`, поэтому нет NPE при простых вычислениях.

Обёртки нужны, когда нужны объектные свойства: хранение в коллекциях (`List<Integer>`), использование в API, возможность `null`, методы утилит (например `Integer.parseInt`) и т.д.

---

Если нужно, могу коротко показать пример, сколько реально занимает, скажем, `Integer` и `int[]` в HotSpot (примерный расчёт) — напиши, хочешь ли пример.


## Верно ли утверждение, что примитивные типы данных всегда хранятся в стеке, а экземпляры ссылочных типов данных в куче?
Не совсем. Примитивное поле экземпляра класса хранится не в стеке, а в куче. Любой объект (всё, что явно или неявно создаётся при помощи оператора `new`) хранится в куче.

[к оглавлению](#java-core)

## Каким образом передаются переменные в методы, по значению или по ссылке?
В Java параметры всегда передаются только по значению, что определяется как «скопировать значение и передать копию». С примитивами это будет копия содержимого. Со ссылками - тоже копия содержимого, т.е. копия ссылки. При этом внутренние члены ссылочных типов через такую копию изменить возможно, а вот саму ссылку, указывающую на экземпляр - нет.

[к оглавлению](#java-core)

## Для чего нужен сборщик мусора?
Сборщик мусора (Garbage Collector) должен делать всего две вещи:

+ Находить мусор - неиспользуемые объекты. (Объект считается неиспользуемым, если ни одна из сущностей в коде, выполняемом в данный момент, не содержит ссылок на него, либо цепочка ссылок, которая могла бы связать объект с некоторой сущностью приложения, обрывается);
+ Освобождать память от мусора.

Существует два подхода к обнаружению мусора:

+ _Reference counting_;
+ _Tracing_

__Reference counting__ (подсчёт ссылок). Суть этого подхода состоит в том, что каждый объект имеет счетчик. Счетчик хранит информацию о том, сколько ссылок указывает на объект. Когда ссылка уничтожается, счетчик уменьшается. Если значение счетчика равно нулю, - объект можно считать мусором. Главным минусом такого подхода является сложность обеспечения точности счетчика. Также при таком подходе сложно выявлять циклические зависимости (когда два объекта указывают друг на друга, но ни один живой объект на них не ссылается), что приводит к утечкам памяти.

Главная идея подхода __Tracing__ (трассировка) состоит в утверждении, что живыми могут считаться только те объекты, до которых мы можем добраться из корневых точек (_GC Root_) и те объекты, которые доступны с живого объекта. Всё остальное - мусор.

Существует 4 типа корневых точки:

+ Локальные переменные и параметры методов;
+ Потоки;
+ Статические переменные;
+ Ссылки из JNI.

Самое простое java приложение будет иметь корневые точки:

+ Локальные переменные внутри `main()` метода и параметры `main()` метода;
+ Поток который выполняет `main()`;
+ Статические переменные класса, внутри которого находится `main()` метод.

Таким образом, если мы представим все объекты и ссылки между ними как дерево, то нам нужно будет пройти с корневых узлов (точек) по всем рёбрам. При этом узлы, до которых мы сможем добраться - не мусор, все остальные - мусор. При таком подходе циклические зависимости легко выявляются. HotSpot VM использует именно такой подход.

---
Для очистки памяти от мусора существуют два основных метода:

+ _Copying collectors_
+ _Mark-and-sweep_

При __copying collectors__ подходе память делится на две части «from-space» и «to-space», при этом сам принцип работы такой:

+ Объекты создаются в «from-space»;
+ Когда «from-space» заполняется, приложение приостанавливается;
+ Запускается сборщик мусора. Находятся живые объекты в «from-space» и копируются в «to-space»;
+ Когда все объекты скопированы «from-space» полностью очищается;
+ «to-space» и «from-space» меняются местами.

Главный плюс такого подхода в том, что объекты плотно забивают память. Минусы подхода:

1. Приложение должно быть остановлено на время, необходимое для полного прохождения цикла сборки мусора;
2. В худшем случае (когда все объекты живые) «form-space» и «to-space» будут обязаны быть одинакового размера.

Алгоритм работы __mark-and-sweep__ можно описать так:

+ Объекты создаются в памяти;
+ В момент, когда нужно запустить сборщик мусора приложение приостанавливается;
+ Сборщик проходится по дереву объектов, помечая живые объекты;
+ Сборщик проходится по всей памяти, находя все не отмеченные куски памяти и сохраняя их в «free list»;
+ Когда новые объекты начинают создаваться они создаются в памяти доступной во «free list».

Минусы этого способа:

1. Приложение не работает пока происходит сборка мусора;
2. Время остановки напрямую зависит от размеров памяти и количества объектов;
3. Если не использовать «compacting» память будет использоваться не эффективно.

Сборщики мусора HotSpot VM используют комбинированный подход __Generational Garbage Collection__, который позволяет использовать разные алгоритмы для разных этапов сборки мусора. Этот подход опирается на том, что:

+ большинство создаваемых объектов быстро становятся мусором;
+ существует мало связей между объектами, которые были созданы в прошлом и только что созданными объектами.

[к оглавлению](#java-core)

## Как работает сборщик мусора?
Механизм сборки мусора - это процесс освобождения места в куче, для возможности добавления новых объектов.

Объекты создаются посредством оператора `new`, тем самым присваивая объекту ссылку. Для окончания работы с объектом достаточно просто перестать на него ссылаться, например, присвоив переменной ссылку на другой объект или значение `null`; прекратить выполнение метода, чтобы его локальные переменные завершили свое существование естественным образом. Объекты, ссылки на которые отсутствуют, принято называть мусором (_garbage_), который будет удален.

Виртуальная машина Java, применяя механизм сборки мусора, гарантирует, что любой объект, обладающий ссылками, остается в памяти — все объекты, которые недостижимы из исполняемого кода, ввиду отсутствия ссылок на них, удаляются с высвобождением отведенной для них памяти. Точнее говоря, объект не попадает в сферу действия процесса сборки мусора, если он достижим посредством цепочки ссылок, начиная с корневой (_GC Root_) ссылки, т.е. ссылки, непосредственно существующей в выполняемом коде.

Память освобождается сборщиком мусора по его собственному «усмотрению». Программа может успешно завершить работу, не исчерпав ресурсов свободной памяти или даже не приблизившись к этой черте и поэтому ей так и не потребуются «услуги» сборщика мусора.

Мусор собирается системой автоматически, без вмешательства пользователя или программиста, но это не значит, что этот процесс не требует внимания вовсе. Необходимость создания и удаления большого количества объектов существенным образом сказывается на производительности приложений и, если быстродействие программы является важным фактором, следует тщательно обдумывать решения, связанные с созданием объектов, — это, в свою очередь, уменьшит и объем мусора, подлежащего утилизации.

[к оглавлению](#java-core)

## Какие разновидности сборщиков мусора реализованы в виртуальной машине HotSpot?
Java HotSpot VM предоставляет разработчикам на выбор четыре различных сборщика мусора:

+ __Serial (последовательный)__ — самый простой вариант для приложений с небольшим объемом данных и не требовательных к задержкам. На данный момент используется сравнительно редко, но на слабых компьютерах может быть выбран виртуальной машиной в качестве сборщика по умолчанию. Использование Serial GC включается опцией `-XX:+UseSerialGC`.
+ __Parallel (параллельный)__ — наследует подходы к сборке от последовательного сборщика, но добавляет параллелизм в некоторые операции, а также возможности по автоматической подстройке под требуемые параметры производительности. Параллельный сборщик включается опцией `-XX:+UseParallelGC`.
+ __Concurrent Mark Sweep (CMS)__ — нацелен на снижение максимальных задержек путем выполнения части работ по сборке мусора параллельно с основными потоками приложения. Подходит для работы с относительно большими объемами данных в памяти. Использование CMS GC включается опцией `-XX:+UseConcMarkSweepGC`.
+ __Garbage-First (G1)__ — создан для замены CMS, особенно в серверных приложениях, работающих на многопроцессорных серверах и оперирующих большими объемами данных. _G1_ включается опцией Java `-XX:+UseG1GC`.

[к оглавлению](#java-core)

## Опишите алгоритм работы какого-нибудь сборщика мусора, реализованного в виртуальной машине HotSpot.
__Serial Garbage Collector (Последовательный сборщик мусора)__ был одним из первых сборщиков мусора в HotSpot VM. Во время работы этого сборщика приложения приостанавливается и продолжает работать только после прекращения сборки мусора. 

Память приложения делится на три пространства:

+ _Young generation_. Объекты создаются именно в этом участке памяти.
+ _Old generation_. В этот участок памяти перемещаются объекты, которые переживают «minor garbage collection».
+ _Permanent generation_. Тут хранятся метаданные об объектах, _Class data sharing (CDS)_, _пул строк (String pool)_. Permanent область делится на две: только для чтения и для чтения-записи. Очевидно, что в этом случае область только для чтения не чистится сборщиком мусора никогда.

Область памяти Young generation состоит из трёх областей: _Eden_ и двух меньших по размеру _Survivor spaces_ - _To space_ и _From space_. Большинство объектов создаются в области Eden, за исключением очень больших объектов, которые не могут быть размещены в ней и поэтому сразу размещаются в Old generation. В Survivor spaces перемещаются объекты, которые пережили по крайней мере одну сборку мусора, но ещё не достигли порога «старости» (_tenuring threshold_), чтобы быть перемещенными в Old generation.

Когда Young generation заполняется, то в этой области запускается процесс лёгкой сборки (_minor collection_), в отличие от процесса сборки, проводимого над всей кучей (_full collection_). Он происходит следующим образом: в начале работы одно из Survivor spaces - To space, является пустым, а другое - From space, содержит объекты, пережившие предыдущие сборки. Сборщик мусора ищет живые объекты в Eden и копирует их в To space, а затем копирует туда же и живые «молодые» (то есть не пережившие еще заданное число сборок мусора) объекты из From space. Старые объекты из From space перемещаются в Old generation. После лёгкой сборки From space и To space меняются ролями, область Eden становится пустой, а число объектов в Old generation увеличивается.

Если в процессе копирования живых объектов To space переполняется, то оставшиеся живые объекты из Eden и From space, которым не хватило места в To space, будут перемещены в Old generation, независимо от того, сколько сборок мусора они пережили.

Поскольку при использовании этого алгоритма сборщик мусора просто копирует все живые объекты из одной области памяти в другую, то такой сборщик мусора называется _copying_ (копирующий). Очевидно, что для работы копирующего сборщика мусора у приложения всегда должна быть свободная область памяти, в которую будут копироваться живые объекты, и такой алгоритм может применяться для областей памяти сравнительно небольших по отношению к общему размеру памяти приложения. Young generation как раз удовлетворяет этому условию (по умолчанию на машинах клиентского типа эта область занимает около 10% кучи (значение может варьироваться в зависимости от платформы)).

Однако, для сборки мусора в Old generation, занимающем большую часть всей памяти, используется другой алгоритм.

В Old generation сборка мусора происходит с использованием алгоритма _mark-sweep-compact_, который состоит из трёх фаз. В фазе _Mark_ (пометка) сборщик мусора помечает все живые объекты, затем, в фазе _Sweep_ (очистка) все не помеченные объекты удаляются, а в фазе _Сompact_ (уплотнение) все живые объекты перемещаются в начало Old generation, в результате чего свободная память после очистки представляет собой непрерывную область. Фаза уплотнения выполняется для того, чтобы избежать фрагментации и упростить процесс выделения памяти в Old generation.

Когда свободная память представляет собой непрерывную область, то для выделения памяти под создаваемый объект можно использовать очень быстрый (около десятка машинных инструкций) алгоритм _bump-the-pointer_: адрес начала свободной памяти хранится в специальном указателе, и когда поступает запрос на создание нового объекта, код проверяет, что для нового объекта достаточно места, и, если это так, то просто увеличивает указатель на размер объекта.

Последовательный сборщик мусора отлично подходит для большинства приложений, использующих до 200 мегабайт кучи, работающих на машинах клиентского типа и не предъявляющих жёстких требований к величине пауз, затрачиваемых на сборку мусора. В то же время модель «stop-the-world» может вызвать длительные паузы в работе приложения при использовании больших объёмов памяти. Кроме того, последовательный алгоритм работы не позволяет оптимально использовать вычислительные ресурсы компьютера, и последовательный сборщик мусора может стать узким местом при работе приложения на многопроцессорных машинах.

[к оглавлению](#java-core)

## Что такое «пул строк»?
__Пул строк__ – это набор строк, хранящийся в _Heap_.

+ Пул строк возможен благодаря неизменяемости строк в Java и реализации идеи интернирования строк;
+ Пул строк помогает экономить память, но по этой же причине создание строки занимает больше времени;
+ Когда для создания строки используются `"`, то сначала ищется строка в пуле с таким же значением, если находится, то просто возвращается ссылка, иначе создается новая строка в пуле, а затем возвращается ссылка на неё;
+ При использовании оператора `new` создаётся новый объект `String`. Затем при помощи метода `intern()` эту строку можно поместить в пул или же получить из пула ссылку на другой объект `String` с таким же значением;
+ Пул строк является примером паттерна _«Приспособленец» (Flyweight)_.

[к оглавлению](#java-core)

## Что такое `finalize()`? Зачем он нужен?
Через вызов метода `finalize()` (который наследуется от Java.lang.Object) JVM реализуется функциональность аналогичная функциональности деструкторов в С++, используемых для очистки памяти перед возвращением управления операционной системе. Данный метод вызывается при уничтожении объекта сборщиком мусора (_garbage collector_) и переопределяя `finalize()` можно запрограммировать действия необходимые для корректного удаления экземпляра класса - например, закрытие сетевых соединений, соединений с базой данных, снятие блокировок на файлы и т.д. 

После выполнения этого метода объект должен быть повторно собран сборщиком мусора (и это считается серьезной проблемой метода `finalize()` т.к. он мешает сборщику мусора освобождать память). Вызов этого метода не гарантируется, т.к. приложение может быть завершено до того, как будет запущена сборка мусора.

Объект не обязательно будет доступен для сборки сразу же - метод `finalize()` может сохранить куда-нибудь ссылку на объект. Подобная ситуация называется «возрождением» объекта и считается антипаттерном. Главная проблема такого трюка - в том, что «возродить» объект можно только 1 раз.

Пример:
```java
public class MainClass {

	public static void main(String args[]) {
		TestClass a = new TestClass();
		a.a();
		a = null;
		a = new TestClass();
		a.a();
		System.out.println("!!! done");
	}
}
```
```java

public class TestClass {

	public void a() {
		System.out.println("!!! a() called");
	}

	@Override
	protected void finalize() throws Throwable {
		System.out.println("!!! finalize() called");
		super.finalize();
	}
}
```
Так как в данном случае сборщик мусора может и не быть вызван (в силу простоты приложения), то результат выполнения программы с большой вероятностью будет следующий:
```
!!! a() called
!!! a() called
!!! done
```
Теперь несколько усложним программу, добавив принудительный вызов Garbage Collector:
```java
public class MainClass {

	public static void main(String args[]) {
		TestClass a = new TestClass();
		a.a();
		a = null;
		System.gc(); // Принудительно зовём сборщик мусора
		a = new TestClass();
		a.a();
		System.out.println("!!! done");
	}

}
```
Как и было сказано ранее, Garbage Collector может в разное время отработать, поэтому результат выполнения может разниться от запуска к запуску:
Вариант а:
```
!!! a() called
!!! a() called
!!! done
!!! finalize() called
```
Вариант б:
```
!!! a() called
!!! a() called
!!! finalize() called
!!! done
```


[к оглавлению](#java-core)

## Что произойдет со сборщиком мусора, если выполнение метода `finalize()` требует ощутимо много времени, или в процессе выполнения будет выброшено исключение?
Непосредственно вызов `finalize()` происходит в отдельном потоке _Finalizer_ (`java.lang.ref.Finalizer.FinalizerThread`), который создаётся при запуске виртуальной машины (в статической секции при загрузке класса `Finalizer`). Методы `finalize()` вызываются последовательно в том порядке, в котором были добавлены в список сборщиком мусора. Соответственно, если какой-то `finalize()` зависнет, он подвесит поток _Finalizer_, но не сборщик мусора. Это в частности означает, что объекты, не имеющие метода `finalize()`, будут исправно удаляться, а вот имеющие будут добавляться в очередь, пока поток _Finalizer_ не освободится, не завершится приложение или не кончится память. 

То же самое применимо и выброшенным в процессе `finalize()` исключениям: метод `runFinalizer()` у потока _Finalizer_ игнорирует все исключения выброшенные в момент выполнения `finalize()`. Таким образом возникновение исключительной ситуации никак не скажется на работоспособности сборщика мусора.

[к оглавлению](#java-core)

## Чем отличаются `final`, `finally` и `finalize()`?
Модификатор `final`:

+ Класс не может иметь наследников;
+ Метод не может быть переопределен в классах наследниках;
+ Поле не может изменить свое значение после инициализации;
+ Локальные переменные не могут быть изменены после присвоения им значения;
+ Параметры методов не могут изменять своё значение внутри метода.

Оператор `finally` гарантирует, что определенный в нём участок кода будет выполнен независимо от того, какие исключения были возбуждены и перехвачены в блоке `try-catch`.

Метод `finalize()` вызывается перед тем как сборщик мусора будет проводить удаление объекта.

Пример:
```java

public class MainClass {

	public static void main(String args[]) {
		TestClass a = new TestClass();
		System.out.println("result of a.a() is " + a.a());
		a = null;
		System.gc(); // Принудительно зовём сборщик мусора
		a = new TestClass();
		System.out.println("result of a.a() is " + a.a());
		System.out.println("!!! done");
	}

}
```

```java
public class TestClass {

	public int a() {
		try {
			System.out.println("!!! a() called");
			throw new Exception("");
		} catch (Exception e) {
			System.out.println("!!! Exception in a()");
			return 2;
		} finally {
			System.out.println("!!! finally in a() ");
		}
	}

	@Override
	protected void finalize() throws Throwable {
		System.out.println("!!! finalize() called");
		super.finalize();
	}
}
```

Результат выполнения:

```
!!! a() called
!!! Exception in a()
!!! finally in a() 
result of a.a() is 2
!!! a() called
!!! Exception in a()
!!! finally in a() 
!!! finalize() called
result of a.a() is 2
!!! done
```

[к оглавлению](#java-core)

## Расскажите про приведение типов. Что такое понижение и повышение типа?
Java является строго типизированным языком программирования, а это означает, то что каждое выражение и каждая переменная имеет строго определенный тип уже на момент компиляции. Однако определен механизм _приведения типов (casting)_ - способ преобразования значения переменной одного типа в значение другого типа. 

В Java существуют несколько разновидностей приведения:

+ __Тождественное (identity)__. Преобразование выражения любого типа к точно такому же типу всегда допустимо и происходит автоматически.
+ __Расширение (повышение, upcasting) примитивного типа (widening primitive)__. Означает, что осуществляется переход от менее емкого типа к более ёмкому. Например, от типа `byte` (длина 1 байт) к типу `int` (длина 4 байта). Такие преобразование безопасны в том смысле, что новый тип всегда гарантировано вмещает в себя все данные, которые хранились в старом типе и таким образом не происходит потери данных. Этот тип приведения всегда допустим и происходит автоматически.
+ __Сужение (понижение, downcasting) примитивного типа (narrowing primitive)__. Означает, что переход осуществляется от более емкого типа к менее емкому. При таком преобразовании есть риск потерять данные. Например, если число типа `int` было больше `127`, то при приведении его к `byte` значения битов старше восьмого будут потеряны. В Java такое преобразование должно совершаться явным образом, при этом все старшие биты, не умещающиеся в новом типе, просто отбрасываются - никакого округления или других действий для получения более корректного результата не производится.
+ __Расширение объектного типа (widening reference)__. Означает неявное восходящее приведение типов или переход от более конкретного типа к менее конкретному, т.е. переход от потомка к предку. Разрешено всегда и происходит автоматически.
+ __Сужение объектного типа (narrowing reference)__. Означает нисходящее приведение, то есть приведение от предка к потомку (подтипу). Возможно только если исходная переменная является подтипом приводимого типа. При несоответствии типов в момент выполнения выбрасывается исключение `ClassCastException`. Требует явного указания типа.
+ __Преобразование к строке (to String)__. Любой тип может быть приведен к строке, т.е. к экземпляру класса `String`.
+ __Запрещенные преобразования (forbidden)__. Не все приведения между произвольными типами допустимы. Например, к запрещенным преобразованиям относятся приведения от любого ссылочного типа к примитивному и наоборот (кроме преобразования к строке). Кроме того, невозможно привести друг к другу классы, находящиеся на разных ветвях дерева наследования и т.п.

При приведении ссылочных типов с самим объектом ничего не происходит, - меняется лишь тип ссылки, через которую происходит обращение к объекту.

Для проверки возможности приведения нужно воспользоваться оператором `instanceof`:

```java
Parent parent = new Child();
if (parent instanceof Child) {
    Child child = (Child) parent;
}
```

[к оглавлению](#java-core)

## Когда в приложении может быть выброшено исключение `ClassCastException`?
`ClassCastException` (потомок `RuntimeException`) - исключение, которое будет выброшено при ошибке приведения типа.

[к оглавлению](#java-core)

## Что такое литералы?
__Литералы__ — это явно заданные значения в коде программы — константы определенного типа, которые находятся в коде в момент запуска.
```java
class Test {
   int a = 0b1101010110;
   public static void main(String[] args) {
       System.out.println("Hello world!");       
   }
}
```
В этом классе “Hello world!” — литерал.

Переменная `a` - тоже литерал.

Литералы бывают разных типов, которые определяются их назначением и способом написания. 

[к оглавлению](#java-core)

## Что такое _autoboxing («автоупаковка»)_ в Java и каковы правила упаковки примитивных типов в классы-обертки?
__Автоупаковка__ - это механизм неявной инициализации объектов классов-оберток (`Byte`, `Short`, `Integer`, `Long`, `Float`, `Double`, `Character`, `Boolean`) значениями соответствующих им исходных примитивных типов (`byte`, `short`, `int`...), без явного использования конструктора класса. 

+ Автоупаковка происходит при прямом присваивании примитива классу-обертке (с помощью оператора `=`), либо при передаче примитива в параметры метода (типа класса-обертки). 

+ Автоупаковке в классы-обертки могут быть подвергнуты как переменные примитивных типов, так и константы времени компиляции (литералы и `final`-примитивы). При этом литералы должны быть синтаксически корректными для инициализации переменной исходного примитивного типа.

+ Автоупаковка переменных примитивных типов требует точного соответствия типа исходного примитива типу класса-обертки. Например, попытка упаковать переменную типа `byte` в `Short`, без предварительного явного приведения `byte` в `short` вызовет ошибку компиляции.

+ Автоупаковка констант примитивных типов допускает более широкие границы соответствия. В этом случае компилятор способен предварительно осуществлять неявное расширение/сужение типа примитивов:
    1) неявное расширение/сужение исходного типа примитива до типа примитива, соответствующего классу-обертке (для преобразования `int` в `Byte`, сначала компилятор самостоятельно неявно сужает `int` к `byte`)
    2) автоупаковку примитива в соответствующий класс-обертку. Однако, в этом случае существуют два дополнительных ограничения:
        a) присвоение примитива обертке может производится только оператором `=` (нельзя передать такой примитив в параметры метода без явного приведения типов)
        b) тип левого операнда не должен быть старше чем `Character`, тип правого не должен старше, чем `int`: допустимо расширение/сужение `byte` в/из `short`, `byte` в/из `char`, `short` в/из `char` и только сужение `byte` из `int`, `short` из `int`, `char` из `int`. Все остальные варианты требуют явного приведения типов).

Дополнительной особенностью целочисленных классов-оберток, созданных автоупаковкой констант в диапазоне `-128 ... +127` является то, что они кэшируются JVM. Поэтому такие обертки с одинаковыми значениями будут являться ссылками на один объект.

[к оглавлению](#java-core)

## Какие есть особенности класса `String`?
+ Это неизменяемый (immutable) и финализированный тип данных;
+ Строки-литералы, интернированные объекты класса `String` JVM хранит в пуле строк;
+ Объект класса `String` можно получить, используя двойные кавычки;
+ Можно использовать оператор `+` для конкатенации строк;
+ Начиная с Java 7 строки можно использовать в конструкции `switch`.

[к оглавлению](#java-core)

## Почему `String` неизменяемый и финализированный класс?
Есть несколько преимуществ в неизменности строк:

+ Пул строк возможен только потому, что строка неизменяемая, таким образом виртуальная машина сохраняет больше свободного места в _Heap_, поскольку разные строковые переменные указывают на одну и ту же переменную в пуле. Если бы строка была изменяемой, то интернирование строк не было бы возможным, потому что изменение значения одной переменной отразилось бы также и на остальных переменных, ссылающихся на эту строку.
+ Если строка будет изменяемой, тогда это станет серьезной угрозой безопасности приложения. Например, имя пользователя базы данных и пароль передаются строкой для получения соединения с базой данных и в программировании сокетов реквизиты хоста и порта передаются строкой. Так как строка неизменяемая, её значение не может быть изменено, в противном случае злоумышленник может изменить значение ссылки и вызвать проблемы в безопасности приложения.
+ Неизменяемость позволяет избежать синхронизации: строки безопасны для многопоточности и один экземпляр строки может быть совместно использован различными потоками.
+ Строки используются _classloader_ и неизменность обеспечивает правильность загрузки класса.
+ Поскольку строка неизменяемая, её `hashCode()` кэшируется в момент создания и нет необходимости рассчитывать его снова. Это делает строку отличным кандидатом для ключа в `HashMap` т.к. его обработка происходит быстрее.

[к оглавлению](#java-core)

## Почему `char[]` предпочтительнее `String` для хранения пароля?
С момента создания строка остаётся в пуле, до тех пор, пока не будет удалена сборщиком мусора. Поэтому, даже после окончания использования пароля, он некоторое время продолжает оставаться доступным в памяти и способа избежать этого не существует. Это представляет определённый риск для безопасности, поскольку кто-либо, имеющий доступ к памяти сможет найти пароль в виде текста.
В случае использования массива символов для хранения пароля имеется возможность очистить его сразу по окончанию работы с паролем, позволяя избежать риска безопасности, свойственного строке.

[к оглавлению](#java-core)

## Почему строка является популярным ключом в `HashMap` в Java?
Поскольку строки неизменяемы, их хэш код вычисляется и кэшируется в момент создания, не требуя повторного пересчета при дальнейшем использовании. Поэтому в качестве ключа `HashMap` они будут обрабатываться быстрее.

[к оглавлению](#java-core)

## Что делает метод `intern()` в классе `String`?.
Метод `intern()` используется для сохранения строки в пуле строк или получения ссылки, если такая строка уже находится в пуле.

[к оглавлению](#java-core)

## Можно ли использовать строки в конструкции `switch`?
Да, начиная с Java 7 в операторе `switch` можно использовать строки, ранние версии Java не поддерживают этого. При этом:

+ участвующие строки чувствительны к регистру;
+ используется метод `equals()` для сравнения полученного значения со значениями `case`, поэтому во избежание `NullPointerException` стоит предусмотреть проверку на `null`.
+ согласно документации, Java 7 для строк в `switch`, компилятор Java формирует более эффективный байткод для строк в конструкции `switch`, чем для сцепленных условий `if`-`else`.

[к оглавлению](#java-core)

## Какая основная разница между `String`, `StringBuffer`, `StringBuilder`?
Класс `String` является неизменяемым (_immutable_) - модифицировать объект такого класса нельзя, можно лишь заменить его созданием нового экземпляра.

Класс `StringBuffer` изменяемый - использовать `StringBuffer` следует тогда, когда необходимо часто модифицировать содержимое. 

Класс `StringBuilder` был добавлен в Java 5 и он во всем идентичен классу `StringBuffer` за исключением того, что он не синхронизирован и поэтому его методы выполняются значительно быстрей.

[к оглавлению](#java-core)


## Что такое класс `Object`? Какие в нем есть методы?
`Object` это базовый класс для всех остальных объектов в Java. Любой класс наследуется от `Object` и, соответственно, наследуют его методы:

`public boolean equals(Object obj)` – служит для сравнения объектов по значению;

`int hashCode()` – возвращает hash код для объекта;

`String toString()` – возвращает строковое представление объекта;

`Class getClass()` – возвращает класс объекта во время выполнения;

`protected Object clone()` – создает и возвращает копию объекта;

`void notify()` – возобновляет поток, ожидающий монитор;

`void notifyAll()` – возобновляет все потоки, ожидающие монитор;

`void wait()` – остановка вызвавшего метод потока до момента пока другой поток не вызовет метод `notify()` или `notifyAll()` для этого объекта;

`void wait(long timeout)` – остановка вызвавшего метод потока на определённое время или пока другой поток не вызовет метод `notify()` или `notifyAll()` для этого объекта;

`void wait(long timeout, int nanos)` – остановка вызвавшего метод потока на определённое время или пока другой поток не вызовет метод `notify()` или `notifyAll()` для этого объекта;

`protected void finalize()` – может вызываться сборщиком мусора в момент удаления объекта при сборке мусора.

[к оглавлению](#java-core)

## Дайте определение понятию «конструктор».
__Конструктор__ — это специальный метод, у которого отсутствует возвращаемый тип и который имеет то же имя, что и класс, в котором он используется. Конструктор вызывается при создании нового объекта класса и определяет действия необходимые для его инициализации.

[к оглавлению](#java-core)

## Что такое _«конструктор по умолчанию»_?
Если у какого-либо класса не определить конструктор, то компилятор сгенерирует конструктор без аргументов - так называемый __«конструктор по умолчанию»__.

```java
public ClassName() {}
```

Если у класса уже определен какой-либо конструктор, то конструктор по умолчанию создан не будет и, если он необходим, его нужно описывать явно.

[к оглавлению](#java-core)

## Чем отличаются конструктор по-умолчанию, конструктор копирования и конструктор с параметрами?

У конструктора по умолчанию отсутствуют какие-либо аргументы. Конструктор копирования принимает в качестве аргумента уже существующий объект класса для последующего создания его клона. Конструктор с параметрами имеет в своей сигнатуре аргументы (обычно необходимые для инициализации полей класса).

[к оглавлению](#java-core)

## Где и как вы можете использовать приватный конструктор?
Приватный (помеченный ключевым словом `private`, скрытый) конструктор может использоваться публичным статическим методом генерации объектов данного класса. Также доступ к нему разрешён вложенным классам и может использоваться для их нужд.

[к оглавлению](#java-core)

## Расскажите про классы-загрузчики и про динамическую загрузку классов.
Основа работы с классами в Java — классы-загрузчики, обычные Java-объекты, предоставляющие интерфейс для поиска и создания объекта класса по его имени во время работы приложения.

В начале работы программы создается 3 основных загрузчика классов:

+ __базовый загрузчик (bootstrap/primordial)__. Загружает основные системные и внутренние классы JDK (_Core API_ - пакеты `java.*` (`rt.jar` и `i18n.jar`) . Важно заметить, что базовый загрузчик является _«Изначальным»_ или _«Корневым»_ и частью JVM, вследствие чего его нельзя создать внутри кода программы.
+ __загрузчик расширений (extention)__. Загружает различные пакеты расширений, которые располагаются в директории `<JAVA_HOME>/lib/ext` или другой директории, описанной в системном параметре `java.ext.dirs`. Это позволяет обновлять и добавлять новые расширения без необходимости модифицировать настройки используемых приложений. Загрузчик расширений реализован классом `sun.misc.Launcher$ExtClassLoader`. 
+ __системный загрузчик (system/application)__. Загружает классы, пути к которым указаны в переменной окружения `CLASSPATH` или пути, которые указаны в командной строке запуска JVM после ключей `-classpath` или `-cp`. Системный загрузчик реализован классом `sun.misc.Launcher$AppClassLoader`.

Загрузчики классов являются иерархическими: каждый из них (кроме базового) имеет родительский загрузчик и в большинстве случаев, перед тем как попробовать загрузить класс самостоятельно, он посылает вначале запрос родительскому загрузчику загрузить указанный класс. Такое делегирование позволяет загружать классы тем загрузчиком, который находится ближе всего к базовому в иерархии делегирования. Как следствие поиск классов будет происходить в источниках в порядке их доверия: сначала в библиотеке _Core API_, потом в папке расширений, потом в локальных файлах `CLASSPATH`. 

Процесс загрузки класса состоит из трех частей:

+ _Loading_ – на этой фазе происходит поиск и физическая загрузка файла класса в определенном источнике (в зависимости от загрузчика). Этот процесс определяет базовое представление класса в памяти. На этом этапе такие понятия как «методы», «поля» и т.д. пока не известны.
+ _Linking_ – процесс, который может быть разбит на 3 части:
    + _Bytecode verification_ – проверка байт-кода на соответствие требованиям, определенным в спецификации JVM.
    + _Class preparation_ – создание и инициализация необходимых структур, используемых для представления полей, методов, реализованных интерфейсов и т.п., определенных в загружаемом классе.
    + _Resolving_ – загрузка набора классов, на которые ссылается загружаемый класс.
+ _Initialization_ – вызов статических блоков инициализации и присваивание полям класса значений по умолчанию.

Динамическая загрузка классов в Java имеет ряд особенностей:

+ _отложенная (lazy) загрузка и связывание классов_. Загрузка классов производится только при необходимости, что позволяет экономить ресурсы и распределять нагрузку.
+ _проверка корректности загружаемого кода (type safeness)_. Все действия связанные с контролем использования типов производятся только во время загрузки класса, позволяя избежать дополнительной нагрузки во время выполнения кода.
+ _программируемая загрузка_. Пользовательский загрузчик полностью контролирует процесс получения запрошенного класса — самому ли искать байт-код и создавать класс или делегировать создание другому загрузчику. Дополнительно существует возможность выставлять различные атрибуты безопасности для загружаемых классов, позволяя таким образом работать с кодом из ненадежных источников.
+ _множественные пространства имен_. Каждый загрузчик имеет своё пространство имён для создаваемых классов. Соответственно, классы, загруженные двумя различными загрузчиками на основе общего байт-кода, в системе будут различаться.

Существует несколько способов инициировать загрузку требуемого класса:

+ явный: вызов `ClassLoader.loadClass()` или `Class.forName()` (по умолчанию используется загрузчик, создавший текущий класс, но есть возможность и явного указания загрузчика);
+ неявный: когда для дальнейшей работы приложения требуется ранее не использованный класс, JVM инициирует его загрузку.

[к оглавлению](#java-core)

## Что такое _Reflection_?
__Рефлексия (Reflection)__ - это механизм получения данных о программе во время её выполнения (runtime). В Java _Reflection_ осуществляется с помощью _Java Reflection API_, состоящего из классов пакетов `java.lang` и `java.lang.reflect`.

Возможности Java Reflection API: 

+ Определение класса объекта;
+ Получение информации о модификаторах класса, полях, методах, конструкторах и суперклассах;
+ Определение интерфейсов, реализуемых классом;
+ Создание экземпляра класса;
+ Получение и установка значений полей объекта;
+ Вызов методов объекта;
+ Создание нового массива.

[к оглавлению](#java-core)

## Зачем нужен `equals()`. Чем он отличается от операции `==`?
Метод `equals()` - определяет отношение эквивалентности объектов.

При сравнении объектов с помощью `==` сравнение происходит лишь между ссылками. При сравнении по переопределённому разработчиком `equals()` - по внутреннему состоянию объектов.

[к оглавлению](#java-core)

## Если вы хотите переопределить `equals()`, какие условия должны выполняться?
## Какими свойствами обладает порождаемое `equals()` отношение эквивалентности?
+ _Рефлексивность_: для любой ссылки на значение `x`, `x.equals(x)` вернет `true`;
+ _Симметричность_: для любых ссылок на значения `x` и `y`, `x.equals(y)` должно вернуть `true`, тогда и только тогда, когда `y.equals(x)` возвращает `true`.
+ _Транзитивность_: для любых ссылок на значения `x`, `y` и `z`, если `x.equals(y)` и `y.equals(z)` возвращают `true`, тогда и `x.equals(z)` вернёт `true`;
+ _Непротиворечивость_: для любых ссылок на значения `х` и `у`, если несколько раз вызвать `х.equals(y)`, постоянно будет возвращаться значение `true` либо постоянно будет возвращаться значение `false` при условии, что никакая информация, используемая при сравнении объектов, не поменялась.

Для любой ненулевой ссылки на значение `х` выражение `х.equals(null)` должно возвращать `false`.

[к оглавлению](#java-core)

## Правила переопределения метода `Object.equals()`.
1. Использование оператора `==` для проверки, является ли аргумент ссылкой на указанный объект. Если является, возвращается `true`. Если сравниваемый объект `== null`, должно вернуться `false`.
2. Использование вызова метода `getClass()` для проверки, имеет ли аргумент правильный тип. Если не имеет, возвращается `false`.
3. Приведение аргумента к правильному типу. Поскольку эта операция следует за проверкой `instanceof` она гарантированно будет выполнена.
4. Обход всех значимых полей класса и проверка того, что значение поля в текущем объекте и значение того же поля в проверяемом на эквивалентность аргументе соответствуют друг другу. Если проверки для всех полей прошли успешно, возвращается результат `true`, в противном случае - `false`.

По окончанию переопределения метода `equals()` следует проверить: является ли порождаемое отношение эквивалентности рефлексивным, симметричным, транзитивным и непротиворечивым? Если ответ отрицательный, метод подлежит соответствующей правке.

[к оглавлению](#java-core)

## Какая связь между `hashCode()` и `equals()`?
## Если `equals()` переопределен, есть ли какие-либо другие методы, которые следует переопределить?
Равные объекты должны возвращать одинаковые хэш коды. При переопределении `equals()` нужно обязательно переопределять и метод `hashCode()`.

[к оглавлению](#java-core)

## Что будет, если переопределить `equals()` не переопределяя `hashCode()`? Какие могут возникнуть проблемы?
Классы и методы, которые используют правила этого контракта могут работать некорректно. Так для `HashMap` это может привести к тому, что пара «ключ-значение», которая была в неё помещена при использовании нового экземпляра ключа не будет в ней найдена.

[к оглавлению](#java-core)

## Каким образом реализованы методы `hashCode()` и `equals()` в классе `Object`?
Реализация метода `Object.equals()` сводится к проверке на равенство двух ссылок:

```java
public boolean equals(Object obj) {
  return (this == obj);
}
```

Реализация метода `Object.hashCode()` описана как `native`, т.е. определенной не с помощью Java кода и в общем случае зависит от реализации JVM:

```java 
public native int hashCode();
```

В HotSpot JVM хэш код по умолчанию вычисляется с помощью алгоритма генерации простых чисел - Xorshift.

[к оглавлению](#java-core)

## Для чего нужен метод `hashCode()`?
Метод `hashCode()` необходим для вычисления хэш кода переданного в качестве входного параметра объекта. В Java это целое число, в более широком смысле - битовая строка фиксированной длины, полученная из массива произвольной длины. Этот метод реализован таким образом, что для одного и того же входного объекта, хэш код всегда будет одинаковым. Следует понимать, что в Java множество возможных хэш кодов ограничено типом `int`, а множество объектов ничем не ограничено. Из-за этого, вполне возможна ситуация, что хэш коды разных объектов могут совпасть:

+ если хэш коды разные, то и объекты гарантированно разные;
+ если хэш коды равны, то объекты не обязательно равны(могут быть разные).

[к оглавлению](#java-core)

## Каковы правила переопределения метода `Object.hashCode()`?
## Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете `hashCode()`?
Общий совет: выбирать поля, которые с большой долью вероятности будут различаться. Для этого необходимо использовать уникальные, лучше всего примитивные поля, например, такие как `id`, `uuid`. При этом нужно следовать правилу, если поля задействованы при вычислении `hashCode()`, то они должны быть задействованы и при выполнении `equals()`.

[к оглавлению](#java-core)

## Могут ли у разных объектов быть одинаковые `hashCode()`?
Да, могут. Метод `hashCode()` не гарантирует уникальность возвращаемого значения. Ситуация, когда у разных объектов одинаковые хэш коды называется _коллизией_. Вероятность возникновения коллизии зависит от используемого алгоритма генерации хэш кода.

[к оглавлению](#java-core)

## Если у класса `Point{int x, y;}` реализовать метод `equals(Object that) {(return this.x == that.x && this.y == that.y)}`, но сделать хэш код в виде `int hashCode() {return x;}`, то будут ли корректно такие точки помещаться и извлекаться из `HashSet`?
`HashSet` использует `HashMap` для хранения элементов. При добавлении элемента в `HashMap` вычисляется хэш код, по которому определяется позиция в массиве, куда будет вставлен новый элемент. У всех экземпляров класса `Point` хэш код будет одинаковым для всех объектов с одинаковым `x`, что приведёт к вырождению хэш таблицы в список. 

При возникновении коллизии в `HashMap` осуществляется проверка на наличие элемента в списке: `e.hash == hash && ((k = e.key) == key || key.equals(k))`. Если элемент найден, то его значение перезаписывается. В нашем случае для разных объектов метод `equals()` будет возвращать `false`. Соответственно новый элемент будет успешно добавлен в `HashSet`. Извлечение элемента также будет осуществляться успешно. Но производительность такого кода будет невысокой, из-за неэффективности хэш-функции, которая cпособна породить большое количество колизий.
[к оглавлению](#java-core)

## Могут ли у разных объектов `(ref0 != ref1)` быть `ref0.equals(ref1) == true`?
Да, могут. Для этого в классе этих объектов должен быть переопределен метод `equals()`.

Если используется метод `Object.equals()`, то для двух ссылок `x` и `y` метод вернет `true` тогда и только тогда, когда обе ссылки указывают на один и тот же объект (т.е. `x == y` возвращает `true`).

[к оглавлению](#java-core)

## Могут ли у разных ссылок на один объект `(ref0 == ref1)` быть `ref0.equals(ref1) == false`?
В общем случае - могут, если метод `equals()` реализован некорректно и не выполняет свойство рефлексивности: для любых ненулевых ссылок `x` метод `x.equals(x)` должен возвращать `true`.

[к оглавлению](#java-core)

## Можно ли так реализовать метод `equals(Object that) {return this.hashCode() == that.hashCode()}`?
Строго говоря нельзя, поскольку метод `hashCode()` не гарантирует уникальность значения для каждого объекта. Однако для сравнения экземпляров класса `Object` такой код допустим, т.к. метод `hashCode()` в классе `Object` возвращает уникальные значения для разных объектов (его вычисление основано на использовании алгоритма генерации случайных чисел).

[к оглавлению](#java-core)

## В `equals()` требуется проверять, что аргумент `equals(Object that)` такого же типа что и сам объект. В чем разница между `this.getClass() == that.getClass()` и `that instanceof MyClass`?
Оператор `instanceof` сравнивает объект и указанный тип. Его можно использовать для проверки является ли данный объект экземпляром некоторого класса, либо экземпляром его дочернего класса, либо экземпляром класса, который реализует указанный интерфейс.

`this.getClass() == that.getClass()` проверяет два класса на идентичность, поэтому для корректной реализации контракта метода `equals()` необходимо использовать точное сравнение с помощью метода `getClass()`.

[к оглавлению](#java-core)

## Можно ли реализовать метод `equals()` класса `MyClass` вот так: `class MyClass {public boolean equals(MyClass that) {return this == that;}}`?
Реализовать можно, но данный метод не переопределяет метод `equals()` класса `Object`, а перегружает его.

[к оглавлению](#java-core)

## Есть класс `Point{int x, y;}`. Почему хэш код в виде `31 * x + y` предпочтительнее чем `x + y`?
Множитель создает зависимость значения хэш кода от очередности обработки полей, что в итоге порождает лучшую хэш функцию.

[к оглавлению](#java-core)

## Расскажите про клонирование объектов.
Использование оператора присваивания не создает нового объекта, а лишь копирует ссылку на объект. Таким образом, две ссылки указывают на одну и ту же область памяти, на один и тот же объект. Для создания нового объекта с таким же состоянием используется клонирование объекта. 

Класс `Object` содержит `protected` метод `clone()`, осуществляющий побитовое копирование объекта производного класса. Однако сначала необходимо переопределить метод `clone()` как `public` для обеспечения возможности его вызова. В переопределенном методе следует вызвать базовую версию метода `super.clone()`, которая и выполняет собственно клонирование. 

Чтобы окончательно сделать объект клонируемым, класс должен реализовать интерфейс `Cloneable`. Интерфейс `Cloneable` не содержит методов относится к маркерным интерфейсам, а его реализация гарантирует, что метод `clone()` класса `Object` возвратит точную копию вызвавшего его объекта с воспроизведением значений всех его полей. В противном случае метод генерирует исключение `CloneNotSupportedException`. Следует отметить, что при использовании этого механизма объект создается без вызова конструктора.

Это решение эффективно только в случае, если поля клонируемого объекта представляют собой значения базовых типов и их обёрток или неизменяемых (immutable) объектных типов. Если же поле клонируемого типа является изменяемым ссылочным типом, то для корректного клонирования требуется другой подход. Причина заключается в том, что при создании копии поля оригинал и копия представляют собой ссылку на один и тот же объект. В этой ситуации следует также клонировать и сам объект поля класса.

Такое клонирование возможно только в случае, если тип атрибута класса также реализует интерфейс `Cloneable` и переопределяет метод `clone()`. Так как, если это будет иначе вызов метода невозможен из-за его недоступности. Отсюда следует, что если класс имеет суперкласс, то для реализации механизма клонирования текущего класса-потомка необходимо наличие корректной реализации такого механизма в суперклассе. При этом следует отказаться от использования объявлений `final` для полей объектных типов по причине невозможности изменения их значений при реализации клонирования.

Помимо встроенного механизма клонирования в Java для клонирования объекта можно использовать:

+ __Специализированный конструктор копирования__ - в классе описывается конструктор, который принимает объект этого же класса и инициализирует поля создаваемого объекта значениями полей переданного.
+ __Фабричный метод__ - (Factory method), который представляет собой статический метод, возвращающий экземпляр своего класса.
+ __Механизм сериализации__ - сохранение и последующее восстановление объекта в/из потока байтов.

[к оглавлению](#java-core)

## В чем отличие между _поверхностным_ и _глубоким_ клонированием?
__Поверхностное копирование__ копирует настолько малую часть информации об объекте, насколько это возможно. По умолчанию, клонирование в Java является поверхностным, т.е. класс `Object` не знает о структуре класса, которого он копирует. Клонирование такого типа осуществляется JVM по следующим правилам: 

+ Если класс имеет только члены примитивных типов, то будет создана совершенно новая копия объекта и возвращена ссылка на этот объект.
+ Если класс помимо членов примитивных типов содержит члены ссылочных типов, то тогда копируются ссылки на объекты этих классов. Следовательно, оба объекта будут иметь одинаковые ссылки.

__Глубокое копирование__ дублирует абсолютно всю информацию объекта:
+ Нет необходимости копировать отдельно примитивные данные;
+ Все члены ссылочного типа в оригинальном классе должны поддерживать клонирование. Для каждого такого члена при переопределении метода `clone()` должен вызываться `super.clone()`;
+ Если какой-либо член класса не поддерживает клонирование, то в методе клонирования необходимо создать новый экземпляр этого класса и скопировать каждый его член со всеми атрибутами в новый объект класса, по одному.

[к оглавлению](#java-core)

## Какой способ клонирования предпочтительней?
Наиболее безопасным и, следовательно, предпочтительным способом клонирования является использование специализированного конструктора копирования: 

+ Отсутствие ошибок наследования (не нужно беспокоиться, что у наследников появятся новые поля, которые не будут склонированы через метод `clone()`);
+ Поля для клонирования указываются явно;
+ Возможность клонировать даже `final` поля.

[к оглавлению](#java-core)

## Почему метод `clone()` объявлен в классе `Object`, а не в интерфейсе `Cloneable`?
Метод `clone()` объявлен в классе `Object` с указанием модификатора `native`, чтобы обеспечить доступ к стандартному механизму поверхностного копирования объектов. Одновременно он объявлен и как `protected`, чтобы нельзя было вызвать этот метод у не переопределивших его объектов. Непосредственно интерфейс `Cloneable` является маркерным (не содержит объявлений методов) и нужен только для обозначения самого факта, что данный объект готов к тому, чтобы быть клонированным. Вызов переопределённого метода `clone()` у не `Cloneable` объекта вызовет выбрасывание `CloneNotSupportedException`.

[к оглавлению](#java-core)

## Опишите иерархию исключений.
Исключения делятся на несколько классов, но все они имеют общего предка — класс `Throwable`, потомками которого являются классы `Exception` и `Error`.

__Ошибки (Errors)__ представляют собой более серьёзные проблемы, которые, согласно спецификации Java, не следует обрабатывать в собственной программе, поскольку они связаны с проблемами уровня JVM. Например, исключения такого рода возникают, если закончилась память доступная виртуальной машине.

__Исключения (Exceptions)__ являются результатом проблем в программе, которые в принципе решаемы, предсказуемы и последствия которых возможно устранить внутри программы. Например, произошло деление целого числа на ноль.

[к оглавлению](#java-core)

## Какие виды исключений в Java вы знаете, чем они отличаются?
## Что такое _checked_ и _unchecked exception_?
В Java все исключения делятся на два типа:

+ __checked (контролируемые/проверяемые исключения)__ должны обрабатываться блоком `catch` или описываться в заголовке метода (например, `throws IOException`). Наличие такого обработчика/модификатора в заголовке метода проверяется на этапе компиляции;
+ __unchecked (неконтролируемые/непроверяемые исключения)__, к которым относятся ошибки `Error` (например, `OutOfMemoryError`), обрабатывать которые не рекомендуется и исключения времени выполнения, представленные классом `RuntimeException` и его наследниками (например, `NullPointerException`), которые могут не обрабатываться блоком `catch` и не быть описанными в заголовке метода.

[к оглавлению](#java-core)

## зачем checked исключения в джаве
Нужны, чтобы заставить программу явно думать об ошибках: API объявляют, какие проблемы могут случиться, и компилятор требует обработать или пробросить их.
Это повышает надёжность в тех местах, где есть реальная возможность восстановиться (I/O, ввод-вывод, сети).
Помогают сделать контракт метода более самодокументируемым — вызывающий сразу видит возможные исключения.
Минусы: приводят к многословному коду, «оборачивают» ошибки в boilerplate и могут поощрять плохое обрабатывание (пустые catch или повторный вайп).
Практическое правило: хорошо для восстановимых условий; плохи для ошибок программирования (нуль-поинтеры, логика) — для них удобнее unchecked.
Итого: checked исключения — инструмент для явной обработки ошибок; полезны концептуально, но на практике требуют дисциплины, иначе становятся обузой.

## Какой оператор позволяет принудительно выбросить исключение?
Это оператор `throw`:

```java
throw new Exception();
```

[к оглавлению](#java-core)

## О чем говорит ключевое слово `throws`?
Модификатор `throws` прописывается в заголовке метода и указывает на то, что метод потенциально может выбросить исключение с указанным типом.

[к оглавлению](#java-core)

## Как написать собственное («пользовательское») исключение?
Необходимо унаследоваться от базового класса требуемого типа исключений (например, от `Exception` или `RuntimeException`).

```java
class CustomException extends Exception {
    public CustomException() {
        super();
    }

    public CustomException(final String string) {
        super(string + " is invalid");
    }

    public CustomException(final Throwable cause) {
        super(cause);
    }
}
```

[к оглавлению](#java-core)

## Какие существуют _unchecked exception_?
Наиболее часто встречающиеся: `ArithmeticException`, `ClassCastException`, `ConcurrentModificationException`, `IllegalArgumentException`, `IllegalStateException`, `IndexOutOfBoundsException`, `NoSuchElementException`, `NullPointerException`, `UnsupportedOperationException`.

[к оглавлению](#java-core)

## Что представляет из себя ошибки класса `Error`?
Ошибки класса `Error` представляют собой наиболее серьёзные проблемы уровня JVM. Например, исключения такого рода возникают, если закончилась память доступная виртуальной машине. Обрабатывать такие ошибки не запрещается, но делать этого не рекомендуется.

[к оглавлению](#java-core)

## Что вы знаете о `OutOfMemoryError`?
`OutOfMemoryError` выбрасывается, когда виртуальная машина Java не может создать (разместить) объект из-за нехватки памяти, а сборщик мусора не может высвободить достаточное её количество.

Область памяти, занимаемая java процессом, состоит из нескольких частей. Тип `OutOfMemoryError` зависит от того, в какой из них не хватило места:

+ `java.lang.OutOfMemoryError: Java heap space`: Не хватает места в куче, а именно, в области памяти в которую помещаются объекты, создаваемые в приложении программно. Обычно проблема кроется в утечке памяти. Размер задается параметрами `-Xms` и `-Xmx`.
+ `java.lang.OutOfMemoryError: PermGen space`: (до версии Java 8) Данная ошибка возникает при нехватке места в _Permanent_ области, размер которой задается параметрами `-XX:PermSize` и `-XX:MaxPermSize`.
+ `java.lang.OutOfMemoryError: GC overhead limit exceeded`: Данная ошибка может возникнуть как при переполнении первой, так и второй областей. Связана она с тем, что памяти осталось мало и сборщик мусора постоянно работает, пытаясь высвободить немного места. Данную ошибку можно отключить с помощью параметра `-XX:-UseGCOverheadLimit`.
+ `java.lang.OutOfMemoryError: unable to create new native thread`: Выбрасывается, когда нет возможности создавать новые потоки.

[к оглавлению](#java-core)

## Опишите работу блока _try-catch-finally_.
`try` — данное ключевое слово используется для отметки начала блока кода, который потенциально может привести к ошибке.
`catch` — ключевое слово для отметки начала блока кода, предназначенного для перехвата и обработки исключений в случае их возникновения.
`finally` — ключевое слово для отметки начала блока кода, который является дополнительным. Этот блок помещается после последнего блока `catch`. Управление передаётся в блок `finally` в любом случае, было выброшено исключение или нет.

Общий вид конструкции для обработки исключительной ситуации выглядит следующим образом:

```java
try { 
    //код, который потенциально может привести к исключительной ситуации 
} 
catch(SomeException e ) { //в скобках указывается класс конкретной ожидаемой ошибки  
    //код обработки исключительной ситуации
} 
finally {
    //необязательный блок, код которого выполняется в любом случае
}
```

[к оглавлению](#java-core)

## Что такое механизм _try-with-resources_?
Данная конструкция, которая появилась в Java 7, позволяет использовать блок _try-catch_ не заботясь о закрытии ресурсов, используемых в данном сегменте кода.
Ресурсы объявляются в скобках сразу после `try`, а компилятор уже сам неявно создаёт секцию `finally`, в которой и происходит освобождение занятых в блоке ресурсов. Под ресурсами подразумеваются сущности, реализующие интерфейс `java.lang.Autocloseable`. 

Общий вид конструкции:

```java
try(/*объявление ресурсов*/) {
    //...
} catch(Exception ex) {
    //...
} finally {
    //...
}
```

Стоит заметить, что блоки `catch` и явный `finally` выполняются уже после того, как закрываются ресурсы в неявном `finally`.

[к оглавлению](#java-core)

## Возможно ли использование блока _try-finally_ (без `catch`)?
Такая запись допустима, но смысла в такой записи не так много, всё же лучше иметь блок `catch`, в котором будет обрабатываться необходимое исключение.

[к оглавлению](#java-core)

## Может ли один блок `catch` отлавливать сразу несколько исключений?
В Java 7 стала доступна новая языковая конструкция, с помощью которой можно перехватывать несколько исключений одним блоком `catch`:

```java
try {  
    //...
} catch(IOException | SQLException ex) {
    //...
}
```

[к оглавлению](#java-core)

## Всегда ли исполняется блок `finally`?
Код в блоке `finally` будет выполнен всегда, независимо от того, выброшено исключение или нет.

[к оглавлению](#java-core)

## Существуют ли ситуации, когда блок `finally` не будет выполнен?
Например, когда JVM «умирает» - в такой ситуации `finally` недостижим и не будет выполнен, так как происходит принудительный системный выход из программы:

```java
try { 
    System.exit(0); 
} catch(Exception e) { 
    e.printStackTrace(); 
} finally { }
```

[к оглавлению](#java-core)

## Может ли метод _main()_ выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?
Может и оно будет передано в виртуальную машину Java (JVM).

## Кратко — как работает + для строк в Java 14.

Что делает +
Обычная операция объединения: "a" + "b" → "ab". (Если один из операндов — объект, вызывается toString(); если ссылка null — вставляется строка "null".) 

Компиляция vs время выполнения
Если обе стороны — строковые литералы (или выражения, вычисляемые во время компиляции), объединение выполняется на этапе компиляции и в итоговый класс попадает уже готовая константа. 

В остальных случаях (переменные, выражения) на уровне байт-кода начиная с Java 9 компилятор генерирует invokedynamic-вызов, который делегирует исполнение в StringConcatFactory — это даёт JVM возможность выбирать оптимальную реализацию (напр., шаблоны, StringBuilder-подход или другие оптимизации) без изменения байт-кода в будущем. То же поведение в Java 14. 

Производительность — кратко
Для редких конкатенаций используйте + — читабельно и JVM оптимизирует. Для очень горячих циклов с большим количеством шагов традиционно рекомендуют StringBuilder, но в современных JVM разница может быть не такой заметной из-за invokedynamic-оптимизаций. 

Примеры

// compile-time
String s1 = "Hello, " + "world!"; // компилятор складывает в "Hello, world!"

// runtime
String name = getName();
String s2 = "Hello, " + name; // вызов в runtime (invokedynamic -> StringConcatFactory)

// null handling
String s3 = "X: " + null; // результат "X: null"



[к оглавлению](#java-core)

## Предположим, есть метод, который может выбросить `IOException` и `FileNotFoundException` в какой последовательности должны идти блоки `catch`? Сколько блоков `catch` будет выполнено?
Общее правило: обрабатывать исключения нужно от «младшего» к старшему. Т.е. нельзя поставить в первый блок `catch(Exception ex) {}`, иначе все дальнейшие блоки `catch()` уже ничего не смогут обработать, т.к. любое исключение будет соответствовать обработчику `catch(Exception ex)`.

Таким образом, исходя из факта, что `FileNotFoundException extends IOException` сначала нужно обработать `FileNotFoundException`, а затем уже `IOException`:

```java
void method() {
    try {
        //...
    } catch (FileNotFoundException ex) {
        //...
    } catch (IOException ex) {
        //...
    }
}
```

[к оглавлению](#java-core)    

## Что такое _generics_?
__Generics__ - это технический термин, обозначающий набор свойств языка позволяющих определять и использовать обобщенные типы и методы. Обобщенные типы или методы отличаются от обычных тем, что имеют типизированные параметры.

Примером использования обобщенных типов может служить _Java Collection Framework_. Так, класс `LinkedList<E>` - типичный обобщенный тип. Он содержит параметр `E`, который представляет тип элементов, которые будут храниться в коллекции. Создание объектов обобщенных типов происходит посредством замены параметризированных типов реальными типами данных. Вместо того, чтобы просто использовать `LinkedList`, ничего не говоря о типе элемента в списке, предлагается использовать точное указание типа `LinkedList<String>`, `LinkedList<Integer>` и т.п.

Отлично — сделаю большой подробный разбор дженериков и wildcard’ов в Java, с объяснениями «как это работает в рантайме», со всеми тонкостями, хитростями для собеса на senior Java и множеством детальных примеров кода с комментариями на русском (почти к каждой строке). Буду чередовать теорию и «практические ловушки», отмечая, какие вещи часто спрашивают на интервью. Где важно — дам ссылки на официальные источники и разъяснения (они в конце соответствующих разделов).

---

# 1) Краткая идея и базовые понятия
Generics (обобщённые типы) в Java — это средство обеспечить статическую типовую безопасность при работе с коллекциями и обобщёнными структуры данных: `List<String>` значит «список строк» на уровне компиляции. Важное отличие от некоторых других языков — Java реализует generics через **type erasure** (стирание типов), а не через реально персистентные типы в рантайме (reified generics). Это фундамент — многие кейсы и ограничения происходят именно из-за erasure.

---

# 2) Type erasure — что это и почему важно (и как это проявляется в рантайме)
**Ключевая мысль:** информация о параметризированных типах (`<T>`) НЕ сохраняется в байткоде в форме, позволяющей `instanceof` по `List<String>` и т.п. — компилятор стирает параметры типов и заменяет их на их первый ограничивающий тип (bound) или `Object` если bound отсутствует. Поэтому в рантайме `List<String>` и `List<Integer>` — это один и тот же класс `java.util.List`. Это объясняет, почему `new T[]` нельзя создавать напрямую, почему `if (obj instanceof List<String>)` — ошибочно, и почему иногда компилятор генерирует *bridge methods* для совместимости. 

Пример: `instanceof` и невозможность проверить параметр типа в рантайме

```java
import java.util.*;

public class ErasureExample {
    public static void main(String[] args) {
        List<String> ls = new ArrayList<>(); // список строк
        // этот код — компиляторская ошибка: нельзя использовать параметризованный тип в instanceof
        // boolean check = ls instanceof List<String>; // <- так нельзя

        // можно проверять только "сырые" типы (reifiable types):
        boolean checkRaw = ls instanceof List; // допустимо — true
        System.out.println(checkRaw); // true
    }
}
```
Комментарии:  
- `List<String>` — в рантайме просто `List`.  
- Попытка `instanceof List<String>` не компилируется, потому что информация о параметре `<String>` не хранится в рантайме. (см. JLS/Oracle Tutorial). 

---

# 3) Reifiable types и следствия (когда типы доступны в рантайме)
**Reifiable type** — тип, который полностью известен и доступен в рантайме (например, необобщённый класс, `int[]`, `List` без параметра). Параметризованный тип `List<String>` — *не* реифицируемый (non-reifiable), поэтому с ним нельзя делать некоторые операции (как `new T[]`, `instanceof List<String>`, сериализация некоторых обобщённых типов без хитростей).

Пример ошибки создания массива обобщённого типа:

```java
public class GenericArray<T> {
    // T[] arr = new T[10]; // компиляторская ошибка — нельзя создать массив параметризованного типа
    // Причина: элемент массива должен содержать информацию о реальном типе в рантайме, а T не реифицируем.
}
```

Решения/хак: обычно используют `Object[]` и касты, либо передают `Class<T>` / `TypeToken` для создания массивов при помощи `java.lang.reflect.Array.newInstance(...)`.

---

# 4) Bridge methods — тонкость, которую часто спрашивают
Когда у вас есть наследование с обобщёнными типами, из–за стирания типов сигнатуры методов могут менять «фактическую» сигнатуру, и компилятор вставляет *synthetic bridge methods* для поддержания виртуальной таблицы и бинарной совместимости. На собеседовании часто спрашивают: «покажи пример bridge method и объясни зачем она нужна».

Пример (упрощённый):

```java
// Базовый параметризованный интерфейс
interface Processor<T> {
    T process(T t);
}

// Реализация с конкретным типом
class StringProcessor implements Processor<String> {
    // Реализация: компилятор фактически генерирует этот метод
    public String process(String s) { return s.toUpperCase(); }

    // Но из-за type erasure интерфейс Processor<T> становится Processor:Object->Object
    // Компилятор добавит synthetic bridge:
    // public Object process(Object o) { return process((String) o); }
    // чтобы вызвать конкретную реализацию и сохранить виртуальную таблицу.
}
```

Почему это важно: bridge methods видны в отладчике/рефлексии как synthetic и могут влиять на безопасность (уязвимости, если кто-то полагается на сигнатуры), и на поведение инструментов, которые смотрят на методы.

---

# 5) Wildcards `? extends` и `? super`: variance и PECS (Producer Extends, Consumer Super)

# Java Generics: Wildcards, Extends, and Super
 
## 1. Wildcards `?`
 
В Java Generics символ `?` называется wildcard (подстановочный знак). Он представляет неизвестный тип. Wildcards особенно полезны, когда нужно работать с обобщёнными типами, но конкретный тип заранее неизвестен.
 
**Описание:**
 
 
- `?` позволяет создавать более гибкий код.
 
- Используется в методах и коллекциях для обозначения того, что тип неизвестен, но всё равно можно проводить безопасные операции.
 
- Позволяет передавать объекты разных типов в один и тот же метод, если они удовлетворяют определённым условиям.
 

 
**Пример:**
 `List<?> list = new ArrayList<String>(); List<?> numbers = new ArrayList<Integer>(); ` 
Здесь `list` и `numbers` могут быть списками любого типа. Но с ними можно только безопасно читать элементы как объекты `Object`, а добавлять нельзя.
 
**Пример метода с wildcard:**
 `public void printList(List<?> list) {     for (Object obj : list) {         System.out.println(obj);     } } ` 
Метод `printList` может принимать любой тип списка.
 
**Когда использовать:**
 
 
- Когда метод только читает данные из коллекции.
 
- Когда важно не привязываться к конкретному типу коллекции.
 

 
## 2. `extends` (Upper Bounded Wildcards)
 
`? extends T` используется для ограничения wildcard сверху. Это значит, что неизвестный тип должен быть либо `T`, либо подклассом `T`.
 
**Описание:**
 
 
- Используется, когда нужно читать элементы, но не изменять их.
 
- Обеспечивает безопасность типов.
 
- Часто применяется с коллекциями.
 

 
**Пример:**
 `List<? extends Number> numbers = new ArrayList<Integer>(); 
 Number n = numbers.get(0); // можно читать как Number //
 numbers.add(10); // ошибка, нельзя добавлять элементы ` 
**Пример метода:**
 `public double sum(List<? extends Number> list) {     
 double sum = 0;    
 for (Number n : list) {       
 sum += n.doubleValue();    
 }     
 return sum; } ` 
Метод `sum` может принимать список чисел любого типа, наследуемого от `Number`.
 
**Когда использовать:**
 
 
- Когда метод должен только читать данные.
 
- Когда важно ограничить тип сверху.
 

 
## 3. `super` (Lower Bounded Wildcards)
 
`? super T` используется для ограничения wildcard снизу. Это значит, что неизвестный тип должен быть либо `T`, либо суперклассом `T`.
 
**Описание:**
 
 
- Используется, когда нужно записывать элементы в коллекцию.
 
- Позволяет безопасно добавлять элементы типа `T` или его подклассов.
 
- Чтение элементов возможно только как `Object`.
 

 
**Пример:**
 `List<? super Integer> list = new ArrayList<Number>(); 
 list.add(10); 
 list.add(20); // 
 Integer i = list.get(0); // ошибка, возвращает Object ` 
**Пример метода:**
 `public void addNumbers(List<? super Integer> list) {  
 list.add(1);     
 list.add(2);
 } ` 
Метод `addNumbers` может добавлять `Integer` в любую коллекцию, которая является суперклассом `Integer`.
 
**Когда использовать:**
 
 
- Когда нужно записывать данные в коллекцию.
 
- Когда важно ограничить тип снизу.
 

 
## 4. Примеры использования всех wildcard
 `List<Integer> integers = Arrays.asList(1, 2, 3); 
 List<Double> doubles = Arrays.asList(1.5, 2.5); 
 printList(integers); // любой тип printList(doubles);  
 List<? extends Number> nums = integers;
 double s = sum(nums); 
 List<? super Integer> list = new ArrayList<Number>(); 
 addNumbers(list); ` 
Эти примеры показывают разные сценарии использования wildcard в Java Generics.
 
Скачать Markdown-файл здесь


# 6) Примеры — почему `? extends` запрещает добавление
Код + подробные комментарии:

```java
import java.util.*;

public class ExtendsExample {
    public static void main(String[] args) {
        List<Integer> ints = new ArrayList<>();
        ints.add(1); // ок
        List<? extends Number> numbers = ints; // ссылка с верхним ограничением

        // numbers.add(2); // ошибка компиляции — нельзя добавить, потому что numbers может указывать на List<Double> и т.д.
        Number n = numbers.get(0); // можно читать как Number — ok
    }
}
```
Комментарии:  
- `List<? extends Number> numbers = ints;` — `numbers` обозначает «какой-то список неизвестного конкретного сабтипа Number». Компилятор запрещает `add`, потому что это может нарушить типобезопасность для других реализаций.

---

# 7) Capture conversion и «capture of ?» ошибки
Иногда компилятор выдаёт сообщение об ошибке типа *capture of ?*. Capture conversion — механизм компилятора, который вводит временный скрытый тип (например, `capture#1-of ? extends Number`) чтобы внутри метода работать с конкретным захваченным типом. На практике: если нужно записать в коллекцию параметризованную `List<?>`, можно использовать вспомогательный generic-метод, который «поймает» wildcard.

Пример helper’а (популярный шаблон):

```java
import java.util.*;

public class CaptureHelper {
    // публичный API: любой List<?>
    public static void swapFirstTwo(List<?> list) {
        swapFirstTwoHelper(list); // делегируем в generic helper
    }

    // приватный helper с generic-параметром, который «поймает» wildcard
    private static <T> void swapFirstTwoHelper(List<T> list) {
        // безопасно обменять элементы внутри list
        if (list.size() >= 2) {
            T tmp = list.get(0);    // читаем как T
            list.set(0, list.get(1)); // записываем T
            list.set(1, tmp);      // записываем T
        }
    }
}
```
Комментарии:  
- `List<?>` нельзя напрямую редактировать, но при делегировании в `<T> void helper(List<T>)` компилятор «захватывает» конкретный тип и операции внутри helper’а безопасны.

---

# 8) Heap pollution, varargs и @SafeVarargs — ловушки
**Heap pollution** — ситуация, когда переменная ссылочного типа (обобщённого типа) содержит ссылку на объект другого, несовместимого параметризированного типа, что приводит к `ClassCastException` при извлечении. Частая причина — массивы обобщённых типов + varargs и приведения.

Пример (классическая ловушка):

```java
import java.util.*;

public class HeapPollution {
    @SafeVarargs
    static void dangerous(List<String>... stringLists) { // varargs параметр типа List<String>...
        Object[] array = stringLists;                     // varargs реализуются как массив
        array[0] = Arrays.asList(42);                     // записываем List<Integer> внутрь массива Object[]
        String s = stringLists[0].get(0);                 // ClassCastException в рантайме
        System.out.println(s);
    }

    public static void main(String[] args) {
        // dangerous(Arrays.asList("a", "b")); // при запуске — возможен ClassCastException
    }
}
```
Комментарии:  
- Varargs в Java реализуются как массивы (`T...` -> `T[]`), а массивы реифицируемы и ковариантны, поэтому смешивание generics и массивов может привести к heap pollution.  
- `@SafeVarargs` предотвращает предупреждения компилятора, но автор метода обязан гарантировать безопасность — аннотация не делает метод безопасным сама по себе.
Интервью-ответ: упомяните `@SafeVarargs`, объясните, что она применима к `final` и `static` методам (и к конструкторам с Java 9?), и что её использовать нужно очень осторожно.

---

# 9) Generics vs arrays — почему arrays ковариантны, generics инвариантны и какие проблемы это даёт
Массивы Java ковариантны: `String[]` — подтип `Object[]`. Generics — инвариантны: `List<String>` не является подтипом `List<Object>`. Это связано с тем, что массивы проверяют тип в рантайме (делают runtime checks) и поэтому позволили ковариантность исторически; generics же были добавлены позже и реализованы через erasure, поэтому сделали их инвариантными для типовой безопасности.

Типичная ошибка интервью: почему нельзя присвоить `List<String>` в `List<Object>`? Ответ: это нарушает безопасность — вы сможете положить туда `Integer` и получить `ClassCastException` при извлечении как `String`.

Код-пояснение:

```java
List<String> ls = new ArrayList<>();
// List<Object> lo = ls; // ошибка компиляции — generics инвариантны
Object[] oa = new String[1]; // допустимо — массивы ковариантны
oa[0] = 1; // ArrayStoreException в рантайме, потому что мы попытались положить Integer в массив String
```

---

# 10) Raw types — старые API и совместимость
Если использовать сырые типы (`List` без параметра), вы возвращаете совместимость со старым кодом, но теряете безопасность: компилятор даст предупреждения, и возможны `ClassCastException` в рантайме. На собесе важно сказать: raw types допустимы для совместимости, но их использование следует избегать.

---

# 11) Generics и метод equals / hashCode / Comparable — подводные камни
Иногда классы реализуют `Comparable<T>` и одновременно `equals`/`hashCode` — важно понимать сигнатуры и почему `compareTo` должен быть совместим с `equals`. Частая ошибка: реализовать `Comparable<SomeClass>` и одновременно пытаться сравнивать с другим дженериком — объясните контракт и мостовые методы (bridge) при generics/overriding.

---

# 12) Generic methods, bounded type parameters и multiple bounds
Пример метода с верхними и пересечёнными ограничениями:

```java
public static <T extends Number & Comparable<T>> T max(T a, T b) {
    // T ограничен Number и Comparable<T>
    return a.compareTo(b) >= 0 ? a : b;
}
```
Комментарии:  
- Порядок: `extends` потом `&` для интерфейсов. Если есть класс — он должен стоять первым, например `<T extends SomeClass & Interface1 & Interface2>`.

---

# 13) Как проверить generic-типы через рефлексию (TypeToken / ParameterizedType)
Поскольку параметры стираются, иногда нужно явно сохранить Type в рантайме: `Class<T>` или `java.lang.reflect.Type`/`ParameterizedType` (например, `new TypeReference<List<String>>() {}` в Jackson/Gson библиотеке). На собесе можно показать пример с `ParameterizedType` для проверки параметров у поля.

Пример (упрощённый):

```java
import java.lang.reflect.*;
import java.util.*;

class Holder {
    List<String> strings; // поле с параметризованным типом
}

public class ReflectGenerics {
    public static void main(String[] args) throws Exception {
        Field f = Holder.class.getDeclaredField("strings"); // получаем поле
        Type t = f.getGenericType();                        // тип поля с generic-информацией
        if (t instanceof ParameterizedType) {               // проверяем, что это ParameterizedType
            ParameterizedType pt = (ParameterizedType) t;   // приводим
            Type raw = pt.getRawType();                     // raw type — List
            Type[] argsTypes = pt.getActualTypeArguments(); // аргументы — [String]
            System.out.println(Arrays.toString(argsTypes)); // [class java.lang.String]
        }
    }
}
```
Комментарий: `getGenericType()` сохраняет info о параметрах, т.к. эта информация оставлена в байткоде для отражения (на уровне signature), хотя не для `instanceof List<String>`.

---

# 14) Wildcards в API: когда использовать `T`, `?`, `? extends`, `? super`
Интервью-совет:  
- Для полей класса обычно **не** используют wildcards — лучше параметризовать сам класс: `class Box<T> { ... }`.  
- Для параметров методов и возвращаемых типов используют wildcards чаще: `void process(List<? extends Foo> src)` или `List<? super Foo> dest`.  
- Если метод возвращает коллекцию, и вы хотите, чтобы вызов мог быть присвоен коллекции с `? extends`, используйте `? extends`.  
- Если метод принимает коллекцию для заполнения, используйте `? super`.

---

# 15) Частые вопросы на собесах и короткие ответы (cheat-sheet)
1. **Почему `List<String>` не подтип `List<Object>`?** — потому что generics инвариантны; иначе можно было бы положить `Integer` в `List<String>`.  
2. **Почему нельзя проверить `instanceof List<String>`?** — из-за type erasure. (см. секцию 2).
3. **Что такое heap pollution?** — переменная generic-типа указывает на объект с некорректным параметризированным типом; часто имеет отношение к varargs/массивам.
4. **Что такое PECS?** — Producer Extends, Consumer Super; правило для wildcard’ов. 
5. **Что такое capture conversion?** — механизм компилятора, который «ловит» wildcard в конкретный временный тип при проверке типов/вызове generic helper’ов.
6. **Что такое bridge method?** — synthetic метод, генерируемый компилятором из-за erasure для корректного overriding/совместимости.

---

# 16) Примеры «хитрых» задач с объяснениями
A) Почему этот код не компилируется, и как исправить?

```java
import java.util.*;
public class Test {
    public static void addToList(List<Object> list) {
        list.add("string");
    }
    public static void main(String[] args) {
        List<String> ls = new ArrayList<>();
        // addToList(ls); // ошибка: List<String> не совместим с List<Object>
    }
}
```
Объяснение: `List<String>` не является `List<Object>`. Решение: сделать метод generic: `public static <T> void addToList(List<? super T> list, T value)` или `List<Object>` заменить на `List<? super String>`.

B) Tricky: `Collections.copy(dest, src)` сигнатура и почему она такая:
`public static <T> void copy(List<? super T> dest, List<? extends T> src)` — чтобы src был **producer** (`? extends T`) и dest был **consumer** (`? super T`), таким образом можно копировать List<Integer> -> List<Number> и т.п

---

# 17) Полезные практические рекомендации для senior-разработчика
- Избегайте raw types — они скрывают ошибки и создают предупреждения.  
- Не пытайтесь «побороть» erasure — лучше проектировать API так, чтобы runtime-type не был нужен; если нужен — используйте `Class<T>` или `TypeToken`.  
- Будьте аккуратны с `@SafeVarargs` — аннотация снимает предупреждения, но ответственность за безопасность остаётся за вами.
- При написании библиотек документируйте, где вы используете `? extends`/`? super` — это делает контракт понятным пользователям.  
- На интервью: давайте примеры кода и объяснения про erasure, bridge methods, PECS, heap pollution и capture conversion — эти темы почти гарантированно всплывут на senior уровне.

---

# 18) Ещё более детальные примеры с комментариями (длинный фрагмент)
Ниже — комплект примеров с комментариями «почти к каждой строке», как вы просили. Это более развёрнутый набор, охватывающий PECS, capture, heap pollution, bridge method scenario, и рефлексию.

```java
import java.lang.reflect.*;
import java.util.*;

// Demo-класс с множеством примеров
public class GenericsDeepDive {

    // 1) Generic method с bounded типом и пример использования
    public static <T extends Comparable<T>> T max(T a, T b) {
        // используем метод compareTo, безопасно, потому что T extends Comparable<T>
        return a.compareTo(b) >= 0 ? a : b; // возвращаем больший из двух
    }

    // 2) Пример capture conversion: публичный метод принимает List<?>
    public static void reverseList(List<?> list) {
        // делегируем в helper, который имеет параметризованный тип
        reverseHelper(list); // компилятор "поймает" wildcard и подставит конкретный тип
    }

    // helper с generic-параметром T — здесь происходит capture conversion
    private static <T> void reverseHelper(List<T> list) {
        // классическая реализация разворота списка
        for (int i = 0, j = list.size() - 1; i < j; i++, j--) {
            T tmp = list.get(i);      // читаем элемент как T
            list.set(i, list.get(j)); // записываем элемент как T
            list.set(j, tmp);         // записываем элемент как T
        }
    }

    // 3) Пример heap pollution с varargs (плохо — демонстрация опасности)
    @SafeVarargs
    public static void unsafeVarargs(List<String>... stringLists) {
        Object[] array = stringLists;         // varargs -> массив, тип Object[]
        array[0] = Arrays.asList(42);         // записываем List<Integer> — heap pollution!
        // теперь stringLists[0].get(0) ожидается как String, но там Integer -> ClassCastException
        String s = stringLists[0].get(0);     // ClassCastException здесь
        System.out.println(s);
    }

    // 4) Пример bridge methods (через наследование)
    static class Base<T> {
        public T work(T t) { return t; } // generic метод
    }

    static class Derived extends Base<String> {
        // этот метод фактически реализует Base<String>.work(String)
        public String work(String s) { return s.toUpperCase(); }

        // компилятор сгенерирует bridge:
        // public Object work(Object o) { return work((String)o); }
        // чтобы бинарно перекрывать Base.work после стирания типов.
    }

    // 5) Пример использования рефлексии для получения параметров поля
    static class Holder { List<String> strings; } // поле с generic

    public static void reflectExample() throws Exception {
        Field f = Holder.class.getDeclaredField("strings"); // получаем поле
        Type t = f.getGenericType();                        // получаем generic-тип
        if (t instanceof ParameterizedType) {
            ParameterizedType pt = (ParameterizedType) t;   // приводим к ParameterizedType
            System.out.println("Raw type: " + pt.getRawType()); // например, interface java.util.List
            System.out.println("Type args: " + Arrays.toString(pt.getActualTypeArguments())); // [class java.lang.String]
        }
    }

    public static void main(String[] args) throws Exception {
        // max: примеры
        System.out.println(max(3, 5)); // для Integer
        System.out.println(max("a", "b")); // для String (Comparable)

        // capture и reverse
        List<Integer> li = new ArrayList<>(Arrays.asList(1,2,3));
        reverseList(li); // безопасно — capture conversion внутри

        // heap pollution demo - НЕ запускать в проде
        // unsafeVarargs(Arrays.asList("a", "b")); // потенциальный ClassCastException

        // bridge demo (отображение методов можно увидеть через методы класса)
        Derived d = new Derived();
        System.out.println(d.work("hello"));

        // reflection demo
        reflectExample();
    }
}
```

Комментарии в коде объясняют каждую критичную строку — на интервью можно пройтись по этому примеру и описать, где именно происходит опасность/польза.

---

# 19) Что ещё спросить на собесе — список «продвинутых» вопросов»
- Объясните `type erasure` и как оно связано с bridge methods. (покажите пример) — ожидают подробного объяснения.
- Что такое heap pollution и где оно может возникнуть? (varargs+generics) — желательно привести пример и решение (`@SafeVarargs`, Object[] + проверки).
- Почему `List<String>[]` нельзя создать? — объясните несовместимость массивов и generics.  
- Что такое capture conversion? Покажите пример helper’а для `List<?>`. 
- Как получить информацию о generic-типа поля или метода через reflection? — упомяните `ParameterizedType`.  
- Когда использовать `? extends`, `? super`, либо обычный `<T>`? — расскажите PECS и приведите примеры.
- В чём разница между `Class<T>` и `Type`/`ParameterizedType`? — объясните когда какой использовать.  
- Как generics влияют на сериализацию? (могут быть сюрпризы, особенно с raw types и сериализацией дженериков)

---

# 20) Резюме (ключевые тезисы для собеса)
- Java generics — **compile-time** типовая система; в рантайме большинство информации о параметрах **потеряно** (type erasure).
- PECS (`? extends` vs `? super`) — фундаментальная рекомендация при проектировании API.
- Capture conversion — используйте helper-методы, если нужно изменить `List<?>`. 
- Heap pollution и varargs — большой источник ошибок; `@SafeVarargs` не вылечит неправильную логику.
- Bridge methods — автоматический результат erasure при переопределении, объясните и покажите пример.

---

Если хочешь, могу:
- подготовить **список конкретных вопросов** по темам (с ожидаемыми ответами и короткими подсказками) для тренировки перед интервью;  
- или сделать **скрипт/тест** из N вопросов с оценкой ответов и обратной связью;  
- или **расширить** любой раздел выше — например, подробный разбор bridge methods, с выходом байткода (`javap -c`) и объяснением synthetic-методов.

# Type Erasure в Java

**Type Erasure** (стирание типов) — это механизм, используемый компилятором Java для реализации **generics**.

Java generics существуют **только на уровне компиляции**, и **во время выполнения информация о типах стирается**. Это позволяет сохранять обратную совместимость с кодом до Java 5.

---

## 1. Что происходит при Type Erasure

1. Компилятор проверяет **типовую безопасность** на этапе компиляции.
2. После компиляции компилятор **удаляет параметризованные типы**, оставляя «сырые» типы (raw types).
3. Компилятор добавляет **cast’ы**, если это необходимо.

**Пример:**

```java
List<String> list = new ArrayList<>();
list.add("Hello");
String s = list.get(0);
```

После компиляции (Type Erasure) код превращается примерно в:

```java
List list = new ArrayList();
list.add("Hello");
String s = (String) list.get(0);
```

* `<String>` исчезает.
* Добавляется явное приведение типа `(String)`.

---

## 2. Ограничения Type Erasure

1. **Нельзя использовать generic type для instanceof**

```java
if (list instanceof List<String>) { } // Ошибка компиляции
```

2. **Нельзя создавать generic массивы**

```java
List<String>[] array = new List<String>[10]; // Ошибка
```

3. **Нельзя использовать типы-параметры в static контексте**

```java
class MyClass<T> {
    static T value; // Ошибка
}
```

4. **Нельзя получить класс параметризованного типа напрямую**

```java
Class<T> clazz = T.class; // Ошибка
```

---

## 3. Типовые аргументы и наследование

Если generic класс имеет **ограничение типа** (`extends`), то при стирании типов тип заменяется на **ограничение**:

```java
class MyClass<T extends Number> {
    T value;
}
```

После Type Erasure:

```java
class MyClass {
    Number value;
}
```

* Если ограничение отсутствует (`<T>`), тип заменяется на `Object`.

---

## 4. Зачем нужен Type Erasure

* Обеспечивает **обратную совместимость** с Java до 5.
* Позволяет **одинаково использовать старые API**, которые не поддерживают generics.
* Позволяет компилировать generics в байт-код без добавления runtime информации о типах.

---

## 5. Итог

| Понятие      | Что происходит                                                                               |
| ------------ | -------------------------------------------------------------------------------------------- |
| Type Erasure | Стирание generic-типа на этапе компиляции                                                    |
| Raw Type     | Тип без generic-параметра после стирания                                                     |
| Cast         | Добавляется компилятором при необходимости                                                   |
| Ограничения  | Нельзя использовать instanceof, создавать массивы, использовать в static, получить `T.class` |

---


[к оглавлению](#java-core)

## Что такое _«интернационализация»_, _«локализация»_?
__Интернационализация (internationalization)__ - способ создания приложений, при котором их можно легко адаптировать для разных аудиторий, говорящих на разных языках.

__Локализация (localization)__ -  адаптация интерфейса приложения под несколько языков. Добавление нового языка может внести определенные сложности в локализацию интерфейса.

[к оглавлению](#java-core)

Отлично — сделал подробный, структурированный разбор **сборщиков мусора (Garbage Collectors, GC)** в Java, написанный простым языком, с примерами, текстовыми диаграммами и рекомендациями для собеседования. Я искал информацию в официальных и авторитетных источниках (Oracle/OpenJDK, статьи и обзоры), ссылки на ключевые факты привожу после соответствующих блоков.

---
# Задачи по Wildcards и PECS (Producer Extends, Consumer Super)
Ниже 5 задач для собеседования на тему **wildcards** и **PECS** (Producer Extends, Consumer Super). Задачи рассчитаны на senior-уровень: в каждой — фрагмент кода или сценарий для анализа, а после них — подробный разбор и окончательный ответ.

---

## Задача 1 — Что скомпилируется, что упадёт, что вернёт?
Рассмотрите фрагмент кода и укажите для каждой помеченной строки: **(A)** компилируется? **(B)** если компилируется — будет ли выполняться без исключений? **(C)** если выполняется — что напечатает / вернёт?

```java
import java.util.*;

public class Test1 {
    public static void main(String[] args) {
        List<Integer> ints = new ArrayList<>();
        ints.add(1);

        List<? extends Number> ext = ints;
        List<? super Integer> sup = new ArrayList<Number>();

        // 1
        Number n = ext.get(0);

        // 2
        ext.add(2); // line 2

        // 3
        Object o = sup.get(0);

        // 4
        sup.add(2); // line 4

        // 5
        List<?> any = ints;
        any.add(null); // line 5

        // 6
        any.add("str"); // line 6
    }
}
```

### Ответ и объяснение

- **Строка 1 (`Number n = ext.get(0);`)**
  - (A) **Компилируется.**
  - (B) **Выполнится без исключений.**
  - (C) `n` получит `Integer` как `Number` (значение `1`).

  Обоснование: `List<? extends Number>` гарантирует, что элементы являются `Number` (или подклассом), поэтому чтение в `Number` безопасно.

- **Строка 2 (`ext.add(2);`)**
  - (A) **Не скомпилируется.**
  - Причина: при `List<? extends Number>` нельзя добавлять элементы (кроме `null`), потому что реальный тип элемента может быть более узким (например `List<Integer>`), и добавление другого подтипа может нарушить реальный тип. Компилятор запрещает.

- **Строка 3 (`Object o = sup.get(0);`)**
  - (A) **Компилируется.**
  - (B) **Выполнится, но тип возвращаемого — `Object`.**
  - (C) `o` будет `Integer` упакованным как `Object` (если в списке есть значение).

  Обоснование: `List<? super Integer>` при чтении даёт только `Object`, так как конкретный элемент может быть суперклассом `Integer` (например `List<Object>`), компилятор даёт `Object`.

- **Строка 4 (`sup.add(2);`)**
  - (A) **Компилируется и выполнится без исключений.**

  Обоснование: `? super Integer` гарантирует, что список принимает `Integer` и его подклассы — безопасно добавлять `Integer`.

- **Строка 5 (`any.add(null);`)**
  - (A) **Компилируется и выполнится.** `null` — единственный безопасный элемент, который можно добавить в `List<?>`.
  - (C) В список будет добавлен `null`.

- **Строка 6 (`any.add("str");`)**
  - (A) **Не скомпилируется.** `List<?>` — неизвестен конкретный тип, кроме `null` ничего добавлять нельзя.

---

## Задача 2 — Реализовать `copyAll` по PECS
Напишите метод `copyAll`, который копирует элементы из источника в приёмник. Подпись должна быть максимально гибкой (работать для подтипов/супертипов). Объясните выбор сигнатуры (PECS) и почему она безопасна.

### Ожидаемая реализация и объяснение

Правильная сигнатура:

```java
public static <T> void copyAll(List<? super T> dest, List<? extends T> src) {
    for (T e : src) {
        dest.add(e);
    }
}
```

**Почему так (PECS):**
- `src` — *producer* (производит элементы), поэтому ограничиваем сверху: `? extends T` — можем безопасно читать `T` из `src`.
- `dest` — *consumer* (потребляет элементы), поэтому ограничиваем снизу: `? super T` — можем безопасно добавлять `T` в `dest`.
- Это позволяет копировать, например, `List<Integer>` в `List<Number>`: `copyAll(NumberList, IntegerList)` — `T = Integer`.

**Пример использования:**

```java
List<Integer> ints = Arrays.asList(1,2,3);
List<Number> nums = new ArrayList<>();
copyAll(nums, ints); // OK
```

Если бы мы написали `List<T> dest, List<T> src`, сигнатуры были бы менее гибкими — нельзя копировать `List<Integer>` в `List<Number>`.

---

## Задача 3 — Override и generics (ловушка с type erasure)
Есть класс с методом:

```java
class Parent {
    public void handle(List<String> list) { /*...*/ }
}
```

Вариант A:

```java
class ChildA extends Parent {
    @Override
    public void handle(List<Object> list) { /*...*/ }
}
```

Вариант B:

```java
class ChildB extends Parent {
    @Override
    public void handle(List<?> list) { /*...*/ }
}
```

Вариант C:

```java
class ChildC extends Parent {
    @Override
    public <T> void handle(List<T> list) { /*...*/ }
}
```

**Вопрос:** какие из вариантов скомпилируются и будут ли они считаться переопределением метода `Parent.handle`? Объясните.

### Ответ и подробности

- **ChildA (`List<Object>`)**
  - **Не скомпилируется как `@Override`.**  
  - Объяснение: `List<String>` и `List<Object>` после *type erasure* оба становятся `List`. Попытка объявить метод с другой generic-арностью приведёт к конфликту сигнатур (name clash) — компилятор не позволит такое переопределение. Это **не** переопределение.

- **ChildB (`List<?>`)**
  - **Скомпилируется и будет переопределением.**
  - Обоснование: `List<?>` после type erasure превращается в `List`, сигнатуры совпадают, и компилятор позволяет переопределение. Семантически `List<?>` — более общий тип, но это корректное переопределение.

- **ChildC (`<T> void handle(List<T>)`)**
  - **Скомпилируется и будет переопределением.**
  - Обоснование: обобщённый метод с параметром `<T>` после erasure превращается в `void handle(List list)` — совпадает с родительской сигнатурой. Это считается корректным переопределением. Однако следует быть внимательным к использованию generics внутри метода — они не влияют на рантайм-сигнатуру.

> **Совет:** Всегда используйте `@Override` — это поможет поймать ошибки переопределения на этапе компиляции.

---

## Задача 4 — Захват wildcard (capture) и как безопасно работать с `?`
У вас есть метод, который должен добавить заданное значение в переданный список чисел. Почему следующий код не компилируется, и как его исправить?

```java
void addNumber(List<? extends Number> list, Number value) {
    list.add(value); // компиляторная ошибка
}
```

Предложите корректный вариант реализации, который *позволяет* добавлять число в список при условии, что исходный список типизирован конкретно (например, `List<Integer>`), или объясните, почему это невозможно и какие альтернативы есть.

### Ответ и объяснение

- **Почему не компилируется:** `List<? extends Number>` означает, что список содержит некоторый неизвестный конкретный подтип `X` числа (например `Integer` или `Double`). Компилятор не позволяет `list.add(value)`, потому что `value` имеет тип `Number` — он может быть `Double`, и если реальный список — `List<Integer>`, добавление `Double` нарушит типовую безопасность. Поэтому добавление запрещено.

- **Что можно сделать:**

  1. **Использовать `? super` (если вы хотите добавлять конкретный тип):**

     ```java
     void addInteger(List<? super Integer> list, Integer value) {
         list.add(value); // OK
     }
     ```

     Тут вы добавляете `Integer` в список, который гарантированно принимает `Integer` или его суперкласс (например `List<Number>` или `List<Object>`).

  2. **Сделать метод обобщённым и принимать конкретный List<T>:**

     ```java
     public static <T extends Number> void addNumberExact(List<T> list, T value) {
         list.add(value); // OK: value имеет точно тот же T
     }

     // Вызов:
     List<Integer> ints = new ArrayList<>();
     addNumberExact(ints, 5); // OK
     ```

     Недостаток: у вас должен *иметь* конкретный `List<T>`. Если у вас есть `List<? extends Number>` — вы не можете напрямую передать его в `addNumberExact`.

  3. **Создать новый список нужного типа и вернуть/заменить:**

     ```java
     List<Number> copyAndAdd(List<? extends Number> list, Number value) {
         List<Number> result = new ArrayList<>(list);
         result.add(value);
         return result;
     }
     ```

     Это безопасно — вы создаёте `List<Number>`, куда можно добавлять любые `Number`.

- **Вывод:** Вы **не можете** добавить `Number` в `List<? extends Number>`. Используйте `? super` чтобы принимать значения или делайте метод с конкретным параметром `<T>`.

---

## Задача 5 — Сравнить массивы и generics: runtime vs compile-time
Поясните разницу в поведении при следующем коде: один использует массивы, другой — generics. Что произойдёт при выполнении и почему?

**Код A (массивы):**
```java
Object[] arr = new String[1];
arr[0] = Integer.valueOf(1); // Что произойдёт?
```

**Код B (generics):**
```java
List<String> strings = new ArrayList<>();
List<Object> objs = (List<Object>)(List<?>) strings; // небезопасное приведение
objs.add(Integer.valueOf(1)); // Что произойдёт — compile/runtimes?
```

### Объяснение и ответ

**Код A (массивы):**
- **Компилируется.**
- **Во время выполнения** при выполнении `arr[0] = Integer.valueOf(1);` JVM проверит реальный тип массива (он создан как `new String[1]`) и бросит `ArrayStoreException` — потому что нельзя положить `Integer` в `String[]`.
- Причина: массивы в Java — **ковариантны** (`String[]` является подтипом `Object[]`), но JVM обеспечивает runtime-проверку вставляемых элементов.

**Код B (generics):**
- Приведение `(List<Object>)(List<?>) strings` — это unchecked cast, компилируется с предупреждением.
- `objs.add(Integer.valueOf(1));` — компилируется (тип `objs` это `List<Object>`), и **во время выполнения** добавление тоже произойдёт (никаких ArrayStoreException), потому что generics реализованы через *type erasure* — на рантайме список остаётся обычным `ArrayList`.
- В результате логическая инвариантность `List<String>` нарушается: в `strings` теперь может оказаться `Integer`. При попытке получить элемент как `String` произойдёт `ClassCastException` у потребителя.
- **Отличие:** массивы дают защиту во время выполнения (ArrayStoreException), generics — защиту во время компиляции (type safety). Небезопасные unchecked-приведения снимают компиляторную защиту и могут привести к `ClassCastException` в другом месте кода.

**Рекомендация:** избегайте unchecked-cast; используйте `List<?>`, `? extends`, `? super` правильно. Для массивов соблюдайте осторожность с ковариантностью.

---

### Дополнительно
Если хотите, могу:
- Добавить JUnit-тесты, демонстрирующие поведение каждого примера.
- Сгенерировать pdf/ePub со всеми задачами.
- Перенести этот markdown в репозиторий и добавить CI-скрипты для тестов.



# 1. Кратко: зачем нужен GC в Java
Java — язык с автоматическим управлением памятью. Основная задача GC — находить в куче (heap) объекты, до которых больше нельзя добраться из «корней» (стеков, статических полей и т.п.), и освобождать занимаемую ими память. Это устраняет необходимость ручного `free`/`delete`, снижает количество ошибок (утечки памяти всё ещё возможны, но не через забытое освобождение) и упрощает разработку.

---

# 2. Области памяти в JVM и как они связаны с GC

Ниже — упрощённая схема памяти JVM и её значение для GC.

```
+------------------------------------------------+
| JVM Process (native memory)                    |
|  +------------------------------------------+  |
|  | Java Heap                                |  |
|  |  +-------------+  +--------------------+ |  |
|  |  | Young Gen   |  | Old/Tenured Gen     | |  |
|  |  | Eden + S0/S1 |  | (long-lived objects)| |  |
|  |  +-------------+  +--------------------+ |  |
|  +------------------------------------------+  |
|  | Metaspace (class metadata)               |  |
|  | Code Cache (JIT compiled code)           |  |
|  +------------------------------------------+  |
+------------------------------------------------+
Each Java thread: Stack (local vars, frames) — not GC-managed for object lifetime (references on stack are GC roots).
```

Коротко про основные области:

- **Heap (куча)** — место для всех объектов; именно её очищает GC. Куча обычно делится на *young* (молодое), *old/tenured* (старое).  
- **Young generation** — делится на *Eden* и два *Survivor* (S0/S1). Новые объекты сначала попадают в Eden. Если объект переживает несколько сборок — он «переселяется» в survivor, затем в tenured. Это использует **генерационную гипотезу**: большинство объектов короткоживущие.  
- **Old/Tenured** — для долгоживущих объектов; сборки старого поколения обычно дороже (больше pause/time).  
- **Metaspace** (ранее PermGen) — классная метаинформация (class metadata), отделена от heap и освобождается/растёт иначе.  
- **Stack (каждый поток)** — хранит ссылки и примитивы; стек не «собирается», но ссылки на объекты со стека являются GC-roots.  

**Почему это важно для GC:** разные алгоритмы оптимизированы под поведение young/old поколений (например, быстрые minor GC для young, более тяжёлые full/major GC для old). Понимание где хранятся объекты помогает в настройке (например, `-Xmx`, `-Xms`, `-XX:MaxMetaspaceSize`) и при диагностике утечек.

---

# 3. Основные принципы работы GC (простыми словами)

1. **Roots (корни)** — набор ссылок (стековые переменные, статические поля, JNI) откуда начинается обход.  
2. **Mark (маркировка)** — GC помечает все достижимые объекты из корней.  
3. **Sweep (сбор)** — освобождает пространство, занятого немаркированными (недостижимыми) объектами.  
4. **Compact (сжатие)** — при необходимости уплотняет кучу, чтобы устранить фрагментацию (перемещает живые объекты).  
5. **Copying** — копирует живые объекты в новую область, оставляя остальное свободным (часто используется в young).  

Эти шаги комбинируются по-разному в разных алгоритмах (см. ниже).

---

# 4. Ключевые метрики GC (что на собеседовании спрашивают чаще всего)
- **Throughput** — доля времени приложения в выполнении (не в GC).  
- **Pause time / latency** — длительность «stop-the-world» пауз (важно для низколатентных систем).  
- **Footprint** — объём памяти, который занимает приложение (и требования GC к headroom).  
- **CPU overhead** — сколько CPU тратится на GC (concurrent collectors используют CPU, чтобы снизить паузы).  
Эти метрики часто взаимно конфликируют: меньше пауз → выше CPU/меньше throughput; максимальный throughput → большие паузы.

---

# 5. Основные виды (семейства) GC в HotSpot/OpenJDK — с простыми примерами и когда выбирать

> Примечание: с Java 9+ **G1** стал дефолтным, далее появились/развились **ZGC** и **Shenandoah** (low-pause). Также есть **Serial**, **Parallel**, **CMS** (устаревший/удален в новых JDK) и экспериментальные (Epsilon).

### 5.1 Serial GC (`-XX:+UseSerialGC`)
- **Как работает:** однопоточная, stop-the-world для всех сборок. Простая copy/mark-sweep для небольших heaps.  
- **Плюсы:** простота, низкие накладные расходы на маленьких машинах.  
- **Минусы:** большие паузы при росте heap, не подходит для серверных приложений.  
- **Когда:** маленькие приложения, тесты, встраиваемые системы с 1-2 CPU.

### 5.2 ParallelGC / Throughput (`-XX:+UseParallelGC` / `-XX:+UseParallelOldGC`)
- **Как:** многопоточная сборка, оптимизирована для throughput. Молодое поколение собирается параллельно.  
- **Плюсы:** высокая пропускная способность (полезно для batch-работ).  
- **Минусы:** паузы stop-the-world всё ещё могут быть долгие.  
- **Когда:** CPU-bound batch jobs, вычислительные задачи, где паузы допустимы.

### 5.3 CMS (Concurrent Mark-Sweep) — исторический (`-XX:+UseConcMarkSweepGC`)
- **Как:** concurrent mark + concurrent sweep; минимизирует паузы, не очень хорошо сжимает heap, приводит к фрагментации.  
- **Плюсы:** меньшие паузы чем Parallel в своё время.  
- **Минусы:** сложности с фрагментацией; deprecated/removed в новых JDK — заменён G1.  
- **Когда:** раньше для low-latency серверов; сейчас лучше G1/ZGC/Shenandoah.

### 5.4 G1 (Garbage-First) — `-XX:+UseG1GC` (дефолт с Java 9)
- **Как:** куча разбита на регионы. Делает *young* и *mixed* сборки; старается «сначала» очистить регионы с наибольшим количеством мусора (garbage-first). Поддерживает concurrent marking и эвакуацию регионов; компромисс между паузами и throughput.  
- **Плюсы:** предсказуемые паузы, хорош для больших heap, дефолтный и хорошо поддерживаемый.  
- **Минусы:** может иметь больше накладных расходов, чем Parallel в чистом throughput-режиме; сложнее тюнинг.  
- **Когда:** общие серверные приложения, где важны управляемые паузы.

### 5.5 ZGC (`-XX:+UseZGC`)
- **Как:** низколатентный, масштабируемый, выполняет большую часть работы одновременно с приложением; минимальные паузы (миллисекунды или меньше) даже для больших heap. В JDK 11 — экспериментально, в новых релизах — стабилен; с JDK21 появился генерационный режим.  
- **Плюсы:** очень низкие pause-times, подходит для огромных heap и latency-sensitive систем.  
- **Минусы:** может требовать больше CPU и памяти; раньше был экспериментален (проверяйте версию JDK).  
- **Когда:** приложения с жёсткими SLAs по латентности и большие кучи.

### 5.6 Shenandoah (`-XX:+UseShenandoahGC`)
- **Как:** low-pause GC от Red Hat / OpenJDK; выполняет компактацию и большую часть работы concurrently; как и ZGC ориентирован на низкие паузы независимо от размера heap.  
- **Плюсы:** низкие pause-times, конкурентная компактация.  
- **Минусы:** использует дополнительные ресурсы; настройка и поведение могут отличаться от ZGC.  
- **Когда:** альтернативная low-latency опция, особенно в дистрибутивах OpenJDK/RedHat.

### 5.7 Epsilon GC (`-XX:+UseEpsilonGC`)
- **Как:** «do-nothing» GC — не собирает объекты; используется для тестирования или бенчмарков.  
- **Когда:** оценивать поведение приложения без GC, профилирование аллокаций.

---

# 6. Алгоритмы/приёмы, которые часто спрашивают на собеседовании (с примерами)

### 6.1 Генерационная гипотеза
«Большинство объектов умирает молодыми» — поэтому young GC (minor GC) делается часто и быстро (copying), а старое поколение — реже. Это основной дизайн большинства Java GC.

### 6.2 Copying vs Mark-Sweep vs Mark-Compact
- **Copying (Eden → Survivor)**: быстр, уплотняет память автоматически, но требует дополнительного пространства.  
- **Mark-Sweep**: пометить, затем очистить — дешёво по памяти, но оставляет фрагментацию.  
- **Mark-Compact**: пометка + уплотнение — устраняет фрагментацию, но требует движения объектов и дополнительных усилий.

### 6.3 Card tables и Remembered Sets
Для того, чтобы быстро узнать, какие старые области ссылаются на молодые (нужна при minor GC), JVM использует *card table* и *remembered sets* — механизмы для отслеживания межпоколенных ссылок.

### 6.4 Weak/Soft/Phantom references
- **SoftReference** — объекты, которые можно хранить до тех пор, пока есть свободная память (подходят для кешей).  
- **WeakReference** — объект можно убрать при следующем GC, даже если он только в WeakRef.  
- **PhantomReference** — для post-mortem действий, используется вместе с ReferenceQueue.  
На собеседовании важно знать различия и примеры использования.

---

# 7. Практическая диагностика и тюнинг — команды и флаги

### Базовые флаги (пример)
- `-Xms<size>` — начальный heap.  
- `-Xmx<size>` — максимальный heap.  
- `-XX:+UseG1GC` — включить G1 (в современных JDK дефолт).  
- `-XX:+UseZGC` — включить ZGC.  
- `-XX:MaxGCPauseMillis=<N>` — цель паузы (G1 использует как hint).  
- Логирование GC (JDK 9+): `-Xlog:gc*,gc+age=trace:file=gc.log:time,uptime,level` — сбор подробного лога.  
Пример запуска с G1 и логом:
```
java -Xms2g -Xmx4g -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -Xlog:gc*:/var/log/gc.log:time,level
```
Эти флаги и формат логов — важная тема для интервью.

### Инструменты диагностики
- `jmap` (heap dump), `jcmd GC.heap_info`, `jcmd GC.run`, `jstat` (статистика GC), VisualVM, Java Mission Control (JMC), GC log analyzers (GCViewer, gceasy).  
На собеседовании полезно уметь объяснить, какие инструменты брать при долгих паузах (сначала GC логи → heap dump → анализ retention paths → fix).

---

# 8. Примеры ситуаций и рекомендации (интервью-кейсы)

### Ситуация A — веб-сервис с жёстким SLA по задержке
- Требования: минимальные паузы.  
- Рекомендация: ZGC или Shenandoah (если доступны на выбранном дистрибутиве/JDK). Тесты: прогонять нагрузку с realistic heap, смотреть p99/p999 latencies и profiling.

### Ситуация B — batch-обработка, максимальная пропускная способность
- Рекомендация: ParallelGC (Throughput collector), возможно ParallelOld. Можно пожертвовать паузами ради скорости.

### Ситуация C — приложение с умеренным heap и желанием «не копаться в тюнинге»
- Рекомендация: оставить G1 (дефолт), настроить `-Xmx` и `-XX:MaxGCPauseMillis` как hint, собрать логи и смотреть.

---

# 9. Частые ошибки и «подводные камни”
- **Доверять дефолтам вслепую** — дефолтный GC хороший, но под конкретную нагрузку может не подходить; всегда проверяйте.  
- **Пытаться решать утечки настройкой GC** — GC не решит программную утечку (неправильные коллекции/кеши/static-lists). Нужно искать удерживающие ссылки.  
- **Неправильный размер heap** — слишком маленький → частые GC; слишком большой → долгие full GC/большие требования к памяти и времени на инициализацию.  
- **Ожидать одинакового поведения на разных JDK/дистрибутах** — ZGC/Shenandoah поддерживаются не во всех билдах одинаково; версии имеют различия (см. JEPs).

---

# 10. Небольшая текстовая диаграмма жизненного цикла объекта (простая)

```
[Create] --> Eden
  if Minor GC and object survives --> Survivor (S0/S1)
    if survives N раз (tenuring threshold) --> Old/Tenured
      if Old GC (full/mixed) determines unreachable --> reclamation (mark/sweep/compact)
```

---

# 11. Типичные вопросы на собеседовании + краткие хорошие ответы (готово к проговариванию)

1. **Что такое поколенческая сборка и почему она используется?**  
   Кратко: делит кучу на молодое и старое поколения, потому что большинство объектов умирают молодыми — это ускоряет сборку (часто быстрый copying в young).

2. **Чем G1 лучше CMS?**  
   G1 использует регионы, concurrent marking и эвакуацию регионов; он был создан как замена CMS с целью более предсказуемых пауз и лучшей работы с большими heap.

3. **Когда стоит выбрать ZGC или Shenandoah?**  
   Когда критично минимизировать паузы (низкая латентность) и вы готовы к чуть большему потреблению CPU/памяти; также когда приложение имеет очень большой heap. Тестируйте в целевой JDK.

4. **Что такое SoftReference?**  
   Сильная, слабая и фантомные — различаются тем, при каких условиях сборщик может их очистить; SoftReference подходит для кеширования, объекты очищаются при нехватке памяти.

5. **Как анализировать long GC pauses?**  
   Шаги: включить подробный GC лог → проанализировать какие сборки (young/old/full) дают паузы → собрать heap-dump в момент проблемы → найти retention paths → исправить код/настроить heap/сменить GC.

---

# Подробный принцип работы G1 Garbage Collector

## 1. Основные идеи G1
G1 создан для:
- **низких пауз** (predictable low pause),
- **работы на больших кучах** (десятки и сотни гигабайт),
- **равномерного распределения работы** (no monolithic compaction, а эвакуация кусками).

Ключевые особенности:
- Куча делится на **регионы** фиксированного размера (обычно 1–32 МБ, настраивается `-XX:G1HeapRegionSize`).
- Нет строгого деления «Eden/Survivor/Old» как contiguous сегментов. Вместо этого регионы логически маркируются: одни регионы используются как Eden, другие как Survivor, другие как Old.
- Сборка идёт по принципу «сначала собрать регионы с наибольшим количеством мусора» (отсюда Garbage-First).
- Умеет **одновременно маркировать и собирать** (concurrent marking + evacuation).
- Делает **компактацию** всегда (живые объекты перемещаются в другие регионы). Это предотвращает фрагментацию (проблему CMS).

---

## 2. Жизненный цикл объекта в G1
1. Новый объект аллоцируется в Eden-регион.
2. При переполнении Eden — запускается **Young GC** (эвакуация живых объектов из Eden и части Survivor в новые Survivor или Old).
3. Объекты, пережившие несколько Young GC → продвигаются в Old-регионы.
4. Когда Old-регионы начинают заполняться, G1 запускает **Concurrent Mark Cycle**:
   - маркирует живые объекты по всей куче,
   - вычисляет, сколько мусора в каждом регионе.
5. Затем G1 планирует **Mixed GC**: собирает не только Eden/Survivor, но и часть Old-регионов с наибольшим количеством мусора.

---

## 3. Алгоритмы внутри G1
- **Remembered Sets (RSet):** G1 хранит информацию о кросс-ссылках между регионами (например, объект в Old ссылается на объект в Eden). Это позволяет при GC не сканировать всю кучу, а только нужные регионы.
- **Evacuation:** живые объекты копируются (эвакуируются) в другие регионы. При этом:
  - Eden → Survivor/Old,
  - Survivor → Survivor/Old,
  - Old (при Mixed GC) → новые Old-регионы.
- **Compaction встроен в эвакуацию:** так как объекты перемещаются, память не фрагментируется.
- **Concurrent marking:** G1 умеет параллельно с приложением сканировать кучу и строить карту живых объектов (Liveness map).

---

## 4. Типы фаз в G1
1. **Young GC (Minor GC):** эвакуация только молодых регионов (Eden + Survivor).
2. **Concurrent Marking:** асинхронная фаза, пока приложение работает → помечаются живые объекты в Old-регионах.
3. **Remark (STW):** финализация маркировки, чтобы уточнить, какие объекты ещё живы.
4. **Cleanup:** обновление статистики по регионам, определение кандидатов на сборку.
5. **Mixed GC:** сборка Eden/Survivor + части Old-регионов с наибольшим количеством мусора.
6. При нехватке памяти → может случиться **Full GC** (но G1 старается этого избегать).

---

## 5. Диаграмма последовательности работы G1

Текстовая последовательность (упрощённая):

```
[Аллокация объекта] -> Eden-регион
   |
   V
[Eden заполнен] -> Запуск Young GC (STW)
   |
   |__ Живые объекты из Eden -> Survivor/Old
   |__ Живые из Survivor -> новый Survivor/Old
   |
   V
[Old растёт]
   |
   V
[Запуск Concurrent Marking (асинхронно)]
   |-- Сканирование кучи (живые/мертвые регионы)
   |-- Построение карты "liveness" по регионам
   |
   V
[Remark STW] -> завершение маркировки
   |
   V
[Cleanup] -> выбор регионов с наибольшим количеством мусора
   |
   V
[Mixed GC (STW)]
   |-- Эвакуация Eden + Survivor
   |-- Эвакуация части Old-регионов
   |-- Перемещение живых в новые регионы (компактация встроена)
   |
   V
[Продолжение работы приложения]
```

---

## 6. Как G1 борется с Stop-the-World
- **Young GC и Mixed GC всё ещё STW**, но они ограничены по времени (цель: уложиться в target pause time).
- G1 использует **predictive model**: при планировании Mixed GC выбирает *только столько регионов*, сколько можно собрать за заданное время (например, `-XX:MaxGCPauseMillis=200`).
- Благодаря этому паузы становятся предсказуемыми, а не «Full GC на несколько секунд».

---

## 7. Плюсы и минусы G1
✅ Плюсы:
- Работает на больших кучах без долгих Full GC.
- Минимизирует фрагментацию.
- Предсказуемые паузы (pause-time goal).
- Автоматически балансирует Eden/Survivor/Old.

❌ Минусы:
- Более сложный алгоритм → больше накладные расходы (CPU).
- Humongous-объекты (больше половины региона) могут вызвать фрагментацию, т.к. их сложно перемещать.
- Может всё равно попасть в Full GC при нехватке памяти.


Если хочешь, могу прямо сейчас:
- подготовить **короткие ответы** (bullet-point) на 10 типичных вопросов для резюме/карты с ответами под собеседование (готовые «речь-ответы»);  
- или **развернуть** любой раздел (например, детально про G1 internals, про настройку для микросервисов, или пример разбора GC логов с реальным логом).
- 
## Иммутабельность 
(неизменяемость) класса в Java означает, что объекты такого класса нельзя изменить после создания. Все поля фиксируются при инициализации, и больше не меняются.

Что это даёт

Потокобезопасность без синхронизации
Иммутабельные объекты можно безопасно использовать в многопоточной среде без synchronized, потому что их состояние не меняется. Пример — String, Integer, LocalDate.

Упрощение кода и reasoning
Когда знаешь, что объект не изменится, проще рассуждать о логике программы, отлаживать и тестировать.

Кэширование и повторное использование
Можно смело кэшировать и переиспользовать один и тот же объект (например, Integer.valueOf(42) или строковые литералы в пуле).

Безопасность
Никто не может «подсунуть» изменённое состояние через ссылку на объект. Это защищает от неожиданных сайд-эффектов.

Удобство в функциональном стиле
Иммутабельность хорошо ложится на «функциональное программирование» — вместо изменения объекта создаётся новый с изменёнными полями. Это повышает предсказуемость кода.

# Где именно хранится стек

Вне кучи (heap) — стек хранится в нативной памяти (off-heap), которую управляет операционная система при создании потока.

Для каждого потока ОС выделяет отдельный кусок памяти под его стек.

JVM лишь запрашивает у ОС стек при старте нового потока.


# 10 задач по `override` (каждая — задача, затем сразу ответ + объяснение)

Ниже — 10 нетривиальных задач для сеньор-уровня по теме переопределения в Java. После каждой задачи идёт **«Ответ и объяснение»** — без лишних отсылок, прямо к делу.

---

## Задача 1 — ковариантный тип возвращаемого значения (разрешённый кейс)
```java
class Parent {
    public Number get() { return 3; }
}

class Child extends Parent {
    @Override
    public Integer get() { return 42; } // A
}

// В main:
Parent p = new Child();
Number n = p.get();
System.out.println(n);
Integer i = ((Child)p).get();
System.out.println(i);
```
Вопрос: скомпилируется ли код? что напечатает и почему?

### Ответ и объяснение
- Код **скомпилируется** (аннотация `@Override` корректна).
- Выведет:
  ```
  42
  42
  ```
Пояснение: Java разрешает *ковариантный* (уточнённый) возвращаемый тип при overriding — подкласс может возвращать подтип возвращаемого типа суперкласса (здесь `Integer` ⊂ `Number`). Вызов динамически направляется на `Child.get()`. Для простого случая ковариантности (без generics/стирания типов) компилятор/байткод справляются без дополнительных bridge-методов. (Bridge-методы обычно появляются в связке с generics/стиранием типов — см. задачу 3.)

---

## Задача 2 — попытка **сузить** тип аргумента при переопределении
```java
class Base {
    public void process(Object o) { System.out.println("Base"); }
}

class Sub extends Base {
    @Override
    public void process(String s) { System.out.println("Sub"); } // попытка
}
```
Вопрос: скомпилируется ли `Sub`? если да/нет — что происходит при вызове `((Base)new Sub()).process("x")`?

### Ответ и объяснение
- Такой код **не скомпилируется**, потому что сигнатура метода должна совпадать по параметрам (после стирания типов). `public void process(String)` — это **другая** сигнатура, это не переопределение, а перегрузка; использование `@Override` приведёт к ошибке компиляции.
- Если убрать `@Override`, код скомпилируется, но тогда `Sub.process(String)` — перегрузка, а `Base.process(Object)` остаётся незаменённым. При вызове через `Base` ссылку будет вызван `Base.process(Object)`, а не `Sub.process(String)`.

Пояснение: Java **не** поддерживает контравариантность аргументов при переопределении — вы не можете заменить параметр на более узкий тип. Это важно: попытка «сузить» аргументы превращает метод в перегруженный, не в переопределённый, и `@Override` поймает ошибку.

---

## Задача 3 — generics + bridge-метод (классический кейс)
```java
class Holder<T> {
    public T get() { return null; }
}

class StringHolder extends Holder<String> {
    @Override
    public String get() { return "ok"; }
}
```
Вопрос: скомпилируется ли? какие методы попадут в bytecode `StringHolder` и зачем нужен bridge-метод?

### Ответ и объяснение
- Код **скомпилируется**.
- В `StringHolder` компилятор сгенерирует:
  1. `public String get()` — ваша реализация.
  2. **bridge** `public Object get()` — автоматически созданный метод, который вызывает `return get();` (или `return (Object) this.get();`) и обеспечивает бинарную совместимость со старой (стертой) сигнатурой.
- Причина: из-за стирания типов в байткоде родительский метод `Holder.get()` воспринимается как `Object get()`. Чтобы старый код, компилированный против `Holder`, корректно вызывал реализацию в `StringHolder`, нужен bridge-метод, который имеет erased-сигнатуру `Object get()` и делегирует в `String get()`.

Пояснение: bridge-методы автоматически создаются при несоответствии между compile-time типами (с generics) и runtime-сигнатурами после стирания типов.

---

## Задача 4 — конфликт из-за стирания (name clash)
```java
import java.util.List;

class Parent {
    public void set(List<String> list) { }
}

class Child extends Parent {
    // пытаемся "переопределить" для другого generic:
    public void set(List<Integer> list) { } // A
}
```
Вопрос: скомпилируется ли `Child`? почему/почему нет?

### Ответ и объяснение
- Такой код **не скомпилируется**: ошибка компиляции `name clash: set(List<String>) and set(List<Integer>) have the same erasure`.
- Пояснение: после стирания типов обе сигнатуры превращаются в `set(List)`, компилятор видит два метода с одинаковой сигнатурой в одном классе — недопустимо. Это отличается от случая с covariant return — здесь конфликт из-за different generic parameters.

Вывод: будьте внимательны с generics при попытке «переопределить» методы с разными параметризованными типами — часто получаете name-clash.

---

## Задача 5 — изменение видимости при override (widening / narrowing)
```java
class A {
    protected void step() { }
}

class B extends A {
    @Override
    public void step() { }   // OK — расширяем видимость
}

class C extends A {
    @Override
    private void step() { }  // попытка сузить видимость
}
```
Вопрос: что скомпилируется, что нет, почему это важно?

### Ответ и объяснение
- `B` **скомпилируется** — разрешено **расширять** доступ (protected → public).
- `C` **не скомпилируется** — нельзя **сузить** видимость при переопределении (protected → private) — компилятор выдаст ошибку.
- Пояснение: если бы можно было сузить видимость, код, который оперирует ссылкой типа базового класса, мог бы потерять доступ к методу на реальном объекте подкласса, нарушая Liskov-подстановку. Поэтому Java запрещает сужение видимости, но позволяет расширение.

---

## Задача 6 — checked-исключения при переопределении
```java
class Base {
    public void read() throws java.io.IOException { }
}

class Good extends Base {
    @Override
    public void read() throws java.io.FileNotFoundException { } // A
}

class Bad extends Base {
    @Override
    public void read() throws Exception { } // B
}
```
Вопрос: какие варианты корректны и почему?

### Ответ и объяснение
- `Good` (A) — **корректно**: `FileNotFoundException` — подкласс `IOException`, переопределяющий метод может объявить **уже более узкие** (или те же) checked-исключения.
- `Bad` (B) — **некорректно**: `Exception` шире, чем `IOException`, и переопределяющий метод не может объявить более общий checked-исключение — компилятор выдаст ошибку.
- Пояснение: правило Java: при overriding checked-исключения должны быть не шире, чем у суперкласса (можно сузить или убрать), а unchecked (RuntimeException) могут быть любыми.

---

## Задача 7 — static методы (скрытие) vs instance методы (полиморфизм)
```java
class Super {
    public static void showStatic() { System.out.println("Super.static"); }
    public void showInstance() { System.out.println("Super.instance"); }
}

class Sub extends Super {
    public static void showStatic() { System.out.println("Sub.static"); }
    @Override
    public void showInstance() { System.out.println("Sub.instance"); }
}

// main:
Super s = new Sub();
s.showStatic();
s.showInstance();
```
Вопрос: что напечатает и почему?

### Ответ и объяснение
Вывод:
```
Super.static
Sub.instance
```
Пояснение:
- Статические методы **не полиморфны** — они **скрываются (hide)**, и вызов статического метода выбирается по **типу ссылки на этапе компиляции** (`Super` → `Super.showStatic()`).
- Нестатические методы виртуальны — при вызове через `s` будет динамически выбрана реализация подкласса (`Sub.showInstance()`).

---

## Задача 8 — `equals()` и нарушение контрактов при переопределении в иерархии
```java
class A {
    int x;
    A(int x){ this.x = x; }
    @Override
    public boolean equals(Object o) {
        if (!(o instanceof A)) return false;
        return x == ((A)o).x;
    }
}

class B extends A {
    int y;
    B(int x, int y){ super(x); this.y = y; }
    @Override
    public boolean equals(Object o) {
        if (!(o instanceof B)) return false;
        B b = (B)o;
        return super.equals(o) && y == b.y;
    }
}
```
Вопрос: что вернёт `a.equals(b)` и `b.equals(a)` при `A a = new A(1); B b = new B(1,2);`? Почему это опасно в коллекциях?

### Ответ и объяснение
- `a.equals(b)` → `true` (A::equals сравнивает только `x` и считает `b` экземпляром `A`).
- `b.equals(a)` → `false` (B::equals требует `instanceof B`, `a` — не `B`).
- Это **нарушает симметрию equals**, что приводит к некорректному поведению в коллекциях (`HashSet`, `HashMap`): объект может считаться равным одному элементу с одной стороны, но не с другой — возможны дубликаты, невозможность удалить или найти элемент и т.д.
- Правильные подходы: использовать `getClass()`-проверку (строгое равенство типов), применять шаблон `canEqual` (по аналогии с Apache Commons), либо сделать класс `A` финальным, либо обеспечить согласованное определение equals во всей иерархии.

---

## Задача 9 — private методы и «переопределение»
```java
class Parent {
    private void secret() { System.out.println("Parent.secret"); }
    public void call() { secret(); }
}

class Child extends Parent {
    private void secret() { System.out.println("Child.secret"); }
}

// main:
new Child().call();
```
Вопрос: что напечатает и почему? являются ли `secret()` в Parent и Child переопределениями?

### Ответ и объяснение
- Выведет:
  ```
  Parent.secret
  ```
- `Parent.secret()` и `Child.secret()` **не являются переопределениями** — `private` методы не видны подклассам и не входят в виртуальную таблицу. `Parent.call()` вызывает именно `Parent.secret()` (вызов определяется внутри класса `Parent`), поэтому реализация `Child.secret()` не влияет.
- Если нужен переопределяемый метод — делайте его `protected`/`public`.

---

## Задача 10 — изменение возвращаемого типа на несвязанное / запрещённое направление
```java
class Super {
    public String provide() { return "s"; }
}

class Good extends Super {
    @Override
    public StringBuilder provide() { return new StringBuilder("b"); } // попытка A
}

class Bad extends Super {
    @Override
    public Object provide() { return "obj"; } // попытка B
}
```
Вопрос: скомпилируются ли версии A и B? почему?

### Ответ и объяснение
- `Good` (A) **не скомпилируется**: `StringBuilder` — не подтип `String`, поэтому нельзя менять возвращаемый тип на произвольный другой тип. Ковариантность позволяет заменить возвращаемый тип **только на подтип** исходного (`String` → `StringBuilder` — это не подтип, это независимый тип) → ошибка.
- `Bad` (B) **не скомпилируется**: вы пытаетесь заменить возвращаемый тип `String` на более общий `Object` (контравариантность) — это запрещено. Переопределённый метод должен возвращать либо тот же тип, либо его подтип.
- Разрешённый вариант: если `Super.provide()` возвращает `Object`, то подкласс может вернуть `String`. Т.е. только ковариантность (подтип) разрешена, контравариантность запрещена.

Пояснение: контракт переопределения требует совместимой сигнатуры — параметрная часть должна совпадать, а возвращаемый тип может быть **уточнён** (подтип) — и только так.

---

# Дополнительные 10 задач по `override` (каждая — задача, затем сразу ответ + объяснение)

Ниже — ещё 10 нетривиальных задач для интервью по теме переопределения в Java. После каждой задачи — **ответ и объяснение** сразу под ней.

---

## Задача 11 — bridge-методы и приватные суперклассы
```java
class Outer {
    private static class Parent {
        public Number get() { return 1; }
    }
    private static class Child extends Parent {
        @Override
        public Integer get() { return 2; }
    }
}
```
Вопрос: скомпилируется ли код и будут ли bridge-методы сгенерированы, если классы `Parent` и `Child` — приватные вложенные?

### Ответ и объяснение
- Код **скомпилируется** (если находится в одном файле) — модификатор доступа вложенных классов не мешает самой семантике переопределения.
- Компилятор **по-прежнему** может сгенерировать bridge-метод для `Child` (если есть стирание типов, но в этом примере generics нет; тем не менее ковариантный return `Integer`→`Number` не требует bridge в absence of generics). Если бы `Parent` был generic (например, `Parent<T>`), тогда bridge появился бы независимо от приватности классов.
- Пояснение: приватность класса не блокирует механизм bridge; bridge зависит от различий между compile-time и runtime сигнатурами после стирания типов, а не от visibility.

---

## Задача 12 — override метода с varargs
```java
class A {
    public void log(String... msgs) { System.out.println("A"); }
}

class B extends A {
    @Override
    public void log(String[] msgs) { System.out.println("B"); } // попытка
}
```
Вопрос: скомпилируется ли код? что будет при `new B().log("x")`?

### Ответ и объяснение
- Метод `public void log(String[] msgs)` **имеет ту же сигнатуру**, что и varargs-параметр `String...` — после компиляции varargs превращается в массив. Поэтому объявление считается переопределением и **скомпилируется** (аннотация `@Override` корректна).
- Вызов `new B().log("x")` выведет `B`.
- Пояснение: varargs в Java — синтаксический сахар, компилятор использует массив; поэтому варрагс и массив с точки зрения сигнатуры — совпадают.

---

## Задача 13 — переопределение метода с generic-параметром в суперклассе (неправильная попытка)
```java
class Parent {
    public void accept(List<String> items) { }
}

class Child extends Parent {
    @Override
    public void accept(List items) { } // raw type
}
```
Вопрос: скомпилируется ли `Child`? безопасно ли такое решение?

### Ответ и объяснение
- `Child` **скомпилируется**, потому что `List` (raw) имеет стирание до `List`, также как `List<String>`. Однако компилятор выдаст предупреждение unchecked (raw type).
- Это **не безопасно**: использование raw types снимает проверку типов на этапе компиляции и может привести к `ClassCastException` или к непредвиденному поведению при работе с generics. Лучше явно использовать точную параметризацию и позволить компилятору помочь.
- Пояснение: raw types остаются для обратной совместимости, но их использование считается плохой практикой.

---

## Задача 14 — default метод интерфейса и приватный метод в интерфейсе (Java 9+)
```java
interface I {
    default void common() {
        helper();
    }
    private void helper() {
        System.out.println("I.helper");
    }
}

class C implements I { }
```
Вопрос: что напечатает `new C().common()`? Можно ли переопределить `helper()` в `C`?

### Ответ и объяснение
- Вызов `new C().common()` выведет `I.helper`.
- `helper()` в интерфейсе — **private**, поэтому класс `C` не видит и не может переопределить его. Это метод-утилита интерфейса, используемый default-реализациями.
- Пояснение: private-методы в интерфейсах (начиная с Java 9) предназначены для инкапсуляции общих фрагментов default-методов; они не часть API интерфейса для реализаций.

---

## Задача 15 — synchronized на уровне суперкласса и подкласса с блокировкой другого монитора
```java
class A {
    public synchronized void op() {
        // uses intrinsic lock on this
    }
}

class B extends A {
    @Override
    public void op() {
        synchronized(SomeClass.class) {
            // uses class lock, not this
        }
    }
}
```
Вопрос: разрешено ли такое переопределение и какие тонкие баги это может породить?

### Ответ и объяснение
- Синтаксически такое переопределение **разрешено**.
- Однако поведение синхронизации меняется: код, который ожидал, что `op()` синхронизован на `this` (например, другой поток синхронизируется `synchronized(obj)` и затем вызывает `op()`), может больше не защищён от гонок, потому что `B.op()` использует другой монитор (`SomeClass.class`). Это приведёт к тонким, трудноуловимым проблемам с конкурентностью.
- Пояснение: синхронизация — часть семантики метода; её изменение нарушает невидимые контракты для клиентов и подклассов. Лучше документировать поведение или избегать таких изменений.

---

## Задача 16 — переопределение метода и совпадение с bridge-методом сторонней библиотеки
Предположим в библиотеке есть класс
```java
public class Lib {
    public Object id() { return 1; }
}
```
и в вашем коде:
```java
public class Custom extends Lib {
    @Override
    public Integer id() { return 2; }
}
```
Вопрос: если библиотека была скомпилирована под старую версию JDK без generics, может ли появиться несовместимость? Объясните роль bridge здесь.

### Ответ и объяснение
- В большинстве случаев код **сработает**: компилятор вашего кода сгенерирует `public Integer id()` и, при необходимости, bridge `public Object id()` для совместимости. Но если библиотека ожидала точную бинарную сигнатуру и была загружена в среде с иным класс-лоадером/инструментом, теоретически возможны `NoSuchMethodError` или неожиданные вызовы.
- Bridge гарантирует, что вызовы `id()` ожидающие `Object` найдут реализацию в `Custom`. Но bridge создается компилятором для класса `Custom` — если по каким-то причинам байткод библиотеки несовместим или модифицирован, проблемы могут возникнуть.
- Пояснение: bridge-методы обычно решают обратную совместимость, но в сложных окружениях с байткод-инструментами стоит тестировать.

---

## Задача 17 — переопределение финального метода
```java
class A {
    public final void done() { System.out.println("A.done"); }
}

class B extends A {
    @Override
    public void done() { System.out.println("B.done"); } // попытка
}
```
Вопрос: скомпилируется ли `B`? почему?

### Ответ и объяснение
- `B` **не скомпилируется**: метод `done()` помечен `final` в `A`, поэтому он не может быть переопределён в подклассе. Компилятор выдаст ошибку.
- Пояснение: `final` на методе означает: поведение зафиксировано и не может быть изменено наследниками — это способ защитить контракт/внутреннюю логику базового класса.

---

## Задача 18 — переопределение equals + hashCode в наследнике
```java
class P {
    int id;
    P(int id){ this.id = id; }
    @Override
    public boolean equals(Object o) {
        if (!(o instanceof P)) return false;
        return id == ((P)o).id;
    }
    @Override
    public int hashCode() { return id; }
}

class Q extends P {
    int version;
    Q(int id, int v){ super(id); this.version = v; }
    @Override
    public boolean equals(Object o) {
        if (!(o instanceof Q)) return false;
        Q q = (Q)o;
        return super.equals(o) && version == q.version;
    }
    // hashCode не переопределён
}
```
Вопрос: какие проблемы возникнут при использовании `Q` в `HashMap`/`HashSet`?

### Ответ и объяснение
- Нарушена согласованность `equals` и `hashCode`: `Q.equals` использует `version`, но `hashCode` унаследован от `P` и зависит только от `id`. Это может привести к тому, что два объекта `Q`, которые `equals` считает разными (разный `version`), будут иметь одинаковый `hashCode`. Это допустимо (равные объекты должны иметь одинаковый hashCode; неравные — могут иметь совпадающие), но второй важный кейс — если два объекта считаются равными (id+version совпадают), их hashCode должен совпадать — он совпадёт, потому что id одинаков, но если equals сравнивает больше полей, обычно hashCode тоже должен учитывать те же поля для равномерного распределения.
- Практическая проблема: неэффективность (хеш-кошельки будут хуже) и возможные ошибки при изменении полей, используемых в equals/hashCode (mutability).
- Пояснение: всегда поддерживайте контракт: если вы изменяете логику equals, обновляйте hashCode соответственно, включая все значимые поля.

---

## Задача 19 — переопределение generic-метода с ограничением (bounded type)
```java
class Parent {
    public <T extends Number> T identity(T t) { return t; }
}

class Child extends Parent {
    @Override
    public <T extends Integer> T identity(T t) { return t; } // попытка
}
```
Вопрос: скомпилируется ли `Child`? почему?

### Ответ и объяснение
- Такой `@Override` **не скомпилируется**: сигнатуры generic-методов включают их параметры типа; `<T extends Integer>` не совместим с `<T extends Number>` — это фактически другая сигнатура метода (и `Integer` не является более общим ограничением). Компилятор укажет, что аннотация `@Override` некорректна.
- Правильный вариант переопределения — сохранить тот же generic-параметр `<T extends Number>` или убрать generic и использовать конкретный тип, но тогда это будет другая сигнатура/перегрузка.
- Пояснение: параметры типа являются частью сигнатуры при проверке совместимости переопределения; сужение bound недопустимо.

---

## Задача 20 — переопределение метода в presence of bridge and reflection
```java
class Parent {
    public Object value() { return "p"; }
}

class Child extends Parent {
    @Override
    public String value() { return "c"; }
}

public class Test {
    public static void main(String[] args) throws Exception {
        Child ch = new Child();
        Method m = Parent.class.getMethod("value");
        Object res = m.invoke(ch);
        System.out.println(res);
    }
}
```
Вопрос: что напечатает программа? нужна ли здесь bridge-метод для корректной работы через reflection?

### Ответ и объяснение
- Программа напечатает `c`.
- Reflection получает `Method m` из `Parent.class` — это метод `public Object value()`. При `m.invoke(ch)` JVM найдёт реализацию на экземпляре `ch` и вызовет её; если есть косвенность из-за различий возвращаемых типов, bridge-метод гарантирует бинарную совместимость, но в данном простом случае компилятор сгенерирует bridge `public Object value()` в `Child`, чтобы соответствовать erased-сигнатуре, и reflective вызов корректно делегирует на `Child` (или напрямую вызывает через виртуальную таблицу). Итого reflection будет работать и без дополнительных ухищрений — но bridge делает байткод безопасным.
- Пояснение: reflection обращается к методам по имени/сигнатуре; JVM разрешает виртуальный вызов на экземпляре и правильную делегацию на переопределённую реализацию; bridge здесь — инструмент обеспечения этой совместимости.

---

Если нужно, могу создать PDF с этими задачами или объединить оба markdown-файла в один документ.


[Вопросы для собеседования](README.md)
